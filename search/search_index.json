{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Welcome to MkDocs For full documentation visit mkdocs.org . Commands mkdocs new [dir-name] - Create a new project. mkdocs serve - Start the live-reloading docs server. mkdocs build - Build the documentation site. mkdocs help - Print this help message. Project layout mkdocs.yml # The configuration file. docs/ index.md # The documentation homepage. ... # Other markdown pages, images and other files.","title":"Home"},{"location":"#welcome-to-mkdocs","text":"For full documentation visit mkdocs.org .","title":"Welcome to MkDocs"},{"location":"#commands","text":"mkdocs new [dir-name] - Create a new project. mkdocs serve - Start the live-reloading docs server. mkdocs build - Build the documentation site. mkdocs help - Print this help message.","title":"Commands"},{"location":"#project-layout","text":"mkdocs.yml # The configuration file. docs/ index.md # The documentation homepage. ... # Other markdown pages, images and other files.","title":"Project layout"},{"location":"00-environment-setup/","text":"Environement Setup AWS Account Setup Create a AWS Free Tier Account to get started. Terraform Installation Best way to install Terraform is by referring to the official documentation , finding the current version and following the procedure published there. Following are a few ways of installing terraform as part of the lab setup, however, I would recommend you to follow the official document neverthless. Ubuntu Follow the following steps to install Terraform on ubuntu. wget -O- https://apt.releases.hashicorp.com/gpg | gpg --dearmor | sudo tee /usr/share/keyrings/hashicorp-archive-keyring.gpg echo \"deb [signed-by=/usr/share/keyrings/hashicorp-archive-keyring.gpg] https://apt.releases.hashicorp.com $(lsb_release -cs) main\" | sudo tee /etc/apt/sources.list.d/hashicorp.list sudo apt update && sudo apt install terraform Windows Visit the following link to download the Terraform executable. Terraform for Windows . Extract the file. Copy the extracted file. Create a new directory called Terrafrom insice C:\\Program Files\\ Paste the file we have copied in the previous step. Copy the file path for the executable. Search for environment from your start menu. Then select environment variables form the window. Select Path variable and edit it. Add the path that we have copied earlier. MacOS There are at least two ways of installing terraform on Mac OS, either using a package manager such as homebrew, or downloading a binary and placing it in the path. Installing with Homebrew brew tap hashicorp/tap brew install hashicorp/tap/terraform validate by running terraform -version To update existing terraform to the latest version use the following commands, brew update brew upgrade hashicorp/tap/terraform Installing with a Binary Download the latest version of terraform from https://www.terraform.io/downloads Following is an example of downloading and installing 1.2.8 version. However, you should modify it as per the current version available. wget https://releases.hashicorp.com/terraform/1.2.8/terraform_1.2.8_darwin_amd64.zip unzip terraform_1.2.8_darwin_amd64.zip sudo mv terraform /usr/local/bin sudo chmod +x /usr/local/bin/terraform Validate the Installation Open a Shell session and run terraform -v . This should produce the following output. terraform -v [sample output] Terraform v1.2.8 on darwin_arm64","title":"Setting up the environment"},{"location":"00-environment-setup/#environement-setup","text":"","title":"Environement Setup"},{"location":"00-environment-setup/#aws-account-setup","text":"Create a AWS Free Tier Account to get started.","title":"AWS Account Setup"},{"location":"00-environment-setup/#terraform-installation","text":"Best way to install Terraform is by referring to the official documentation , finding the current version and following the procedure published there. Following are a few ways of installing terraform as part of the lab setup, however, I would recommend you to follow the official document neverthless.","title":"Terraform Installation"},{"location":"00-environment-setup/#ubuntu","text":"Follow the following steps to install Terraform on ubuntu. wget -O- https://apt.releases.hashicorp.com/gpg | gpg --dearmor | sudo tee /usr/share/keyrings/hashicorp-archive-keyring.gpg echo \"deb [signed-by=/usr/share/keyrings/hashicorp-archive-keyring.gpg] https://apt.releases.hashicorp.com $(lsb_release -cs) main\" | sudo tee /etc/apt/sources.list.d/hashicorp.list sudo apt update && sudo apt install terraform","title":"Ubuntu"},{"location":"00-environment-setup/#windows","text":"Visit the following link to download the Terraform executable. Terraform for Windows . Extract the file. Copy the extracted file. Create a new directory called Terrafrom insice C:\\Program Files\\ Paste the file we have copied in the previous step. Copy the file path for the executable. Search for environment from your start menu. Then select environment variables form the window. Select Path variable and edit it. Add the path that we have copied earlier.","title":"Windows"},{"location":"00-environment-setup/#macos","text":"There are at least two ways of installing terraform on Mac OS, either using a package manager such as homebrew, or downloading a binary and placing it in the path.","title":"MacOS"},{"location":"00-environment-setup/#installing-with-homebrew","text":"brew tap hashicorp/tap brew install hashicorp/tap/terraform validate by running terraform -version To update existing terraform to the latest version use the following commands, brew update brew upgrade hashicorp/tap/terraform","title":"Installing with Homebrew"},{"location":"00-environment-setup/#installing-with-a-binary","text":"Download the latest version of terraform from https://www.terraform.io/downloads Following is an example of downloading and installing 1.2.8 version. However, you should modify it as per the current version available. wget https://releases.hashicorp.com/terraform/1.2.8/terraform_1.2.8_darwin_amd64.zip unzip terraform_1.2.8_darwin_amd64.zip sudo mv terraform /usr/local/bin sudo chmod +x /usr/local/bin/terraform","title":"Installing with a Binary"},{"location":"00-environment-setup/#validate-the-installation","text":"Open a Shell session and run terraform -v . This should produce the following output. terraform -v [sample output] Terraform v1.2.8 on darwin_arm64","title":"Validate the Installation"},{"location":"01-getting-started/","text":"Lab 3 : Getting Started with Terraform In this lab you are going to learn how to, * Create a Terraform Configuration * Add and initialise a Cloud Provisioner * Write a Resource by using HCL * Validate Configurations * Create a Change Plan * Apply Configurations to Build Actual Infrastructure * Modify Existing Infrastructure created with Terraform * Destroy the Infrastructure created by Terraform Getting Started with terraform CLI You could get started with terraform and check the list of commands for Terraform by running, terrform -h From the commands listed , the following are most commonly used ones, terraform init terraform validate terraform plan terraform apply terraform destroy Adding Terraform Configurations mkdir terraform-code cd terraform-code You will begin by defining required_providers block for terraform. This defines which providers should terraform install, from where, and which version. Create main.tf with the following initial configuration terraform { required_providers { aws = { source = \"registry.terraform.io/hashicorp/aws\" version = \"~> 4.29\" } } } Provider Source Components You could read more about Provider Requirements at Provider Requirements - Configuration Language | Terraform by HashiCorp and about AWS Provider\u2019s Version etc. used above at https://registry.terraform.io/providers/hashicorp/aws/latest. Check the providers configuration using terraform providers Adding AWS Cloud Provider In Terraform, Providers are responsible for understanding API interactions from * IaaS : e.g. AWS, Azure, GCP * PaaS : e.g. Heroku, Kubernetes * SaaS : e.g. CloudFlare, DNSSimple, DNSMadeEasy Let\u2019s add AWS provider to main.tf as follows, provider \"aws\" { region = \"us-east-1\" } As seen in the above given example, Provider is a way to instruct Terraform to interact with AWS API. Every provider needs some kind of credentials to get authenticated with the API. In this example, we would provide AWS access key and secret key by adding those to the environment. Export your AWS access and secret keys as environment variables. export AWS_ACCESS_KEY_ID=\"Access-Key\" export AWS_SECRET_ACCESS_KEY=\"Secret-Key\" You could also add the above lines to your ~/.bashrc , ~/.zshrc files based on which shell you are using to avoid setting these credentials every time you open a new shell. Now run the following command to initialize your environment. terraform init This should initialize the environment by * Installing the provider from the registry as defined in main.tf * Adding a lock file .terraform.lock.hcl to record the provider details installed. Launching a EC2 Instance with Terraform To create anything with terraform, you need to write a Resource. You could get started by reading about using Resources here Resources Overview - Configuration Language | Terraform by HashiCorp Resources are the building block in Terraform. These the actual cloud entities that you are either creating/deleting or modifying. Following is a syntax for writing a simple resource. There are a few more properties such as meta-arguments, condition checks, timeouts etc. which we would explore later. To get started, with the AWS provider, you would create EC2 instance by using aws_instance as a resource. You could refer to this document Terraform Registry , to find the details about using this resource. You should be specially paying attention to the Argument References Add the following code to same main.tf file to define creation of a new EC2 instance by name frontend . resource \"aws_instance\" \"frontend\" { ami = \"ami-052efd3df9dad4825\" instance_type = \"t2.micro\" tags = { Name = \"tf-frontend-01\" App = \"devops-demo\" Maintainer = \"Gourav Shah\" } } Validate terraform configurations with, terraform validate Optionally, you could further format the configuration file automatically to follow correct terraform style with, terraform fmt Now you could let Terraform create a Change Plan using the following command, terraform plan To apply this plan and build actual infrastructure, in this case create a ec2 instance with, terraform apply Terraform apply first generates a plan and then asks for approval as, [Sample Output] Plan: 1 to add, 0 to change, 0 to destroy. Do you want to perform these actions? Terraform will perform the actions described above. Only 'yes' will be accepted to approve. Enter a value: yes Say yes to proceed, which will create the instance. [Sample Output] aws_instance.frontend: Creating... aws_instance.frontend: Still creating... [10s elapsed] aws_instance.frontend: Still creating... [20s elapsed] aws_instance.frontend: Still creating... [30s elapsed] aws_instance.frontend: Creation complete after 36s [id=i-04b03b981dbc55d7c] Apply complete! Resources: 1 added, 0 changed, 0 destroyed. Try running apply command again. terraform apply It does nothing this time since the instance was already created. Check the state file created using the following or similar command specific to your OS, cat terraform.tfstate Modifying Properties of an Existing Instance Begin by applying terraform once terraform apply Since there is no change from the previous run, it does not plan to change anything. The property of terraform where it refreshes the current state, compares it with the desired state, and decides to make change only if necessary is idempotence. This makes terraform safe to apply multiple times. Lets try making a change by adding a property which is mutable. To do this, just add one more tag to the existing map of tags as, ... tags = { Name = \"tf-frontend-01\" App = \"devops-demo\" Maintainer = \"Gourav Shah\" Role = \"frontend\" } } Where Role = \"frontend\" is the new property. [Sample Output] # aws_instance.frontend will be updated in-place ~ resource \"aws_instance\" \"frontend\" { id = \"i-04b03b981dbc55d7c\" ~ tags = { + \"Role\" = \"frontend\" # (3 unchanged elements hidden) } ~ tags_all = { + \"Role\" = \"frontend\" # (3 unchanged elements hidden) } # (29 unchanged attributes hidden) # (7 unchanged blocks hidden) } Since this property is mutable , it would update the instance in place, without needing for it to be recreate. Say yes to apply the changes. Now, try updating a property which is immutable e.g. keypair. Update main.tf by adding a key pair to be associated with this instance. resource \"aws_instance\" \"frontend\" { ami = \"ami-052efd3df9dad4825\" instance_type = \"t2.micro\" key_name = \"demo\" tags = { Name = \"tf-frontend-01\" App = \"devops-demo\" Maintainer = \"Gourav Shah\" Role = \"frontend\" } } Where, key_name = \"demo\" is the new argument added. Ensure a key pair by name demo is present on AWS for the region for which you are creating this instance. terraform apply This time terraform plan should show you that its going to recreate the instance, since the change is immutable. # aws_instance.frontend must be replaced -/+ resource \"aws_instance\" \"frontend\" { ~ arn = \"arn:aws:ec2:us-east-1:665496447754:instance/i-0a477fc11e0055d72\" -> (known after apply) ~ associate_public_ip_address = true -> (known after apply) .. .. + key_name = \"demo\" # forces replacement .. .. Plan: 1 to add, 0 to change, 1 to destroy. Do you want to perform these actions? Say yes to have the instance be recreated, this time with a key pair. [Sample Output] aws_instance.frontend: Destroying... [id=i-0a477fc11e0055d72] aws_instance.frontend: Still destroying... [id=i-0a477fc11e0055d72, 10s elapsed] aws_instance.frontend: Still destroying... [id=i-0a477fc11e0055d72, 20s elapsed] aws_instance.frontend: Still destroying... [id=i-0a477fc11e0055d72, 30s elapsed] aws_instance.frontend: Destruction complete after 32s aws_instance.frontend: Creating... aws_instance.frontend: Still creating... [10s elapsed] aws_instance.frontend: Still creating... [20s elapsed] aws_instance.frontend: Still creating... [30s elapsed] aws_instance.frontend: Creation complete after 37s [id=i-02b2a78e90ac9e89e] Apply complete! Resources: 1 added, 0 changed, 1 destroyed. If you check from the AWS Console, you shall now see a new instance created, this time associated with the keypair you defined e.g. demo as shows in the image below. Deleting Instance with Terraform Destroy terraform destroy -auto-approve [Sample Output] Terraform will perform the following actions: # aws_instance.frontend will be destroyed - resource \"aws_instance\" \"frontend\" { - ami = \"ami-052efd3df9dad4825\" -> null .. ... Plan: 0 to add, 0 to change, 1 to destroy. aws_instance.frontend: Destroying... [id=i-02b2a78e90ac9e89e] aws_instance.frontend: Still destroying... [id=i-02b2a78e90ac9e89e, 10s elapsed] aws_instance.frontend: Still destroying... [id=i-02b2a78e90ac9e89e, 20s elapsed] aws_instance.frontend: Still destroying... [id=i-02b2a78e90ac9e89e, 30s elapsed] aws_instance.frontend: Destruction complete after 32s Destroy complete! Resources: 1 destroyed. Summary In this lab, you learnt how to get started with terraform to build your infrastructure. You configured terraform, added and initialised a provider, created a resource using HCL (Hashicorp Configuration Language), learnt to apply the configuration and also to modify and destroy a resource with terraform.","title":"Getting Started with Terraform"},{"location":"01-getting-started/#lab-3-getting-started-with-terraform","text":"In this lab you are going to learn how to, * Create a Terraform Configuration * Add and initialise a Cloud Provisioner * Write a Resource by using HCL * Validate Configurations * Create a Change Plan * Apply Configurations to Build Actual Infrastructure * Modify Existing Infrastructure created with Terraform * Destroy the Infrastructure created by Terraform","title":"Lab 3 : Getting Started with Terraform"},{"location":"01-getting-started/#getting-started-with-terraform-cli","text":"You could get started with terraform and check the list of commands for Terraform by running, terrform -h From the commands listed , the following are most commonly used ones, terraform init terraform validate terraform plan terraform apply terraform destroy","title":"Getting Started with terraform CLI"},{"location":"01-getting-started/#adding-terraform-configurations","text":"mkdir terraform-code cd terraform-code You will begin by defining required_providers block for terraform. This defines which providers should terraform install, from where, and which version. Create main.tf with the following initial configuration terraform { required_providers { aws = { source = \"registry.terraform.io/hashicorp/aws\" version = \"~> 4.29\" } } } Provider Source Components You could read more about Provider Requirements at Provider Requirements - Configuration Language | Terraform by HashiCorp and about AWS Provider\u2019s Version etc. used above at https://registry.terraform.io/providers/hashicorp/aws/latest. Check the providers configuration using terraform providers","title":"Adding Terraform Configurations"},{"location":"01-getting-started/#adding-aws-cloud-provider","text":"In Terraform, Providers are responsible for understanding API interactions from * IaaS : e.g. AWS, Azure, GCP * PaaS : e.g. Heroku, Kubernetes * SaaS : e.g. CloudFlare, DNSSimple, DNSMadeEasy Let\u2019s add AWS provider to main.tf as follows, provider \"aws\" { region = \"us-east-1\" } As seen in the above given example, Provider is a way to instruct Terraform to interact with AWS API. Every provider needs some kind of credentials to get authenticated with the API. In this example, we would provide AWS access key and secret key by adding those to the environment. Export your AWS access and secret keys as environment variables. export AWS_ACCESS_KEY_ID=\"Access-Key\" export AWS_SECRET_ACCESS_KEY=\"Secret-Key\" You could also add the above lines to your ~/.bashrc , ~/.zshrc files based on which shell you are using to avoid setting these credentials every time you open a new shell. Now run the following command to initialize your environment. terraform init This should initialize the environment by * Installing the provider from the registry as defined in main.tf * Adding a lock file .terraform.lock.hcl to record the provider details installed.","title":"Adding AWS Cloud Provider"},{"location":"01-getting-started/#launching-a-ec2-instance-with-terraform","text":"To create anything with terraform, you need to write a Resource. You could get started by reading about using Resources here Resources Overview - Configuration Language | Terraform by HashiCorp Resources are the building block in Terraform. These the actual cloud entities that you are either creating/deleting or modifying. Following is a syntax for writing a simple resource. There are a few more properties such as meta-arguments, condition checks, timeouts etc. which we would explore later. To get started, with the AWS provider, you would create EC2 instance by using aws_instance as a resource. You could refer to this document Terraform Registry , to find the details about using this resource. You should be specially paying attention to the Argument References Add the following code to same main.tf file to define creation of a new EC2 instance by name frontend . resource \"aws_instance\" \"frontend\" { ami = \"ami-052efd3df9dad4825\" instance_type = \"t2.micro\" tags = { Name = \"tf-frontend-01\" App = \"devops-demo\" Maintainer = \"Gourav Shah\" } } Validate terraform configurations with, terraform validate Optionally, you could further format the configuration file automatically to follow correct terraform style with, terraform fmt Now you could let Terraform create a Change Plan using the following command, terraform plan To apply this plan and build actual infrastructure, in this case create a ec2 instance with, terraform apply Terraform apply first generates a plan and then asks for approval as, [Sample Output] Plan: 1 to add, 0 to change, 0 to destroy. Do you want to perform these actions? Terraform will perform the actions described above. Only 'yes' will be accepted to approve. Enter a value: yes Say yes to proceed, which will create the instance. [Sample Output] aws_instance.frontend: Creating... aws_instance.frontend: Still creating... [10s elapsed] aws_instance.frontend: Still creating... [20s elapsed] aws_instance.frontend: Still creating... [30s elapsed] aws_instance.frontend: Creation complete after 36s [id=i-04b03b981dbc55d7c] Apply complete! Resources: 1 added, 0 changed, 0 destroyed. Try running apply command again. terraform apply It does nothing this time since the instance was already created. Check the state file created using the following or similar command specific to your OS, cat terraform.tfstate","title":"Launching a EC2 Instance with Terraform"},{"location":"01-getting-started/#modifying-properties-of-an-existing-instance","text":"Begin by applying terraform once terraform apply Since there is no change from the previous run, it does not plan to change anything. The property of terraform where it refreshes the current state, compares it with the desired state, and decides to make change only if necessary is idempotence. This makes terraform safe to apply multiple times. Lets try making a change by adding a property which is mutable. To do this, just add one more tag to the existing map of tags as, ... tags = { Name = \"tf-frontend-01\" App = \"devops-demo\" Maintainer = \"Gourav Shah\" Role = \"frontend\" } } Where Role = \"frontend\" is the new property. [Sample Output] # aws_instance.frontend will be updated in-place ~ resource \"aws_instance\" \"frontend\" { id = \"i-04b03b981dbc55d7c\" ~ tags = { + \"Role\" = \"frontend\" # (3 unchanged elements hidden) } ~ tags_all = { + \"Role\" = \"frontend\" # (3 unchanged elements hidden) } # (29 unchanged attributes hidden) # (7 unchanged blocks hidden) } Since this property is mutable , it would update the instance in place, without needing for it to be recreate. Say yes to apply the changes. Now, try updating a property which is immutable e.g. keypair. Update main.tf by adding a key pair to be associated with this instance. resource \"aws_instance\" \"frontend\" { ami = \"ami-052efd3df9dad4825\" instance_type = \"t2.micro\" key_name = \"demo\" tags = { Name = \"tf-frontend-01\" App = \"devops-demo\" Maintainer = \"Gourav Shah\" Role = \"frontend\" } } Where, key_name = \"demo\" is the new argument added. Ensure a key pair by name demo is present on AWS for the region for which you are creating this instance. terraform apply This time terraform plan should show you that its going to recreate the instance, since the change is immutable. # aws_instance.frontend must be replaced -/+ resource \"aws_instance\" \"frontend\" { ~ arn = \"arn:aws:ec2:us-east-1:665496447754:instance/i-0a477fc11e0055d72\" -> (known after apply) ~ associate_public_ip_address = true -> (known after apply) .. .. + key_name = \"demo\" # forces replacement .. .. Plan: 1 to add, 0 to change, 1 to destroy. Do you want to perform these actions? Say yes to have the instance be recreated, this time with a key pair. [Sample Output] aws_instance.frontend: Destroying... [id=i-0a477fc11e0055d72] aws_instance.frontend: Still destroying... [id=i-0a477fc11e0055d72, 10s elapsed] aws_instance.frontend: Still destroying... [id=i-0a477fc11e0055d72, 20s elapsed] aws_instance.frontend: Still destroying... [id=i-0a477fc11e0055d72, 30s elapsed] aws_instance.frontend: Destruction complete after 32s aws_instance.frontend: Creating... aws_instance.frontend: Still creating... [10s elapsed] aws_instance.frontend: Still creating... [20s elapsed] aws_instance.frontend: Still creating... [30s elapsed] aws_instance.frontend: Creation complete after 37s [id=i-02b2a78e90ac9e89e] Apply complete! Resources: 1 added, 0 changed, 1 destroyed. If you check from the AWS Console, you shall now see a new instance created, this time associated with the keypair you defined e.g. demo as shows in the image below.","title":"Modifying Properties of an Existing Instance"},{"location":"01-getting-started/#deleting-instance-with-terraform-destroy","text":"terraform destroy -auto-approve [Sample Output] Terraform will perform the following actions: # aws_instance.frontend will be destroyed - resource \"aws_instance\" \"frontend\" { - ami = \"ami-052efd3df9dad4825\" -> null .. ... Plan: 0 to add, 0 to change, 1 to destroy. aws_instance.frontend: Destroying... [id=i-02b2a78e90ac9e89e] aws_instance.frontend: Still destroying... [id=i-02b2a78e90ac9e89e, 10s elapsed] aws_instance.frontend: Still destroying... [id=i-02b2a78e90ac9e89e, 20s elapsed] aws_instance.frontend: Still destroying... [id=i-02b2a78e90ac9e89e, 30s elapsed] aws_instance.frontend: Destruction complete after 32s Destroy complete! Resources: 1 destroyed.","title":"Deleting  Instance with Terraform Destroy"},{"location":"01-getting-started/#summary","text":"In this lab, you learnt how to get started with terraform to build your infrastructure. You configured terraform, added and initialised a provider, created a resource using HCL (Hashicorp Configuration Language), learnt to apply the configuration and also to modify and destroy a resource with terraform.","title":"Summary"},{"location":"02-terraform-important-commands/","text":"Important Terraform Commands Terraform Plan When you run terraform plan it will present you with the execution plan . This will show you which resources are going to be created/deleted or modified. This is more like a dry run, if you want to see what your code will do before you apply it. Example terrform plan [output] Acquiring state lock. This may take a few moments... Refreshing Terraform state in-memory prior to plan... The refreshed state will be used to calculate this plan, but will not be persisted to local or remote state storage. aws_security_group.webserver_sg: Refreshing state... (ID: sg-04b81bcdfa7f287b0) aws_key_pair.webserver_key: Refreshing state... (ID: web-admin-key) aws_instance.webserver: Refreshing state... (ID: i-00ddea272445bd4ec) ------------------------------------------------------------------------ An execution plan has been generated and is shown below. Resource actions are indicated with the following symbols: -/+ destroy and then create replacement Terraform will perform the following actions: -/+ aws_instance.webserver (tainted) (new resource required) id: \"i-00ddea272445bd4ec\" => <computed> (forces new resource) ami: \"ami-408c7f28\" => \"ami-408c7f28\" arn: \"arn:aws:ec2:us-east-1:822941572458:instance/i-00ddea272445bd4ec\" => <computed> associate_public_ip_address: \"true\" => <computed> availability_zone: \"us-east-1a\" => <computed> cpu_core_count: \"1\" => <computed> cpu_threads_per_core: \"1\" => <computed> ebs_block_device.#: \"0\" => <computed> ephemeral_block_device.#: \"0\" => <computed> get_password_data: \"false\" => \"false\" instance_state: \"running\" => <computed> instance_type: \"t1.micro\" => \"t1.micro\" ipv6_address_count: \"\" => <computed> ipv6_addresses.#: \"0\" => <computed> key_name: \"web-admin-key\" => \"web-admin-key\" network_interface.#: \"0\" => <computed> network_interface_id: \"eni-0e92356540e1a2f47\" => <computed> password_data: \"\" => <computed> placement_group: \"\" => <computed> primary_network_interface_id: \"eni-0e92356540e1a2f47\" => <computed> private_dns: \"ip-172-31-38-119.ec2.internal\" => <computed> private_ip: \"172.31.38.119\" => <computed> public_dns: \"ec2-35-173-130-100.compute-1.amazonaws.com\" => <computed> public_ip: \"35.173.130.100\" => <computed> root_block_device.#: \"1\" => <computed> security_groups.#: \"1\" => <computed> source_dest_check: \"true\" => \"true\" subnet_id: \"subnet-d363e58f\" => <computed> tags.%: \"1\" => \"1\" tags.Name: \"demo-server\" => \"demo-server\" tenancy: \"default\" => <computed> volume_tags.%: \"0\" => <computed> vpc_security_group_ids.#: \"1\" => \"1\" vpc_security_group_ids.3215502186: \"sg-04b81bcdfa7f287b0\" => \"sg-04b81bcdfa7f287b0\" Plan: 1 to add, 0 to change, 1 to destroy. ------------------------------------------------------------------------ Note: You didn't specify an \"-out\" parameter to save this plan, so Terraform can't guarantee that exactly these actions will be performed if \"terraform apply\" is subsequently run. Releasing state lock. This may take a few moments... Terraform Apply Terraform apply is command which creates the resources for us. The output will look similar to terraform plan but this time you will be prompted for permisson on your console. The output is truncated from the original. Example aws_security_group.webserver_sg: Refreshing state... (ID: sg-04b81bcdfa7f287b0) aws_key_pair.webserver_key: Refreshing state... (ID: web-admin-key) aws_instance.webserver: Refreshing state... (ID: i-00ddea272445bd4ec) An execution plan has been generated and is shown below. Resource actions are indicated with the following symbols: -/+ destroy and then create replacement Terraform will perform the following actions: -/+ aws_instance.webserver (tainted) (new resource required) id: \"i-00ddea272445bd4ec\" => <computed> (forces new resource) ami: \"ami-408c7f28\" => \"ami-408c7f28\" arn: \"arn:aws:ec2:us-east-1:822941572458:instance/ [...] volume_tags.%: \"0\" => <computed> vpc_security_group_ids.#: \"1\" => \"1\" vpc_security_group_ids.3215502186: \"sg-04b81bcdfa7f287b0\" => \"sg-04b81bcdfa7f287b0\" Plan: 1 to add, 0 to change, 1 to destroy. Do you want to perform these actions? Terraform will perform the actions described above. Only 'yes' will be accepted to approve. Enter a value: yes aws_instance.webserver: Destroying... (ID: i-00ddea272445bd4ec) aws_instance.webserver: Destruction complete after 49s [...] Terraform Destroy This command will delete everything that terraform manages for you. So we need to be really careful when we run this command and only run it when you know what you are doing. Example terraform destroy [output] Acquiring state lock. This may take a few moments... aws_security_group.webserver_sg: Refreshing state... (ID: sg-04b81bcdfa7f287b0) aws_key_pair.webserver_key: Refreshing state... (ID: web-admin-key) aws_instance.webserver: Refreshing state... (ID: i-04264d266661e096d) An execution plan has been generated and is shown below. Resource actions are indicated with the following symbols: - destroy Terraform will perform the following actions: - aws_instance.webserver - aws_key_pair.webserver_key - aws_security_group.webserver_sg Plan: 0 to add, 0 to change, 3 to destroy. Do you really want to destroy? Terraform will destroy all your managed infrastructure, as shown above. There is no undo. Only 'yes' will be accepted to confirm. Enter a value: yes [...] Terraform init The terraform init command is used to initialize a working directory containing Terraform configuration files. This is the first command that should be run after writing a new Terraform configuration or cloning an existing one from version control. It is safe to run this command multiple times. Example terraform init [Output] Initializing provider plugins... - Checking for available provider plugins on https://releases.hashicorp.com... - Downloading plugin for provider \"aws\" (1.37.0)... The following providers do not have any version constraints in configuration, so the latest version was installed. To prevent automatic upgrades to new major versions that may contain breaking changes, it is recommended to add version = \"...\" constraints to the corresponding provider blocks in configuration, with the constraint strings suggested below. * provider.aws: version = \"~> 1.37\" Terraform has been successfully initialized! You may now begin working with Terraform. Try running \"terraform plan\" to see any changes that are required for your infrastructure. All Terraform commands should now work. If you ever set or change modules or backend configuration for Terraform, rerun this command to reinitialize your working directory. If you forget, other commands will detect it and remind you to do so if necessary. Terraform fmt The terraform fmt command is used to rewrite Terraform configuration files to a canonical format and style.","title":"Important Commands"},{"location":"02-terraform-important-commands/#important-terraform-commands","text":"","title":"Important Terraform Commands"},{"location":"02-terraform-important-commands/#terraform-plan","text":"When you run terraform plan it will present you with the execution plan . This will show you which resources are going to be created/deleted or modified. This is more like a dry run, if you want to see what your code will do before you apply it. Example terrform plan [output] Acquiring state lock. This may take a few moments... Refreshing Terraform state in-memory prior to plan... The refreshed state will be used to calculate this plan, but will not be persisted to local or remote state storage. aws_security_group.webserver_sg: Refreshing state... (ID: sg-04b81bcdfa7f287b0) aws_key_pair.webserver_key: Refreshing state... (ID: web-admin-key) aws_instance.webserver: Refreshing state... (ID: i-00ddea272445bd4ec) ------------------------------------------------------------------------ An execution plan has been generated and is shown below. Resource actions are indicated with the following symbols: -/+ destroy and then create replacement Terraform will perform the following actions: -/+ aws_instance.webserver (tainted) (new resource required) id: \"i-00ddea272445bd4ec\" => <computed> (forces new resource) ami: \"ami-408c7f28\" => \"ami-408c7f28\" arn: \"arn:aws:ec2:us-east-1:822941572458:instance/i-00ddea272445bd4ec\" => <computed> associate_public_ip_address: \"true\" => <computed> availability_zone: \"us-east-1a\" => <computed> cpu_core_count: \"1\" => <computed> cpu_threads_per_core: \"1\" => <computed> ebs_block_device.#: \"0\" => <computed> ephemeral_block_device.#: \"0\" => <computed> get_password_data: \"false\" => \"false\" instance_state: \"running\" => <computed> instance_type: \"t1.micro\" => \"t1.micro\" ipv6_address_count: \"\" => <computed> ipv6_addresses.#: \"0\" => <computed> key_name: \"web-admin-key\" => \"web-admin-key\" network_interface.#: \"0\" => <computed> network_interface_id: \"eni-0e92356540e1a2f47\" => <computed> password_data: \"\" => <computed> placement_group: \"\" => <computed> primary_network_interface_id: \"eni-0e92356540e1a2f47\" => <computed> private_dns: \"ip-172-31-38-119.ec2.internal\" => <computed> private_ip: \"172.31.38.119\" => <computed> public_dns: \"ec2-35-173-130-100.compute-1.amazonaws.com\" => <computed> public_ip: \"35.173.130.100\" => <computed> root_block_device.#: \"1\" => <computed> security_groups.#: \"1\" => <computed> source_dest_check: \"true\" => \"true\" subnet_id: \"subnet-d363e58f\" => <computed> tags.%: \"1\" => \"1\" tags.Name: \"demo-server\" => \"demo-server\" tenancy: \"default\" => <computed> volume_tags.%: \"0\" => <computed> vpc_security_group_ids.#: \"1\" => \"1\" vpc_security_group_ids.3215502186: \"sg-04b81bcdfa7f287b0\" => \"sg-04b81bcdfa7f287b0\" Plan: 1 to add, 0 to change, 1 to destroy. ------------------------------------------------------------------------ Note: You didn't specify an \"-out\" parameter to save this plan, so Terraform can't guarantee that exactly these actions will be performed if \"terraform apply\" is subsequently run. Releasing state lock. This may take a few moments...","title":"Terraform Plan"},{"location":"02-terraform-important-commands/#terraform-apply","text":"Terraform apply is command which creates the resources for us. The output will look similar to terraform plan but this time you will be prompted for permisson on your console. The output is truncated from the original. Example aws_security_group.webserver_sg: Refreshing state... (ID: sg-04b81bcdfa7f287b0) aws_key_pair.webserver_key: Refreshing state... (ID: web-admin-key) aws_instance.webserver: Refreshing state... (ID: i-00ddea272445bd4ec) An execution plan has been generated and is shown below. Resource actions are indicated with the following symbols: -/+ destroy and then create replacement Terraform will perform the following actions: -/+ aws_instance.webserver (tainted) (new resource required) id: \"i-00ddea272445bd4ec\" => <computed> (forces new resource) ami: \"ami-408c7f28\" => \"ami-408c7f28\" arn: \"arn:aws:ec2:us-east-1:822941572458:instance/ [...] volume_tags.%: \"0\" => <computed> vpc_security_group_ids.#: \"1\" => \"1\" vpc_security_group_ids.3215502186: \"sg-04b81bcdfa7f287b0\" => \"sg-04b81bcdfa7f287b0\" Plan: 1 to add, 0 to change, 1 to destroy. Do you want to perform these actions? Terraform will perform the actions described above. Only 'yes' will be accepted to approve. Enter a value: yes aws_instance.webserver: Destroying... (ID: i-00ddea272445bd4ec) aws_instance.webserver: Destruction complete after 49s [...]","title":"Terraform Apply"},{"location":"02-terraform-important-commands/#terraform-destroy","text":"This command will delete everything that terraform manages for you. So we need to be really careful when we run this command and only run it when you know what you are doing. Example terraform destroy [output] Acquiring state lock. This may take a few moments... aws_security_group.webserver_sg: Refreshing state... (ID: sg-04b81bcdfa7f287b0) aws_key_pair.webserver_key: Refreshing state... (ID: web-admin-key) aws_instance.webserver: Refreshing state... (ID: i-04264d266661e096d) An execution plan has been generated and is shown below. Resource actions are indicated with the following symbols: - destroy Terraform will perform the following actions: - aws_instance.webserver - aws_key_pair.webserver_key - aws_security_group.webserver_sg Plan: 0 to add, 0 to change, 3 to destroy. Do you really want to destroy? Terraform will destroy all your managed infrastructure, as shown above. There is no undo. Only 'yes' will be accepted to confirm. Enter a value: yes [...]","title":"Terraform Destroy"},{"location":"02-terraform-important-commands/#terraform-init","text":"The terraform init command is used to initialize a working directory containing Terraform configuration files. This is the first command that should be run after writing a new Terraform configuration or cloning an existing one from version control. It is safe to run this command multiple times. Example terraform init [Output] Initializing provider plugins... - Checking for available provider plugins on https://releases.hashicorp.com... - Downloading plugin for provider \"aws\" (1.37.0)... The following providers do not have any version constraints in configuration, so the latest version was installed. To prevent automatic upgrades to new major versions that may contain breaking changes, it is recommended to add version = \"...\" constraints to the corresponding provider blocks in configuration, with the constraint strings suggested below. * provider.aws: version = \"~> 1.37\" Terraform has been successfully initialized! You may now begin working with Terraform. Try running \"terraform plan\" to see any changes that are required for your infrastructure. All Terraform commands should now work. If you ever set or change modules or backend configuration for Terraform, rerun this command to reinitialize your working directory. If you forget, other commands will detect it and remind you to do so if necessary.","title":"Terraform init"},{"location":"02-terraform-important-commands/#terraform-fmt","text":"The terraform fmt command is used to rewrite Terraform configuration files to a canonical format and style.","title":"Terraform fmt"},{"location":"03-providers/","text":"Providers In Terraform, Providers are responsible for understanding API interactions from * IaaS : e.g. AWS, Azure, GCP * PaaS : e.g. Heroku, Kubernetes * SaaS : e.g. CloudFlare, DNSSimple, DNSMadeEasy Example Provider Let's look at AWS Provider as an example. provider \"aws\" { access_key = \"${var.aws_access_key}\" secret_key = \"${var.aws_secret_key}\" region = \"us-east-1\" } As seen in the above given example, Provider is a way to instruct Terraform to interact with AWS API. Every provider needs some kind of credentials to get authenticated with the API. In our example, we have porvided AWS access key and secret key to perform the same. Setting up our environment for AWS Let us set up our environment by creating a directory called aws . mkdir aws cd aws After changing directory into aws , we need to create a file named main.tf . touch main.tf Define your Provider details in this main manifest. Change the region if you want to create the resources elsewhere. provider \"aws\" { region = \"us-east-1\" } Export your AWS access and secret keys as environment variables. export AWS_ACCESS_KEY_ID=\"Access-Key\" export AWS_SECRET_ACCESS_KEY=\"Secret-Key\" Finally run the following command to initialize your environment. terraform init [output] Initializing provider plugins... - Checking for available provider plugins on https://releases.hashicorp.com... - Downloading plugin for provider \"aws\" (1.37.0)... The following providers do not have any version constraints in configuration, so the latest version was installed. To prevent automatic upgrades to new major versions that may contain breaking changes, it is recommended to add version = \"...\" constraints to the corresponding provider blocks in configuration, with the constraint strings suggested below. * provider.aws: version = \"~> 1.37\" Terraform has been successfully initialized! You may now begin working with Terraform. Try running \"terraform plan\" to see any changes that are required for your infrastructure. All Terraform commands should now work. If you ever set or change modules or backend configuration for Terraform, rerun this command to reinitialize your working directory. If you forget, other commands will detect it and remind you to do so if necessary. This should initialize the environment for our course. Reference If you want to learn more about providers, you can visit this link .","title":"Terraform Providers"},{"location":"03-providers/#providers","text":"In Terraform, Providers are responsible for understanding API interactions from * IaaS : e.g. AWS, Azure, GCP * PaaS : e.g. Heroku, Kubernetes * SaaS : e.g. CloudFlare, DNSSimple, DNSMadeEasy","title":"Providers"},{"location":"03-providers/#example-provider","text":"Let's look at AWS Provider as an example. provider \"aws\" { access_key = \"${var.aws_access_key}\" secret_key = \"${var.aws_secret_key}\" region = \"us-east-1\" } As seen in the above given example, Provider is a way to instruct Terraform to interact with AWS API. Every provider needs some kind of credentials to get authenticated with the API. In our example, we have porvided AWS access key and secret key to perform the same.","title":"Example Provider"},{"location":"03-providers/#setting-up-our-environment-for-aws","text":"Let us set up our environment by creating a directory called aws . mkdir aws cd aws After changing directory into aws , we need to create a file named main.tf . touch main.tf Define your Provider details in this main manifest. Change the region if you want to create the resources elsewhere. provider \"aws\" { region = \"us-east-1\" } Export your AWS access and secret keys as environment variables. export AWS_ACCESS_KEY_ID=\"Access-Key\" export AWS_SECRET_ACCESS_KEY=\"Secret-Key\" Finally run the following command to initialize your environment. terraform init [output] Initializing provider plugins... - Checking for available provider plugins on https://releases.hashicorp.com... - Downloading plugin for provider \"aws\" (1.37.0)... The following providers do not have any version constraints in configuration, so the latest version was installed. To prevent automatic upgrades to new major versions that may contain breaking changes, it is recommended to add version = \"...\" constraints to the corresponding provider blocks in configuration, with the constraint strings suggested below. * provider.aws: version = \"~> 1.37\" Terraform has been successfully initialized! You may now begin working with Terraform. Try running \"terraform plan\" to see any changes that are required for your infrastructure. All Terraform commands should now work. If you ever set or change modules or backend configuration for Terraform, rerun this command to reinitialize your working directory. If you forget, other commands will detect it and remind you to do so if necessary. This should initialize the environment for our course.","title":"Setting up our environment for AWS"},{"location":"03-providers/#reference","text":"If you want to learn more about providers, you can visit this link .","title":"Reference"},{"location":"04-resources/","text":"Resources Resources are the building block in Terraform. These the actual cloud entities that you are either creating/deleting or modifying. To do so, you will have to define them in a terraform manifest and apply them. Creating our first Resource Let us create an EC2 instance, which is going to be our first resource on AWS using Terraform. Every resorce has the following syntax. resource syntax resource \"resource_type\" \"resource_name\" { config1 = value1 config2 = value2 } Here, resource_type = The type of the resouce that we create/delete/modfiy resource_name = Give the resource a name for Terraform internal references. config(1-n) = The properties of the reosurce your manipulating. In your main.tf, add this block next to your Provider definition. an ec2 resource resource \"aws_instance\" \"frontend\" { ami = \"ami-0ac019f4fcb7cb7e6\" instance_type = \"t2.micro\" } Here, to compare it with the syntax, ``` resource_type = aws_instance resource_name = frontend config1 = ami value1 = ami-0ac019f4fcb7cb7e6(ubuntu-14.04) config2 = instance_type value2 = t2.micro Your `main.tf` file should look like the following. provider \"aws\" { region = \"us-east-1\" } resource \"aws_instance\" \"frontend\" { ami = \"ami-0ac019f4fcb7cb7e6\" instance_type = \"t2.micro\" } ### Terraform Plan Then run `terraform plan` to see what will happen if we apply the manifest. terraform plan [output] Refreshing Terraform state in-memory prior to plan... The refreshed state will be used to calculate this plan, but will not be persisted to local or remote state storage. An execution plan has been generated and is shown below. Resource actions are indicated with the following symbols: + create Terraform will perform the following actions: aws_instance.webserver id: ami: \"ami-0ac019f4fcb7cb7e6\" arn: associate_public_ip_address: availability_zone: cpu_core_count: cpu_threads_per_core: ebs_block_device.#: ephemeral_block_device.#: get_password_data: \"false\" instance_state: instance_type: \"t2.micro\" [...] Plan: 1 to add, 0 to change, 0 to destroy. Note: You didn't specify an \"-out\" parameter to save this plan, so Terraform can't guarantee that exactly these actions will be performed if \"terraform apply\" is subsequently run. ### Terraform Apply Then run, `terraform apply` to actually create the resource on AWS. terraform apply [output] [...] aws_instance.webserver: Still creating... (10s elapsed) aws_instance.webserver: Still creating... (20s elapsed) aws_instance.webserver: Still creating... (30s elapsed) aws_instance.webserver: Still creating... (40s elapsed) aws_instance.webserver: Creation complete after 49s (ID: i-02489cdf638f05bbd) Apply complete! Resources: 1 added, 0 changed, 0 destroyed. We have successfully created our first reosource on AWS. Please check your AWS console to check the properties(AMI and instance type) of the machine. ![terraform apply](./images/04-resources-apply.png) ## Resource Lifecycles In Terraform, a resource can be, * Created (+) * Destroyed (-) * Recreated (-/+) or * Updated (~) Like in the previous example, when Terraform creates a resource, it represents it with `+` symbol. Similarly Destroy, Recreate and Modify are represented with `-`, `-/+` and `~` respectively. ### Resource Update Let us see what happens when we apply a tag to the instance from `main.tf`. `file: main.tf` provider \"aws\" { region = \"us-east-1\" } resource \"aws_instance\" \"frontend\" { ami = \"ami-0ac019f4fcb7cb7e6\" instance_type = \"t2.micro\" tags { Name = \"tf-frontend-01\" App = \"devops-demo\" Maintainer = \"Gourav Shah\" Role =\"frontend\" } } We have added a tag block with in *aws_instance* resource which will add the name `instance-01` for our EC2 instance. terraform plan terraform apply [output] Acquiring state lock. This may take a few moments... aws_instance.webserver: Refreshing state... (ID: i-0f6ab73cdd9d6882c) An execution plan has been generated and is shown below. Resource actions are indicated with the following symbols: ~ update in-place Terraform will perform the following actions: ~ aws_instance.webserver tags.%: \"0\" => \"1\" tags.Name: \"\" => \"instance-01\" Plan: 0 to add, 1 to change, 0 to destroy. Do you want to perform these actions? Terraform will perform the actions described above. Only 'yes' will be accepted to approve. Enter a value: yes aws_instance.webserver: Modifying... (ID: i-0f6ab73cdd9d6882c) tags.%: \"0\" => \"1\" tags.Name: \"\" => \"instance-01\" aws_instance.webserver: Still modifying... (ID: i-0f6ab73cdd9d6882c, 10s elapsed) aws_instance.webserver: Modifications complete after 12s (ID: i-0f6ab73cdd9d6882c) Apply complete! Resources: 0 added, 1 changed, 0 destroyed. Releasing state lock. This may take a few moments... This did not recreate the instance, but just updated it. The instance still has the same internal and external IPs and other properties. ### Resource Recreation Now let us change the *ami* for the instance from *ami-408c7f28*(ubuntu 14.04) to *ami-0c11a0129f63fb571*(ubuntu 16.04). `file: main.tf` provider \"aws\" { region = \"us-east-1\" } resource \"aws_instance\" \"frontend\" { ami = \"ami-0c11a0129f63fb571\" instance_type = \"t2.micro\" tags { Name = \"tf-frontend-01\" App = \"devops-demo\" Maintainer = \"Gourav Shah\" Role =\"frontend\" } } Let us plan and apply this manifest. terraform apply [output] Acquiring state lock. This may take a few moments... aws_instance.webserver: Refreshing state... (ID: i-0f6ab73cdd9d6882c) An execution plan has been generated and is shown below. Resource actions are indicated with the following symbols: -/+ destroy and then create replacement Terraform will perform the following actions: -/+ aws_instance.webserver (new resource required) id: \"i-0f6ab73cdd9d6882c\" => (forces new resource) ami: \"ami-408c7f28\" => \"ami-0c11a0129f63fb571\" (forces new resource) arn: \"arn:aws:ec2:us-east-1:822941572458:instance/i-0f6ab73cdd9d6882c\" => associate_public_ip_address: \"false\" => availability_zone: \"us-east-1a\" => cpu_core_count: \"1\" => cpu_threads_per_core: \"1\" => ebs_block_device.#: \"0\" => ephemeral_block_device.#: \"0\" => get_password_data: \"false\" => \"false\" instance_state: \"stopped\" => instance_type: \"t2.micro\" => \"t2.micro\" ipv6_address_count: \"\" => ipv6_addresses.#: \"0\" => key_name: \"web-admin-key\" => network_interface.#: \"0\" => network_interface_id: \"eni-0c851ccf5348f539b\" => password_data: \"\" => placement_group: \"\" => primary_network_interface_id: \"eni-0c851ccf5348f539b\" => private_dns: \"ip-172-31-39-209.ec2.internal\" => private_ip: \"172.31.39.209\" => public_dns: \"\" => public_ip: \"\" => root_block_device.#: \"1\" => security_groups.#: \"1\" => source_dest_check: \"true\" => \"true\" subnet_id: \"subnet-d363e58f\" => tags.%: \"1\" => \"1\" tags.Name: \"instance-01\" => \"instance-01\" tenancy: \"default\" => volume_tags.%: \"0\" => vpc_security_group_ids.#: \"1\" => Plan: 1 to add, 0 to change, 1 to destroy. Do you want to perform these actions? Terraform will perform the actions described above. Only 'yes' will be accepted to approve. Enter a value: yes aws_instance.webserver: Destroying... (ID: i-0f6ab73cdd9d6882c) aws_instance.webserver: Still destroying... (ID: i-0f6ab73cdd9d6882c, 10s elapsed) aws_instance.webserver: Destruction complete after 13s aws_instance.webserver: Creating... aws_instance.webserver: Still creating... (10s elapsed) aws_instance.webserver: Still creating... (20s elapsed) aws_instance.webserver: Still creating... (30s elapsed) aws_instance.webserver: Creation complete after 40s (ID: i-04aa34e873c5e4c63) If we change `ami` attribute, it forces the instance to be recreated. ### Resource Destruction Let us see what happens when we run `terraform plan --destroy` terraform plan --destroy [output] Acquiring state lock. This may take a few moments... Refreshing Terraform state in-memory prior to plan... The refreshed state will be used to calculate this plan, but will not be persisted to local or remote state storage. aws_instance.webserver: Refreshing state... (ID: i-04aa34e873c5e4c63) An execution plan has been generated and is shown below. Resource actions are indicated with the following symbols: - destroy Terraform will perform the following actions: aws_instance.webserver Plan: 0 to add, 0 to change, 1 to destroy. Note: You didn't specify an \"-out\" parameter to save this plan, so Terraform can't guarantee that exactly these actions will be performed if \"terraform apply\" is subsequently run. Releasing state lock. This may take a few moments... This command will help you to see what will happen when you run `terraform destroy`. terraform destroy [output] Acquiring state lock. This may take a few moments... aws_instance.webserver: Refreshing state... (ID: i-04aa34e873c5e4c63) An execution plan has been generated and is shown below. Resource actions are indicated with the following symbols: - destroy Terraform will perform the following actions: aws_instance.webserver Plan: 0 to add, 0 to change, 1 to destroy. Do you really want to destroy? Terraform will destroy all your managed infrastructure, as shown above. There is no undo. Only 'yes' will be accepted to confirm. Enter a value: yes aws_instance.webserver: Destroying... (ID: i-04aa34e873c5e4c63) aws_instance.webserver: Still destroying... (ID: i-04aa34e873c5e4c63, 10s elapsed) aws_instance.webserver: Still destroying... (ID: i-04aa34e873c5e4c63, 20s elapsed) aws_instance.webserver: Still destroying... (ID: i-04aa34e873c5e4c63, 30s elapsed) aws_instance.webserver: Still destroying... (ID: i-04aa34e873c5e4c63, 40s elapsed) aws_instance.webserver: Still destroying... (ID: i-04aa34e873c5e4c63, 50s elapsed) aws_instance.webserver: Still destroying... (ID: i-04aa34e873c5e4c63, 1m0s elapsed) aws_instance.webserver: Destruction complete after 1m0s Destroy complete! Resources: 1 destroyed. Releasing state lock. This may take a few moments... ``` Reference If you need further details about resources, please visit this link","title":"Resources"},{"location":"04-resources/#resources","text":"Resources are the building block in Terraform. These the actual cloud entities that you are either creating/deleting or modifying. To do so, you will have to define them in a terraform manifest and apply them.","title":"Resources"},{"location":"04-resources/#creating-our-first-resource","text":"Let us create an EC2 instance, which is going to be our first resource on AWS using Terraform. Every resorce has the following syntax. resource syntax resource \"resource_type\" \"resource_name\" { config1 = value1 config2 = value2 } Here, resource_type = The type of the resouce that we create/delete/modfiy resource_name = Give the resource a name for Terraform internal references. config(1-n) = The properties of the reosurce your manipulating. In your main.tf, add this block next to your Provider definition. an ec2 resource resource \"aws_instance\" \"frontend\" { ami = \"ami-0ac019f4fcb7cb7e6\" instance_type = \"t2.micro\" } Here, to compare it with the syntax, ``` resource_type = aws_instance resource_name = frontend config1 = ami value1 = ami-0ac019f4fcb7cb7e6(ubuntu-14.04) config2 = instance_type value2 = t2.micro Your `main.tf` file should look like the following. provider \"aws\" { region = \"us-east-1\" } resource \"aws_instance\" \"frontend\" { ami = \"ami-0ac019f4fcb7cb7e6\" instance_type = \"t2.micro\" } ### Terraform Plan Then run `terraform plan` to see what will happen if we apply the manifest. terraform plan [output] Refreshing Terraform state in-memory prior to plan... The refreshed state will be used to calculate this plan, but will not be persisted to local or remote state storage. An execution plan has been generated and is shown below. Resource actions are indicated with the following symbols: + create Terraform will perform the following actions: aws_instance.webserver id: ami: \"ami-0ac019f4fcb7cb7e6\" arn: associate_public_ip_address: availability_zone: cpu_core_count: cpu_threads_per_core: ebs_block_device.#: ephemeral_block_device.#: get_password_data: \"false\" instance_state: instance_type: \"t2.micro\" [...] Plan: 1 to add, 0 to change, 0 to destroy. Note: You didn't specify an \"-out\" parameter to save this plan, so Terraform can't guarantee that exactly these actions will be performed if \"terraform apply\" is subsequently run. ### Terraform Apply Then run, `terraform apply` to actually create the resource on AWS. terraform apply [output] [...] aws_instance.webserver: Still creating... (10s elapsed) aws_instance.webserver: Still creating... (20s elapsed) aws_instance.webserver: Still creating... (30s elapsed) aws_instance.webserver: Still creating... (40s elapsed) aws_instance.webserver: Creation complete after 49s (ID: i-02489cdf638f05bbd) Apply complete! Resources: 1 added, 0 changed, 0 destroyed. We have successfully created our first reosource on AWS. Please check your AWS console to check the properties(AMI and instance type) of the machine. ![terraform apply](./images/04-resources-apply.png) ## Resource Lifecycles In Terraform, a resource can be, * Created (+) * Destroyed (-) * Recreated (-/+) or * Updated (~) Like in the previous example, when Terraform creates a resource, it represents it with `+` symbol. Similarly Destroy, Recreate and Modify are represented with `-`, `-/+` and `~` respectively. ### Resource Update Let us see what happens when we apply a tag to the instance from `main.tf`. `file: main.tf` provider \"aws\" { region = \"us-east-1\" } resource \"aws_instance\" \"frontend\" { ami = \"ami-0ac019f4fcb7cb7e6\" instance_type = \"t2.micro\" tags { Name = \"tf-frontend-01\" App = \"devops-demo\" Maintainer = \"Gourav Shah\" Role =\"frontend\" } } We have added a tag block with in *aws_instance* resource which will add the name `instance-01` for our EC2 instance. terraform plan terraform apply [output] Acquiring state lock. This may take a few moments... aws_instance.webserver: Refreshing state... (ID: i-0f6ab73cdd9d6882c) An execution plan has been generated and is shown below. Resource actions are indicated with the following symbols: ~ update in-place Terraform will perform the following actions: ~ aws_instance.webserver tags.%: \"0\" => \"1\" tags.Name: \"\" => \"instance-01\" Plan: 0 to add, 1 to change, 0 to destroy. Do you want to perform these actions? Terraform will perform the actions described above. Only 'yes' will be accepted to approve. Enter a value: yes aws_instance.webserver: Modifying... (ID: i-0f6ab73cdd9d6882c) tags.%: \"0\" => \"1\" tags.Name: \"\" => \"instance-01\" aws_instance.webserver: Still modifying... (ID: i-0f6ab73cdd9d6882c, 10s elapsed) aws_instance.webserver: Modifications complete after 12s (ID: i-0f6ab73cdd9d6882c) Apply complete! Resources: 0 added, 1 changed, 0 destroyed. Releasing state lock. This may take a few moments... This did not recreate the instance, but just updated it. The instance still has the same internal and external IPs and other properties. ### Resource Recreation Now let us change the *ami* for the instance from *ami-408c7f28*(ubuntu 14.04) to *ami-0c11a0129f63fb571*(ubuntu 16.04). `file: main.tf` provider \"aws\" { region = \"us-east-1\" } resource \"aws_instance\" \"frontend\" { ami = \"ami-0c11a0129f63fb571\" instance_type = \"t2.micro\" tags { Name = \"tf-frontend-01\" App = \"devops-demo\" Maintainer = \"Gourav Shah\" Role =\"frontend\" } } Let us plan and apply this manifest. terraform apply [output] Acquiring state lock. This may take a few moments... aws_instance.webserver: Refreshing state... (ID: i-0f6ab73cdd9d6882c) An execution plan has been generated and is shown below. Resource actions are indicated with the following symbols: -/+ destroy and then create replacement Terraform will perform the following actions: -/+ aws_instance.webserver (new resource required) id: \"i-0f6ab73cdd9d6882c\" => (forces new resource) ami: \"ami-408c7f28\" => \"ami-0c11a0129f63fb571\" (forces new resource) arn: \"arn:aws:ec2:us-east-1:822941572458:instance/i-0f6ab73cdd9d6882c\" => associate_public_ip_address: \"false\" => availability_zone: \"us-east-1a\" => cpu_core_count: \"1\" => cpu_threads_per_core: \"1\" => ebs_block_device.#: \"0\" => ephemeral_block_device.#: \"0\" => get_password_data: \"false\" => \"false\" instance_state: \"stopped\" => instance_type: \"t2.micro\" => \"t2.micro\" ipv6_address_count: \"\" => ipv6_addresses.#: \"0\" => key_name: \"web-admin-key\" => network_interface.#: \"0\" => network_interface_id: \"eni-0c851ccf5348f539b\" => password_data: \"\" => placement_group: \"\" => primary_network_interface_id: \"eni-0c851ccf5348f539b\" => private_dns: \"ip-172-31-39-209.ec2.internal\" => private_ip: \"172.31.39.209\" => public_dns: \"\" => public_ip: \"\" => root_block_device.#: \"1\" => security_groups.#: \"1\" => source_dest_check: \"true\" => \"true\" subnet_id: \"subnet-d363e58f\" => tags.%: \"1\" => \"1\" tags.Name: \"instance-01\" => \"instance-01\" tenancy: \"default\" => volume_tags.%: \"0\" => vpc_security_group_ids.#: \"1\" => Plan: 1 to add, 0 to change, 1 to destroy. Do you want to perform these actions? Terraform will perform the actions described above. Only 'yes' will be accepted to approve. Enter a value: yes aws_instance.webserver: Destroying... (ID: i-0f6ab73cdd9d6882c) aws_instance.webserver: Still destroying... (ID: i-0f6ab73cdd9d6882c, 10s elapsed) aws_instance.webserver: Destruction complete after 13s aws_instance.webserver: Creating... aws_instance.webserver: Still creating... (10s elapsed) aws_instance.webserver: Still creating... (20s elapsed) aws_instance.webserver: Still creating... (30s elapsed) aws_instance.webserver: Creation complete after 40s (ID: i-04aa34e873c5e4c63) If we change `ami` attribute, it forces the instance to be recreated. ### Resource Destruction Let us see what happens when we run `terraform plan --destroy` terraform plan --destroy [output] Acquiring state lock. This may take a few moments... Refreshing Terraform state in-memory prior to plan... The refreshed state will be used to calculate this plan, but will not be persisted to local or remote state storage. aws_instance.webserver: Refreshing state... (ID: i-04aa34e873c5e4c63) An execution plan has been generated and is shown below. Resource actions are indicated with the following symbols: - destroy Terraform will perform the following actions: aws_instance.webserver Plan: 0 to add, 0 to change, 1 to destroy. Note: You didn't specify an \"-out\" parameter to save this plan, so Terraform can't guarantee that exactly these actions will be performed if \"terraform apply\" is subsequently run. Releasing state lock. This may take a few moments... This command will help you to see what will happen when you run `terraform destroy`. terraform destroy [output] Acquiring state lock. This may take a few moments... aws_instance.webserver: Refreshing state... (ID: i-04aa34e873c5e4c63) An execution plan has been generated and is shown below. Resource actions are indicated with the following symbols: - destroy Terraform will perform the following actions: aws_instance.webserver Plan: 0 to add, 0 to change, 1 to destroy. Do you really want to destroy? Terraform will destroy all your managed infrastructure, as shown above. There is no undo. Only 'yes' will be accepted to confirm. Enter a value: yes aws_instance.webserver: Destroying... (ID: i-04aa34e873c5e4c63) aws_instance.webserver: Still destroying... (ID: i-04aa34e873c5e4c63, 10s elapsed) aws_instance.webserver: Still destroying... (ID: i-04aa34e873c5e4c63, 20s elapsed) aws_instance.webserver: Still destroying... (ID: i-04aa34e873c5e4c63, 30s elapsed) aws_instance.webserver: Still destroying... (ID: i-04aa34e873c5e4c63, 40s elapsed) aws_instance.webserver: Still destroying... (ID: i-04aa34e873c5e4c63, 50s elapsed) aws_instance.webserver: Still destroying... (ID: i-04aa34e873c5e4c63, 1m0s elapsed) aws_instance.webserver: Destruction complete after 1m0s Destroy complete! Resources: 1 destroyed. Releasing state lock. This may take a few moments... ```","title":"Creating our first Resource"},{"location":"04-resources/#reference","text":"If you need further details about resources, please visit this link","title":"Reference"},{"location":"05-resource-dependencies/","text":"Resource Dependency The ec2 instance that we have created is not that useful when we don't have access to it. So let us delete it and we shall set up this again with additional resources. Let us create a security group, which allows us to ssh(port 22) into the machine. file: main.tf provider \"aws\" { region = \"us-east-1\" } resource \"aws_instance\" \"frontend\" { ami = \"ami-0ac019f4fcb7cb7e6\" instance_type = \"t2.micro\" } resource \"aws_security_group\" \"frontend\" { name = \"frontend\" ingress { cidr_blocks = [\"0.0.0.0/0\"] from_port = 22 to_port = 22 protocol = \"tcp\" description = \"open ssh port for all\" } } } Here, Resource type = aws_security_group, Resource name = frontend This aws_security_group resource allows us to ssh into the instance. We need to create the EC2 instance with this security group. To do that, The final requirement is a key pair using which we can login to the machine. Let us use aws_key_pair to register the key with AWS and then use in our ec2 instance. To do this, you will need to create a key pair in your local machine. Run the following commands. This will create one public key and a private key. root@vibe$ ssh-keygen -t rsa [output] Generating public/private rsa key pair. Enter file in which to save the key (/home/vibe/.ssh/id_rsa): Enter passphrase (empty for no passphrase): Enter same passphrase again: Your identification has been saved in /home/vibe/.ssh/id_rsa. Your public key has been saved in /home/vibe/.ssh/id_rsa.pub. The key fingerprint is: SHA256:nSnSLKDvnLv22LFX+wKYMa0TvSt3AL406z+Asj/GSak vibe@vibes-MacBook-Air.local The key's randomart image is: +---[RSA 2048]----+ | | | | | . o | | . .=oo. o | | . +oOS.+ | | ..+ Xo+.. | | *.o.* = . | | Eo*++o= + | | +O*==.o o. | +----[SHA256]-----+ Copy the content of your public key cat ~/.ssh/id_rsa.pub [output] ssh-rsa AAAAB3NzaC1yc2EAAAADAQABAAABAQC4Q2TBuAD7ijkPjp+/Hl/QnrNo4hoZEz/l+UBsfvlDuJk8zfh0ivnQLtoYyXNuJ3/BjTVVIchrGo8CLZdTco//n+YBvMqgW4Wg5F92JNNkR5L5x04ELRUmC3ed1ZqbwrLmujzB33nMJ8Ld5dJjtS55KJa5MwkCaP7lqGicU2NgXe+if2DhCKW/lZyCpkkvRgmB7oEqj6aBWNjp+FMY4v6BtcmmB/+1Ry+GMvmZJO1EjSeUHAWCec3snX7TxJKHf4opwTHxknmhRKkz8+pS8rxyjiBeyncxP9jL9Tx/Zh6qmExCUfuhAWk87sjbb3j0enVs2LtzJOG9eBZ726wD83TJ vibe@vibes-MacBook-Air.local Paste the content of public key in the public_key file: main.tf [...] resource \"aws_security_group\" \"frontend\" { name = \"frontend\" ingress { cidr_blocks = [\"0.0.0.0/0\"] from_port = 22 to_port = 22 protocol = \"tcp\" description = \"open ssh port for all\" } } } resource \"aws_key_pair\" \"terraform\" { key_name = \"terraform\" public_key = \"ssh-rsa AAAAB3NzaC1yc2EAAAADAQABAAABAQC4Q2TBuAD7ijkPjp+/Hl/QnrNo4hoZEz/l+UBsfvlDuJk8zfh0ivnQLtoYyXNuJ3/BjTVVIchrGo8CLZdTco//n+YBvMqgW4Wg5F92JNNkR5L5x04ELRUmC3ed1ZqbwrLmujzB33nMJ8Ld5dJjtS55KJa5MwkCaP7lqGicU2NgXe+if2DhCKW/lZyCpkkvRgmB7oEqj6aBWNjp+FMY4v6BtcmmB/+1Ry+GMvmZJO1EjSeUHAWCec3snX7TxJKHf4opwTHxknmhRKkz8+pS8rxyjiBeyncxP9jL9Tx/Zh6qmExCUfuhAWk87sjbb3j0enVs2LtzJOG9eBZ726wD83TJ vibe@vibes-MacBook-Air.local } We need to make sure our instance uses this key. To do that, we should add one more attribute to our aws_instance module. We will also tag the instace with a name. file: main.tf provider \"aws\" { region = \"us-east-1\" } resource \"aws_instance\" \"frontend\" { ami = \"ami-0ac019f4fcb7cb7e6\" instance_type = \"t2.micro\" key_name = \"terraform\" tags { Name = \"tf-frontend-01\" App = \"devops-demo\" Maintainer = \"Gourav Shah\" Role =\"frontend\" } } [...] The final file should look like the following. provider \"aws\" { region = \"us-east-1\" } resource \"aws_instance\" \"frontend\" { ami = \"ami-0ac019f4fcb7cb7e6\" instance_type = \"t2.micro\" key_name = \"terraform\" tags { Name = \"tf-frontend-01\" App = \"devops-demo\" Maintainer = \"Gourav Shah\" Role = \"frontend\" } } resource \"aws_security_group\" \"frontend\" { name = \"frontend\" ingress { cidr_blocks = [\"0.0.0.0/0\"] from_port = 22 to_port = 22 protocol = \"tcp\" description = \"open ssh port for all\" } } resource \"aws_key_pair\" \"terraform\" { key_name = \"terraform\" public_key = \"ssh-rsa AAAAB3NzaC1yc2EAAAADAQABAAABAQC4Q2TBuAD7ijkPjp+/Hl/QnrNo4hoZEz/l+UBsfvlDuJk8zfh0ivnQLtoYyXNuJ3/BjTVVIchrGo8CLZdTco//n+YBvMqgW4Wg5F92JNNkR5L5x04ELRUmC3ed1ZqbwrLmujzB33nMJ8Ld5dJjtS55KJa5MwkCaP7lqGicU2NgXe+if2DhCKW/lZyCpkkvRgmB7oEqj6aBWNjp+FMY4v6BtcmmB/+1Ry+GMvmZJO1EjSeUHAWCec3snX7TxJKHf4opwTHxknmhRKkz8+pS8rxyjiBeyncxP9jL9Tx/Zh6qmExCUfuhAWk87sjbb3j0enVs2LtzJOG9eBZ726wD83TJ vibe@vibes-MacBook-Air.local\" } Explicit Dependency We can control the order of execution in two ways. * Implicit Dependecy (Automatic Dependency) * Explicit Dependency (Manual Dependency) We will learn more about Implicit Dependency in the next chapter. Now we will focus on adding Explicit Dependency to aws_instance resource to depend on aws_key_pair resource. This will guarantee the creation of key pair before the instance get's created. In your instance block add the following, file: main.tf [...] resource \"aws_instance\" \"frontend\" { ami = \"ami-0ac019f4fcb7cb7e6\" instance_type = \"t2.micro\" key_name = \"terraform\" depends_on = [\"aws_key_pair.webserver_key\"] tags { Name = \"terraform\" } } [...] Syntax: depends_on = [\"resource_type.resource_name\"] Exercise: Create an explicit dependency on security group in ec2 instance block just like key pair dependecy Idempotency Finally apply the manifest by running terraform apply [output] Plan: 2 to add, 0 to change, 0 to destroy. Do you want to perform these actions? Terraform will perform the actions described above. Only 'yes' will be accepted to approve. Enter a value: yes aws_key_pair.webserver_key: Creating... fingerprint: \"\" => \"<computed>\" key_name: \"\" => \"terraform\" public_key: \"\" => \"ssh-rsa AAAAB3NzaC1yc2EAAAADAQABAAABAQC4Q2TBuAD7ijkPjp+/Hl/QnrNo4hoZEz/l+UBsfvlDuJk8zfh0ivnQLtoYyXNuJ3/BjTVVIchrGo8CLZdTco//n+YBvMqgW4Wg5F92JNNkR5L5x04ELRUmC3ed1ZqbwrLmujzB33nMJ8Ld5dJjtS55KJa5MwkCaP7lqGicU2NgXe+if2DhCKW/lZyCpkkvRgmB7oEqj6aBWNjp+FMY4v6BtcmmB/+1Ry+GMvmZJO1EjSeUHAWCec3snX7TxJKHf4opwTHxknmhRKkz8+pS8rxyjiBeyncxP9jL9Tx/Zh6qmExCUfuhAWk87sjbb3j0enVs2LtzJOG9eBZ726wD83TJ vibe@vibes-MacBook-Air.local\" aws_key_pair.webserver_key: Creation complete after 3s (ID: web-admin-key) aws_instance.webserver: Creating... ami: \"\" => \"ami-0ac019f4fcb7cb7e6\" arn: \"\" => \"<computed>\" associate_public_ip_address: \"\" => \"<computed>\" availability_zone: \"\" => \"<computed>\" cpu_core_count: \"\" => \"<computed>\" cpu_threads_per_core: \"\" => \"<computed>\" ebs_block_device.#: \"\" => \"<computed>\" ephemeral_block_device.#: \"\" => \"<computed>\" get_password_data: \"\" => \"false\" instance_state: \"\" => \"<computed>\" instance_type: \"\" => \"t2.micro\" ipv6_address_count: \"\" => \"<computed>\" ipv6_addresses.#: \"\" => \"<computed>\" key_name: \"\" => \"terraform\" network_interface.#: \"\" => \"<computed>\" network_interface_id: \"\" => \"<computed>\" password_data: \"\" => \"<computed>\" placement_group: \"\" => \"<computed>\" primary_network_interface_id: \"\" => \"<computed>\" private_dns: \"\" => \"<computed>\" private_ip: \"\" => \"<computed>\" public_dns: \"\" => \"<computed>\" public_ip: \"\" => \"<computed>\" root_block_device.#: \"\" => \"<computed>\" security_groups.#: \"\" => \"<computed>\" source_dest_check: \"\" => \"true\" subnet_id: \"\" => \"<computed>\" tags.%: \"\" => \"1\" tags.Name: \"\" => \"frontend\" tenancy: \"\" => \"<computed>\" volume_tags.%: \"\" => \"<computed>\" vpc_security_group_ids.#: \"\" => \"<computed>\" aws_instance.webserver: Still creating... (10s elapsed) aws_instance.webserver: Still creating... (20s elapsed) aws_instance.webserver: Still creating... (30s elapsed) aws_instance.webserver: Creation complete after 37s (ID: i-0a7d259b3126e16b8) Apply complete! Resources: 2 added, 0 changed, 0 destroyed. If you have noticed, Terraform did not create the security group this time around. The reason for this behaviour is, it had created the security group resource in the first run itself. So it did not create the same resource again when we applied the second time. This behaviour is called Idempotency . Reference If you want to know more about, resource dependencies then please refer this link .","title":"Resource Dependencies"},{"location":"05-resource-dependencies/#resource-dependency","text":"The ec2 instance that we have created is not that useful when we don't have access to it. So let us delete it and we shall set up this again with additional resources. Let us create a security group, which allows us to ssh(port 22) into the machine. file: main.tf provider \"aws\" { region = \"us-east-1\" } resource \"aws_instance\" \"frontend\" { ami = \"ami-0ac019f4fcb7cb7e6\" instance_type = \"t2.micro\" } resource \"aws_security_group\" \"frontend\" { name = \"frontend\" ingress { cidr_blocks = [\"0.0.0.0/0\"] from_port = 22 to_port = 22 protocol = \"tcp\" description = \"open ssh port for all\" } } } Here, Resource type = aws_security_group, Resource name = frontend This aws_security_group resource allows us to ssh into the instance. We need to create the EC2 instance with this security group. To do that, The final requirement is a key pair using which we can login to the machine. Let us use aws_key_pair to register the key with AWS and then use in our ec2 instance. To do this, you will need to create a key pair in your local machine. Run the following commands. This will create one public key and a private key. root@vibe$ ssh-keygen -t rsa [output] Generating public/private rsa key pair. Enter file in which to save the key (/home/vibe/.ssh/id_rsa): Enter passphrase (empty for no passphrase): Enter same passphrase again: Your identification has been saved in /home/vibe/.ssh/id_rsa. Your public key has been saved in /home/vibe/.ssh/id_rsa.pub. The key fingerprint is: SHA256:nSnSLKDvnLv22LFX+wKYMa0TvSt3AL406z+Asj/GSak vibe@vibes-MacBook-Air.local The key's randomart image is: +---[RSA 2048]----+ | | | | | . o | | . .=oo. o | | . +oOS.+ | | ..+ Xo+.. | | *.o.* = . | | Eo*++o= + | | +O*==.o o. | +----[SHA256]-----+ Copy the content of your public key cat ~/.ssh/id_rsa.pub [output] ssh-rsa AAAAB3NzaC1yc2EAAAADAQABAAABAQC4Q2TBuAD7ijkPjp+/Hl/QnrNo4hoZEz/l+UBsfvlDuJk8zfh0ivnQLtoYyXNuJ3/BjTVVIchrGo8CLZdTco//n+YBvMqgW4Wg5F92JNNkR5L5x04ELRUmC3ed1ZqbwrLmujzB33nMJ8Ld5dJjtS55KJa5MwkCaP7lqGicU2NgXe+if2DhCKW/lZyCpkkvRgmB7oEqj6aBWNjp+FMY4v6BtcmmB/+1Ry+GMvmZJO1EjSeUHAWCec3snX7TxJKHf4opwTHxknmhRKkz8+pS8rxyjiBeyncxP9jL9Tx/Zh6qmExCUfuhAWk87sjbb3j0enVs2LtzJOG9eBZ726wD83TJ vibe@vibes-MacBook-Air.local Paste the content of public key in the public_key file: main.tf [...] resource \"aws_security_group\" \"frontend\" { name = \"frontend\" ingress { cidr_blocks = [\"0.0.0.0/0\"] from_port = 22 to_port = 22 protocol = \"tcp\" description = \"open ssh port for all\" } } } resource \"aws_key_pair\" \"terraform\" { key_name = \"terraform\" public_key = \"ssh-rsa AAAAB3NzaC1yc2EAAAADAQABAAABAQC4Q2TBuAD7ijkPjp+/Hl/QnrNo4hoZEz/l+UBsfvlDuJk8zfh0ivnQLtoYyXNuJ3/BjTVVIchrGo8CLZdTco//n+YBvMqgW4Wg5F92JNNkR5L5x04ELRUmC3ed1ZqbwrLmujzB33nMJ8Ld5dJjtS55KJa5MwkCaP7lqGicU2NgXe+if2DhCKW/lZyCpkkvRgmB7oEqj6aBWNjp+FMY4v6BtcmmB/+1Ry+GMvmZJO1EjSeUHAWCec3snX7TxJKHf4opwTHxknmhRKkz8+pS8rxyjiBeyncxP9jL9Tx/Zh6qmExCUfuhAWk87sjbb3j0enVs2LtzJOG9eBZ726wD83TJ vibe@vibes-MacBook-Air.local } We need to make sure our instance uses this key. To do that, we should add one more attribute to our aws_instance module. We will also tag the instace with a name. file: main.tf provider \"aws\" { region = \"us-east-1\" } resource \"aws_instance\" \"frontend\" { ami = \"ami-0ac019f4fcb7cb7e6\" instance_type = \"t2.micro\" key_name = \"terraform\" tags { Name = \"tf-frontend-01\" App = \"devops-demo\" Maintainer = \"Gourav Shah\" Role =\"frontend\" } } [...] The final file should look like the following. provider \"aws\" { region = \"us-east-1\" } resource \"aws_instance\" \"frontend\" { ami = \"ami-0ac019f4fcb7cb7e6\" instance_type = \"t2.micro\" key_name = \"terraform\" tags { Name = \"tf-frontend-01\" App = \"devops-demo\" Maintainer = \"Gourav Shah\" Role = \"frontend\" } } resource \"aws_security_group\" \"frontend\" { name = \"frontend\" ingress { cidr_blocks = [\"0.0.0.0/0\"] from_port = 22 to_port = 22 protocol = \"tcp\" description = \"open ssh port for all\" } } resource \"aws_key_pair\" \"terraform\" { key_name = \"terraform\" public_key = \"ssh-rsa AAAAB3NzaC1yc2EAAAADAQABAAABAQC4Q2TBuAD7ijkPjp+/Hl/QnrNo4hoZEz/l+UBsfvlDuJk8zfh0ivnQLtoYyXNuJ3/BjTVVIchrGo8CLZdTco//n+YBvMqgW4Wg5F92JNNkR5L5x04ELRUmC3ed1ZqbwrLmujzB33nMJ8Ld5dJjtS55KJa5MwkCaP7lqGicU2NgXe+if2DhCKW/lZyCpkkvRgmB7oEqj6aBWNjp+FMY4v6BtcmmB/+1Ry+GMvmZJO1EjSeUHAWCec3snX7TxJKHf4opwTHxknmhRKkz8+pS8rxyjiBeyncxP9jL9Tx/Zh6qmExCUfuhAWk87sjbb3j0enVs2LtzJOG9eBZ726wD83TJ vibe@vibes-MacBook-Air.local\" }","title":"Resource Dependency"},{"location":"05-resource-dependencies/#explicit-dependency","text":"We can control the order of execution in two ways. * Implicit Dependecy (Automatic Dependency) * Explicit Dependency (Manual Dependency) We will learn more about Implicit Dependency in the next chapter. Now we will focus on adding Explicit Dependency to aws_instance resource to depend on aws_key_pair resource. This will guarantee the creation of key pair before the instance get's created. In your instance block add the following, file: main.tf [...] resource \"aws_instance\" \"frontend\" { ami = \"ami-0ac019f4fcb7cb7e6\" instance_type = \"t2.micro\" key_name = \"terraform\" depends_on = [\"aws_key_pair.webserver_key\"] tags { Name = \"terraform\" } } [...] Syntax: depends_on = [\"resource_type.resource_name\"] Exercise: Create an explicit dependency on security group in ec2 instance block just like key pair dependecy","title":"Explicit Dependency"},{"location":"05-resource-dependencies/#idempotency","text":"Finally apply the manifest by running terraform apply [output] Plan: 2 to add, 0 to change, 0 to destroy. Do you want to perform these actions? Terraform will perform the actions described above. Only 'yes' will be accepted to approve. Enter a value: yes aws_key_pair.webserver_key: Creating... fingerprint: \"\" => \"<computed>\" key_name: \"\" => \"terraform\" public_key: \"\" => \"ssh-rsa AAAAB3NzaC1yc2EAAAADAQABAAABAQC4Q2TBuAD7ijkPjp+/Hl/QnrNo4hoZEz/l+UBsfvlDuJk8zfh0ivnQLtoYyXNuJ3/BjTVVIchrGo8CLZdTco//n+YBvMqgW4Wg5F92JNNkR5L5x04ELRUmC3ed1ZqbwrLmujzB33nMJ8Ld5dJjtS55KJa5MwkCaP7lqGicU2NgXe+if2DhCKW/lZyCpkkvRgmB7oEqj6aBWNjp+FMY4v6BtcmmB/+1Ry+GMvmZJO1EjSeUHAWCec3snX7TxJKHf4opwTHxknmhRKkz8+pS8rxyjiBeyncxP9jL9Tx/Zh6qmExCUfuhAWk87sjbb3j0enVs2LtzJOG9eBZ726wD83TJ vibe@vibes-MacBook-Air.local\" aws_key_pair.webserver_key: Creation complete after 3s (ID: web-admin-key) aws_instance.webserver: Creating... ami: \"\" => \"ami-0ac019f4fcb7cb7e6\" arn: \"\" => \"<computed>\" associate_public_ip_address: \"\" => \"<computed>\" availability_zone: \"\" => \"<computed>\" cpu_core_count: \"\" => \"<computed>\" cpu_threads_per_core: \"\" => \"<computed>\" ebs_block_device.#: \"\" => \"<computed>\" ephemeral_block_device.#: \"\" => \"<computed>\" get_password_data: \"\" => \"false\" instance_state: \"\" => \"<computed>\" instance_type: \"\" => \"t2.micro\" ipv6_address_count: \"\" => \"<computed>\" ipv6_addresses.#: \"\" => \"<computed>\" key_name: \"\" => \"terraform\" network_interface.#: \"\" => \"<computed>\" network_interface_id: \"\" => \"<computed>\" password_data: \"\" => \"<computed>\" placement_group: \"\" => \"<computed>\" primary_network_interface_id: \"\" => \"<computed>\" private_dns: \"\" => \"<computed>\" private_ip: \"\" => \"<computed>\" public_dns: \"\" => \"<computed>\" public_ip: \"\" => \"<computed>\" root_block_device.#: \"\" => \"<computed>\" security_groups.#: \"\" => \"<computed>\" source_dest_check: \"\" => \"true\" subnet_id: \"\" => \"<computed>\" tags.%: \"\" => \"1\" tags.Name: \"\" => \"frontend\" tenancy: \"\" => \"<computed>\" volume_tags.%: \"\" => \"<computed>\" vpc_security_group_ids.#: \"\" => \"<computed>\" aws_instance.webserver: Still creating... (10s elapsed) aws_instance.webserver: Still creating... (20s elapsed) aws_instance.webserver: Still creating... (30s elapsed) aws_instance.webserver: Creation complete after 37s (ID: i-0a7d259b3126e16b8) Apply complete! Resources: 2 added, 0 changed, 0 destroyed. If you have noticed, Terraform did not create the security group this time around. The reason for this behaviour is, it had created the security group resource in the first run itself. So it did not create the same resource again when we applied the second time. This behaviour is called Idempotency .","title":"Idempotency"},{"location":"05-resource-dependencies/#reference","text":"If you want to know more about, resource dependencies then please refer this link .","title":"Reference"},{"location":"06-variables-and-outputs/","text":"Variables Let us try to ssh into the machine that we've just created. Get the public IP from the AWS console. ssh ubuntu@34.203.194.201 [output] ssh: connect to host 34.203.194.201 port 22: Operation timed out You will not be able to SSH. The reason is we have not associated the security group that we have created with this instance. The instance is still using the default security group which doesn't allow ssh. We need to fix this issue. Let us associate our security group with this machine. file: main.tf Bad Practice resource \"aws_instance\" \"frontend\" { ami = \"ami-0ac019f4fcb7cb7e6\" instance_type = \"t2.micro\" key_name = \"terraform\" vpc_security_group_ids = \"sg-0c22a3497351d1caa\" depends_on = [\"aws_key_pair.terraform\"] tags { Name = \"tf-frontend-01\" App = \"devops-demo\" Maintainer = \"Gourav Shah\" Role =\"frontend\" } } We can manually copy the ID of the security group and apply the manifest. This would work but this is an ugly fix. We should let Terraform to find the these kind of mutable data. Thats where Variables come into picture. Type 1: Attribute of a Resource file: main.tf Good Practice resource \"aws_instance\" \"frontend\" { ami = \"ami-0ac019f4fcb7cb7e6\" instance_type = \"t2.micro\" key_name = \"terraform\" vpc_security_group_ids = [\"${aws_security_group.front-end.id}\"] depends_on = [\"aws_key_pair.terraform\"] tags { Name = \"tf-frontend-01\" App = \"devops-demo\" Maintainer = \"Gourav Shah\" Role =\"frontend\" } } This is how variable interpolation works in Terraform. Syntax: ${TYPE.NAME.ATTRIBUTE} In our case, it is, ${aws_security_group.fornt-end.id} . Here, aws_security_group => TYPE webserver_sg => NAME id => ATTRIBUTE Every resource has set of attribute that can be referred as a variable. aws_security_group resource has the following attributes which can be referred. * id - The ID of the security group * arn - The ARN of the security group * vpc_id - The VPC ID. * owner_id - The owner ID. * name - The name of the security group * description - The description of the security group * ingress - The ingress rules. See above for more. * egress - The egress rules. See above for more. This also creates an Implicit Dependency . Terraform will know that this security group has to be created before the EC2 instance since the later refers to it. Let us apply the given manifest. Let us apply the manifest. terraform apply [output] An execution plan has been generated and is shown below. Resource actions are indicated with the following symbols: ~ update in-place Terraform will perform the following actions: ~ aws_instance.webserver vpc_security_group_ids.118229083: \"\" => \"sg-0c22a3497351d1caa\" vpc_security_group_ids.3314100969: \"sg-a42b7ae9\" => \"\" Plan: 0 to add, 1 to change, 0 to destroy. Do you want to perform these actions? Terraform will perform the actions described above. Only 'yes' will be accepted to approve. Enter a value: yes aws_instance.webserver: Modifying... (ID: i-0a7d259b3126e16b8) vpc_security_group_ids.118229083: \"\" => \"sg-0c22a3497351d1caa\" vpc_security_group_ids.3314100969: \"sg-a42b7ae9\" => \"\" aws_instance.webserver: Still modifying... (ID: i-0a7d259b3126e16b8, 10s elapsed) aws_instance.webserver: Modifications complete after 13s (ID: i-0a7d259b3126e16b8) Apply complete! Resources: 0 added, 1 changed, 0 destroyed. Check in your AWS console to check the same. Now you should be able to SSH into the machine. ssh ubuntu@34.203.194.201 [output] Warning: Permanently added '34.203.194.201' (ECDSA) to the list of known hosts. Welcome to Ubuntu 14.04 LTS (GNU/Linux 3.13.0-29-generic x86_64) ubuntu@ip-172-31-40-32:~$ Exercise: Remove the explicit dependecy by using the key_pair with above given attribute reference method Type 2: User Defined(Input) Variables It is always a good practice to remove data from code. In our manifest, we are hardcoding all the values. Instead we should use variables to define the values and reference them in the manifest. Create a new file with the name variables.tf touch variables.tf Syntax : variable \"name\" { description = \"describe your variable\" default = \"default value\" } Let us define our first variable in this file. file: variables.tf variable \"ami\" { description = \"ami for the instance\" default = \"ami-0ac019f4fcb7cb7e6\" } This variable can be referenced in the main manifest like the following. [...] resource \"aws_instance\" \"frontend\" { ami = \"${var.ami}\" instance_type = \"t2.micro\" key_name = \"terraform\" vpc_security_group_ids = [\"${aws_security_group.front-end.id}\"] depends_on = [\"aws_key_pair.terraform\"] tags { Name = \"tf-frontend-01\" App = \"devops-demo\" Maintainer = \"Gourav Shah\" Role =\"frontend\" } } [...] Let us apply the manifest to see if this works. Terraform automatically loads all the files with .tf extension from the working directory. So we do not need to implicitly mention about the variable file. terraform apply [output] aws_key_pair.webserver_key: Refreshing state... (ID: web-admin-key) aws_security_group.webserver_sg: Refreshing state... (ID: sg-0c22a3497351d1caa) aws_instance.webserver: Refreshing state... (ID: i-0a7d259b3126e16b8) Apply complete! Resources: 0 added, 0 changed, 0 destroyed. Let us parameterize some properties from our main manifest. file: variables.tf # default type is string variable \"ami\" { description = \"ami for the instance\" default = \"ami-0ac019f4fcb7cb7e6\" } # map type variable definition variable \"instance\" { description = \"instance parameters\" type = \"map\" default = { type = \"t2.micro\" name = \"tf-frontend-01\" } } variable \"key_name\" { description = \"name of the key\" default = \"terraform\" } variable \"key_pub\" { description = \"content of public key\" default = \"ssh-rsa AAAAB3NzaC1yc2EAAAADAQABAAABAQC4Q2TBuAD7ijkPjp+/Hl/QnrNo4hoZEz/l+UBsfvlDuJk8zfh0ivnQLtoYyXNuJ3/BjTVVIchrGo8CLZdTco//n+YBvMqgW4Wg5F92JNNkR5L5x04ELRUmC3ed1ZqbwrLmujzB33nMJ8Ld5dJjtS55KJa5MwkCaP7lqGicU2NgXe+if2DhCKW/lZyCpkkvRgmB7oEqj6aBWNjp+FMY4v6BtcmmB/+1Ry+GMvmZJO1EjSeUHAWCec3snX7TxJKHf4opwTHxknmhRKkz8+pS8rxyjiBeyncxP9jL9Tx/Zh6qmExCUfuhAWk87sjbb3j0enVs2LtzJOG9eBZ726wD83TJ vibe@vibes-MacBook-Air.local\" } Here is fully parameterized main manifest. file: main.tf provider \"aws\" { region = \"ap-southeast-1\" } resource \"aws_instance\" \"frontend\" { ami = \"${var.ami}\" instance_type = \"${var.instance[\"type\"]}\" key_name = \"web-admin-key\" vpc_security_group_ids = [\"${aws_security_group.frontend.id}\"] depends_on = [\"aws_key_pair.terraform\"] tags { Name = \"${var.instance[\"name\"]}\" } } resource \"aws_security_group\" \"frontend\" { name = \"frontend\" ingress { from_port = 22 to_port = 22 protocol = \"tcp\" cidr_blocks = [\"0.0.0.0/0\"] } } resource \"aws_key_pair\" \"terraform\" { key_name = \"${var.key_name}\" public_key = \"${var.key_pub}\" } I've intentionally set the variable instance.name to demo-server . Let us apply the manifest. terraform apply [output] aws_security_group.webserver_sg: Refreshing state... (ID: sg-0c22a3497351d1caa) aws_key_pair.webserver_key: Refreshing state... (ID: web-admin-key) aws_instance.webserver: Refreshing state... (ID: i-0a7d259b3126e16b8) An execution plan has been generated and is shown below. Resource actions are indicated with the following symbols: ~ update in-place Terraform will perform the following actions: ~ aws_instance.webserver tags.Name: \"weberserver\" => \"devops-server\" Plan: 0 to add, 1 to change, 0 to destroy. Do you want to perform these actions? Terraform will perform the actions described above. Only 'yes' will be accepted to approve. Enter a value: yes aws_instance.webserver: Modifying... (ID: i-0a7d259b3126e16b8) tags.Name: \"weberserver\" => \"devops-server\" aws_instance.webserver: Still modifying... (ID: i-0a7d259b3126e16b8, 10s elapsed) aws_instance.webserver: Modifications complete after 14s (ID: i-0a7d259b3126e16b8) Apply complete! Resources: 0 added, 1 changed, 0 destroyed. Terraform has substituted the value of instance name from variables, thus it has changed the resource as well. Type 3: Output Variables Output variables help us to refer the metadata of resources after they are applied. This saves a lot of time, because we don't have to find go to AWS web console to find the details. Let us get the public ip of the instance we've created by using output variable. file: main.tf [...] output \"webserver_ip\" { value = \"${aws_instance.webserver.public_ip}\" } [...] Output variables also uses variable interpolation. Run terraform apply to see output variables in action. terraform apply [output] aws_security_group.webserver_sg: Refreshing state... (ID: sg-0c22a3497351d1caa) aws_key_pair.webserver_key: Refreshing state... (ID: web-admin-key) aws_instance.webserver: Refreshing state... (ID: i-0a7d259b3126e16b8) Apply complete! Resources: 0 added, 0 changed, 0 destroyed. Outputs: webserver_ip = 34.203.194.201 TODO usage of environment vars Reference If you want know more about variables, please visit the official documentation .","title":"Input and Output Variables"},{"location":"06-variables-and-outputs/#variables","text":"Let us try to ssh into the machine that we've just created. Get the public IP from the AWS console. ssh ubuntu@34.203.194.201 [output] ssh: connect to host 34.203.194.201 port 22: Operation timed out You will not be able to SSH. The reason is we have not associated the security group that we have created with this instance. The instance is still using the default security group which doesn't allow ssh. We need to fix this issue. Let us associate our security group with this machine. file: main.tf Bad Practice resource \"aws_instance\" \"frontend\" { ami = \"ami-0ac019f4fcb7cb7e6\" instance_type = \"t2.micro\" key_name = \"terraform\" vpc_security_group_ids = \"sg-0c22a3497351d1caa\" depends_on = [\"aws_key_pair.terraform\"] tags { Name = \"tf-frontend-01\" App = \"devops-demo\" Maintainer = \"Gourav Shah\" Role =\"frontend\" } } We can manually copy the ID of the security group and apply the manifest. This would work but this is an ugly fix. We should let Terraform to find the these kind of mutable data. Thats where Variables come into picture.","title":"Variables"},{"location":"06-variables-and-outputs/#type-1-attribute-of-a-resource","text":"file: main.tf Good Practice resource \"aws_instance\" \"frontend\" { ami = \"ami-0ac019f4fcb7cb7e6\" instance_type = \"t2.micro\" key_name = \"terraform\" vpc_security_group_ids = [\"${aws_security_group.front-end.id}\"] depends_on = [\"aws_key_pair.terraform\"] tags { Name = \"tf-frontend-01\" App = \"devops-demo\" Maintainer = \"Gourav Shah\" Role =\"frontend\" } } This is how variable interpolation works in Terraform. Syntax: ${TYPE.NAME.ATTRIBUTE} In our case, it is, ${aws_security_group.fornt-end.id} . Here, aws_security_group => TYPE webserver_sg => NAME id => ATTRIBUTE Every resource has set of attribute that can be referred as a variable. aws_security_group resource has the following attributes which can be referred. * id - The ID of the security group * arn - The ARN of the security group * vpc_id - The VPC ID. * owner_id - The owner ID. * name - The name of the security group * description - The description of the security group * ingress - The ingress rules. See above for more. * egress - The egress rules. See above for more. This also creates an Implicit Dependency . Terraform will know that this security group has to be created before the EC2 instance since the later refers to it. Let us apply the given manifest. Let us apply the manifest. terraform apply [output] An execution plan has been generated and is shown below. Resource actions are indicated with the following symbols: ~ update in-place Terraform will perform the following actions: ~ aws_instance.webserver vpc_security_group_ids.118229083: \"\" => \"sg-0c22a3497351d1caa\" vpc_security_group_ids.3314100969: \"sg-a42b7ae9\" => \"\" Plan: 0 to add, 1 to change, 0 to destroy. Do you want to perform these actions? Terraform will perform the actions described above. Only 'yes' will be accepted to approve. Enter a value: yes aws_instance.webserver: Modifying... (ID: i-0a7d259b3126e16b8) vpc_security_group_ids.118229083: \"\" => \"sg-0c22a3497351d1caa\" vpc_security_group_ids.3314100969: \"sg-a42b7ae9\" => \"\" aws_instance.webserver: Still modifying... (ID: i-0a7d259b3126e16b8, 10s elapsed) aws_instance.webserver: Modifications complete after 13s (ID: i-0a7d259b3126e16b8) Apply complete! Resources: 0 added, 1 changed, 0 destroyed. Check in your AWS console to check the same. Now you should be able to SSH into the machine. ssh ubuntu@34.203.194.201 [output] Warning: Permanently added '34.203.194.201' (ECDSA) to the list of known hosts. Welcome to Ubuntu 14.04 LTS (GNU/Linux 3.13.0-29-generic x86_64) ubuntu@ip-172-31-40-32:~$ Exercise: Remove the explicit dependecy by using the key_pair with above given attribute reference method","title":"Type 1: Attribute of a Resource"},{"location":"06-variables-and-outputs/#type-2-user-definedinput-variables","text":"It is always a good practice to remove data from code. In our manifest, we are hardcoding all the values. Instead we should use variables to define the values and reference them in the manifest. Create a new file with the name variables.tf touch variables.tf Syntax : variable \"name\" { description = \"describe your variable\" default = \"default value\" } Let us define our first variable in this file. file: variables.tf variable \"ami\" { description = \"ami for the instance\" default = \"ami-0ac019f4fcb7cb7e6\" } This variable can be referenced in the main manifest like the following. [...] resource \"aws_instance\" \"frontend\" { ami = \"${var.ami}\" instance_type = \"t2.micro\" key_name = \"terraform\" vpc_security_group_ids = [\"${aws_security_group.front-end.id}\"] depends_on = [\"aws_key_pair.terraform\"] tags { Name = \"tf-frontend-01\" App = \"devops-demo\" Maintainer = \"Gourav Shah\" Role =\"frontend\" } } [...] Let us apply the manifest to see if this works. Terraform automatically loads all the files with .tf extension from the working directory. So we do not need to implicitly mention about the variable file. terraform apply [output] aws_key_pair.webserver_key: Refreshing state... (ID: web-admin-key) aws_security_group.webserver_sg: Refreshing state... (ID: sg-0c22a3497351d1caa) aws_instance.webserver: Refreshing state... (ID: i-0a7d259b3126e16b8) Apply complete! Resources: 0 added, 0 changed, 0 destroyed. Let us parameterize some properties from our main manifest. file: variables.tf # default type is string variable \"ami\" { description = \"ami for the instance\" default = \"ami-0ac019f4fcb7cb7e6\" } # map type variable definition variable \"instance\" { description = \"instance parameters\" type = \"map\" default = { type = \"t2.micro\" name = \"tf-frontend-01\" } } variable \"key_name\" { description = \"name of the key\" default = \"terraform\" } variable \"key_pub\" { description = \"content of public key\" default = \"ssh-rsa AAAAB3NzaC1yc2EAAAADAQABAAABAQC4Q2TBuAD7ijkPjp+/Hl/QnrNo4hoZEz/l+UBsfvlDuJk8zfh0ivnQLtoYyXNuJ3/BjTVVIchrGo8CLZdTco//n+YBvMqgW4Wg5F92JNNkR5L5x04ELRUmC3ed1ZqbwrLmujzB33nMJ8Ld5dJjtS55KJa5MwkCaP7lqGicU2NgXe+if2DhCKW/lZyCpkkvRgmB7oEqj6aBWNjp+FMY4v6BtcmmB/+1Ry+GMvmZJO1EjSeUHAWCec3snX7TxJKHf4opwTHxknmhRKkz8+pS8rxyjiBeyncxP9jL9Tx/Zh6qmExCUfuhAWk87sjbb3j0enVs2LtzJOG9eBZ726wD83TJ vibe@vibes-MacBook-Air.local\" } Here is fully parameterized main manifest. file: main.tf provider \"aws\" { region = \"ap-southeast-1\" } resource \"aws_instance\" \"frontend\" { ami = \"${var.ami}\" instance_type = \"${var.instance[\"type\"]}\" key_name = \"web-admin-key\" vpc_security_group_ids = [\"${aws_security_group.frontend.id}\"] depends_on = [\"aws_key_pair.terraform\"] tags { Name = \"${var.instance[\"name\"]}\" } } resource \"aws_security_group\" \"frontend\" { name = \"frontend\" ingress { from_port = 22 to_port = 22 protocol = \"tcp\" cidr_blocks = [\"0.0.0.0/0\"] } } resource \"aws_key_pair\" \"terraform\" { key_name = \"${var.key_name}\" public_key = \"${var.key_pub}\" } I've intentionally set the variable instance.name to demo-server . Let us apply the manifest. terraform apply [output] aws_security_group.webserver_sg: Refreshing state... (ID: sg-0c22a3497351d1caa) aws_key_pair.webserver_key: Refreshing state... (ID: web-admin-key) aws_instance.webserver: Refreshing state... (ID: i-0a7d259b3126e16b8) An execution plan has been generated and is shown below. Resource actions are indicated with the following symbols: ~ update in-place Terraform will perform the following actions: ~ aws_instance.webserver tags.Name: \"weberserver\" => \"devops-server\" Plan: 0 to add, 1 to change, 0 to destroy. Do you want to perform these actions? Terraform will perform the actions described above. Only 'yes' will be accepted to approve. Enter a value: yes aws_instance.webserver: Modifying... (ID: i-0a7d259b3126e16b8) tags.Name: \"weberserver\" => \"devops-server\" aws_instance.webserver: Still modifying... (ID: i-0a7d259b3126e16b8, 10s elapsed) aws_instance.webserver: Modifications complete after 14s (ID: i-0a7d259b3126e16b8) Apply complete! Resources: 0 added, 1 changed, 0 destroyed. Terraform has substituted the value of instance name from variables, thus it has changed the resource as well.","title":"Type 2: User Defined(Input) Variables"},{"location":"06-variables-and-outputs/#type-3-output-variables","text":"Output variables help us to refer the metadata of resources after they are applied. This saves a lot of time, because we don't have to find go to AWS web console to find the details. Let us get the public ip of the instance we've created by using output variable. file: main.tf [...] output \"webserver_ip\" { value = \"${aws_instance.webserver.public_ip}\" } [...] Output variables also uses variable interpolation. Run terraform apply to see output variables in action. terraform apply [output] aws_security_group.webserver_sg: Refreshing state... (ID: sg-0c22a3497351d1caa) aws_key_pair.webserver_key: Refreshing state... (ID: web-admin-key) aws_instance.webserver: Refreshing state... (ID: i-0a7d259b3126e16b8) Apply complete! Resources: 0 added, 0 changed, 0 destroyed. Outputs: webserver_ip = 34.203.194.201","title":"Type 3: Output Variables"},{"location":"06-variables-and-outputs/#todo","text":"usage of environment vars","title":"TODO"},{"location":"06-variables-and-outputs/#reference","text":"If you want know more about variables, please visit the official documentation .","title":"Reference"},{"location":"07-provisioners/","text":"Provisioners Provisioners are used to execute scripts either on local machines or on remote machines. Provisioners will run at either * Resource creation time , hence called Creation-Time provisioner or * Resource destruction time, hence called Destroy-Time provisioner Most generally used provisioners are, * file => copy file from local to remote * local-exec => execute on the machine where you run Terraform commands * remote-exec => execute on the machine created/modified by Terrform Devops Demo Application We will set up this application using creation-time provisioner. File Provisioner Create a new file with the name user-data.sh touch user-data.sh file: user-data.sh #!/bin/bash sudo apt update sudo apt install -y software-properties-common language-pack-en-base dialog apt-utils sudo update-locale LC_ALL=en_US.UTF-8 LANG=en_US.UTF-8 sudo cp /usr/share/zoneinfo/America/New_York /etc/localtime sudo LC_ALL=en_US.UTF-8 add-apt-repository -y ppa:ondrej/php sudo apt update sudo apt install -yq apache2 php5.6 php5.6-mysql mysql-client sudo rm -rf /var/www/html/* sudo wget https://github.com/devopsdemoapps/devops-demo/raw/master/devops-demo.tar.gz sudo tar -xvzf devops-demo.tar.gz -C /var/www/html/ sudo wget https://raw.githubusercontent.com/devopsdemoapps/devops-demo/master/devops-demo.sql sudo service apache2 restart file: main.tf [...] resource \"aws_instance\" \"frontend\" { ami = \"${var.ami}\" instance_type = \"${var.instance[\"type\"]}\" key_name = \"${var.key[\"name\"]}\" vpc_security_group_ids = [\"${aws_security_group.frontend.id}\"] depends_on = [\"aws_key_pair.webserver_key\"] tags { Name = \"${var.instance[\"name\"]}\" } provisioner \"file\" { source = \"user-data.sh\" destination = \"/tmp/user-data.sh\" connection { type = \"ssh\" user = \"ubuntu\" private_key = \"${file(\"~/.ssh/terraform-ap)}\" } } } [...] We will need to destroy and recreate the resources to apply this provisioner terraform destroy [output] Destroy complete! Resources: 2 destroyed. terraform apply [output] aws_instance.webserver: Still creating... (10s elapsed) aws_instance.webserver: Still creating... (20s elapsed) aws_instance.webserver: Still creating... (30s elapsed) aws_instance.webserver: Provisioning with 'file'... aws_instance.webserver: Still creating... (40s elapsed) aws_instance.webserver: Still creating... (50s elapsed) aws_instance.webserver: Still creating... (1m0s elapsed) aws_instance.webserver: Still creating... (1m10s elapsed) aws_instance.webserver: Creation complete after 1m11s (ID: i-02888bbc102c4d0ed) Apply complete! Resources: 3 added, 0 changed, 0 destroyed. Outputs: webserver_ip = 35.173.254.26 Remote-Exec Provisioner Now we will execute the script that we have just copied over. file: main.tf resource \"aws_instance\" \"frontend\" { ami = \"${var.ami}\" instance_type = \"${var.instance[\"type\"]}\" key_name = \"${var.key[\"name\"]}\" vpc_security_group_ids = [\"${aws_security_group.frontend.id}\"] depends_on = [\"aws_key_pair.webserver_key\"] tags { Name = \"${var.instance[\"name\"]}\" } provisioner \"file\" { source = \"user-data.sh\" destination = \"/tmp/user-data.sh\" connection { type = \"ssh\" user = \"${var.ssh_user}\" private_key = \"${file(var.ssh_pvtkey)}\" } } provisioner \"remote-exec\" { inline = [ \"chmod +x /tmp/user-data.sh\", \"/tmp/user-data.sh\", ] connection { type = \"ssh\" user = \"${var.ssh_user}\" private_key = \"${file(\"~/.ssh/terraform-ap\")}\" } } } We will also add the ingress policy port 80 and egress policy for allo traffic in our security group. file: main.tf [...] resource \"aws_security_group\" \"front-end\" { name = \"front-end\" ingress { cidr_blocks = [\"0.0.0.0/0\"] from_port = 22 to_port = 22 protocol = \"tcp\" description = \"Open SSH port to all \" } ingress { cidr_blocks = [\"0.0.0.0/0\"] from_port = 80 to_port = 80 protocol = \"tcp\" description = \"Open HTTP port to all \" } egress { from_port = 0 to_port = 0 protocol = \"-1\" cidr_blocks = [\"0.0.0.0/0\"] description =\"allow all outgoing connections\" } } [...] For this remote-exec provisioner to take effect, we need to recreate the resources(since these are creation-time provisoners). terraform destroy [output] aws_instance.webserver: Still destroying... (ID: i-02888bbc102c4d0ed, 30s elapsed) aws_instance.webserver: Still destroying... (ID: i-02888bbc102c4d0ed, 40s elapsed) aws_instance.webserver: Destruction complete after 48s aws_key_pair.webserver_key: Destroying... (ID: web-admin-key) aws_security_group.webserver_sg: Destroying... (ID: sg-097c880ffd1c9f6c3) aws_key_pair.webserver_key: Destruction complete after 1s aws_security_group.webserver_sg: Destruction complete after 3s Destroy complete! Resources: 3 destroyed. terrform apply [output] aws_instance.webserver (remote-exec): Connecting to raw.githubusercontent.com (raw.githubusercontent.com)|151.101.200.133|:443... connected. aws_instance.webserver (remote-exec): HTTP request sent, awaiting response... 200 OK aws_instance.webserver (remote-exec): Length: 233 [text/plain] aws_instance.webserver (remote-exec): Saving to: \u2018devops-demo.sql\u2019 aws_instance.webserver (remote-exec): 0% 0 --.-K/s aws_instance.webserver (remote-exec): 100% 233 --.-K/s in 0s aws_instance.webserver (remote-exec): 2018-09-24 12:36:02 (9.54 MB/s) - \u2018devops-demo.sql\u2019 saved [233/233] aws_instance.webserver: Creation complete after 5m11s (ID: i-02848bbc106c45ced) Apply complete! Resources: 3 added, 0 changed, 0 destroyed. Outputs: webserver_ip = 35.173.130.100 Once the creation is complete, you should be able to access the application by visiting the instance's public IP. We shall discuss about local-exec provisioner in the next chapter. Reference For more details about provisioners, please visit this link .","title":"Provisioners in detail"},{"location":"07-provisioners/#provisioners","text":"Provisioners are used to execute scripts either on local machines or on remote machines. Provisioners will run at either * Resource creation time , hence called Creation-Time provisioner or * Resource destruction time, hence called Destroy-Time provisioner Most generally used provisioners are, * file => copy file from local to remote * local-exec => execute on the machine where you run Terraform commands * remote-exec => execute on the machine created/modified by Terrform","title":"Provisioners"},{"location":"07-provisioners/#devops-demo-application","text":"We will set up this application using creation-time provisioner.","title":"Devops Demo Application"},{"location":"07-provisioners/#file-provisioner","text":"Create a new file with the name user-data.sh touch user-data.sh file: user-data.sh #!/bin/bash sudo apt update sudo apt install -y software-properties-common language-pack-en-base dialog apt-utils sudo update-locale LC_ALL=en_US.UTF-8 LANG=en_US.UTF-8 sudo cp /usr/share/zoneinfo/America/New_York /etc/localtime sudo LC_ALL=en_US.UTF-8 add-apt-repository -y ppa:ondrej/php sudo apt update sudo apt install -yq apache2 php5.6 php5.6-mysql mysql-client sudo rm -rf /var/www/html/* sudo wget https://github.com/devopsdemoapps/devops-demo/raw/master/devops-demo.tar.gz sudo tar -xvzf devops-demo.tar.gz -C /var/www/html/ sudo wget https://raw.githubusercontent.com/devopsdemoapps/devops-demo/master/devops-demo.sql sudo service apache2 restart file: main.tf [...] resource \"aws_instance\" \"frontend\" { ami = \"${var.ami}\" instance_type = \"${var.instance[\"type\"]}\" key_name = \"${var.key[\"name\"]}\" vpc_security_group_ids = [\"${aws_security_group.frontend.id}\"] depends_on = [\"aws_key_pair.webserver_key\"] tags { Name = \"${var.instance[\"name\"]}\" } provisioner \"file\" { source = \"user-data.sh\" destination = \"/tmp/user-data.sh\" connection { type = \"ssh\" user = \"ubuntu\" private_key = \"${file(\"~/.ssh/terraform-ap)}\" } } } [...] We will need to destroy and recreate the resources to apply this provisioner terraform destroy [output] Destroy complete! Resources: 2 destroyed. terraform apply [output] aws_instance.webserver: Still creating... (10s elapsed) aws_instance.webserver: Still creating... (20s elapsed) aws_instance.webserver: Still creating... (30s elapsed) aws_instance.webserver: Provisioning with 'file'... aws_instance.webserver: Still creating... (40s elapsed) aws_instance.webserver: Still creating... (50s elapsed) aws_instance.webserver: Still creating... (1m0s elapsed) aws_instance.webserver: Still creating... (1m10s elapsed) aws_instance.webserver: Creation complete after 1m11s (ID: i-02888bbc102c4d0ed) Apply complete! Resources: 3 added, 0 changed, 0 destroyed. Outputs: webserver_ip = 35.173.254.26","title":"File Provisioner"},{"location":"07-provisioners/#remote-exec-provisioner","text":"Now we will execute the script that we have just copied over. file: main.tf resource \"aws_instance\" \"frontend\" { ami = \"${var.ami}\" instance_type = \"${var.instance[\"type\"]}\" key_name = \"${var.key[\"name\"]}\" vpc_security_group_ids = [\"${aws_security_group.frontend.id}\"] depends_on = [\"aws_key_pair.webserver_key\"] tags { Name = \"${var.instance[\"name\"]}\" } provisioner \"file\" { source = \"user-data.sh\" destination = \"/tmp/user-data.sh\" connection { type = \"ssh\" user = \"${var.ssh_user}\" private_key = \"${file(var.ssh_pvtkey)}\" } } provisioner \"remote-exec\" { inline = [ \"chmod +x /tmp/user-data.sh\", \"/tmp/user-data.sh\", ] connection { type = \"ssh\" user = \"${var.ssh_user}\" private_key = \"${file(\"~/.ssh/terraform-ap\")}\" } } } We will also add the ingress policy port 80 and egress policy for allo traffic in our security group. file: main.tf [...] resource \"aws_security_group\" \"front-end\" { name = \"front-end\" ingress { cidr_blocks = [\"0.0.0.0/0\"] from_port = 22 to_port = 22 protocol = \"tcp\" description = \"Open SSH port to all \" } ingress { cidr_blocks = [\"0.0.0.0/0\"] from_port = 80 to_port = 80 protocol = \"tcp\" description = \"Open HTTP port to all \" } egress { from_port = 0 to_port = 0 protocol = \"-1\" cidr_blocks = [\"0.0.0.0/0\"] description =\"allow all outgoing connections\" } } [...] For this remote-exec provisioner to take effect, we need to recreate the resources(since these are creation-time provisoners). terraform destroy [output] aws_instance.webserver: Still destroying... (ID: i-02888bbc102c4d0ed, 30s elapsed) aws_instance.webserver: Still destroying... (ID: i-02888bbc102c4d0ed, 40s elapsed) aws_instance.webserver: Destruction complete after 48s aws_key_pair.webserver_key: Destroying... (ID: web-admin-key) aws_security_group.webserver_sg: Destroying... (ID: sg-097c880ffd1c9f6c3) aws_key_pair.webserver_key: Destruction complete after 1s aws_security_group.webserver_sg: Destruction complete after 3s Destroy complete! Resources: 3 destroyed. terrform apply [output] aws_instance.webserver (remote-exec): Connecting to raw.githubusercontent.com (raw.githubusercontent.com)|151.101.200.133|:443... connected. aws_instance.webserver (remote-exec): HTTP request sent, awaiting response... 200 OK aws_instance.webserver (remote-exec): Length: 233 [text/plain] aws_instance.webserver (remote-exec): Saving to: \u2018devops-demo.sql\u2019 aws_instance.webserver (remote-exec): 0% 0 --.-K/s aws_instance.webserver (remote-exec): 100% 233 --.-K/s in 0s aws_instance.webserver (remote-exec): 2018-09-24 12:36:02 (9.54 MB/s) - \u2018devops-demo.sql\u2019 saved [233/233] aws_instance.webserver: Creation complete after 5m11s (ID: i-02848bbc106c45ced) Apply complete! Resources: 3 added, 0 changed, 0 destroyed. Outputs: webserver_ip = 35.173.130.100 Once the creation is complete, you should be able to access the application by visiting the instance's public IP. We shall discuss about local-exec provisioner in the next chapter.","title":"Remote-Exec Provisioner"},{"location":"07-provisioners/#reference","text":"For more details about provisioners, please visit this link .","title":"Reference"},{"location":"08-datasources/","text":"Data Source Data sources are read only information that Terraform can get from Provider's API. When we use data source, Terraform doesn't create/modify anything. It just queries the API, so that the data can be used by other resources. Let us create a RDS DB manually and we will refer to it in our manifest. Creating RDS DB Go to RDS service page. Select MySQL DB Engine. Provide the DB instance the following name and enter some complex password. Provide the following network settings for the instance. Provide your DB a name and disable IAM authentication. Leave all other values to default and create the DB. Using Datasource Let us add the datasource block for RDS in our main.tf file: main.tf [...] data \"aws_db_instance\" \"database\" { provider = \"aws.singapore\" db_instance_identifier = \"${var.rds_name}\" } We have parameterized the attribute db_instance_identifier which is the db instance's name. Define the variable rds_name in variables.tf . file: variables.tf [...] variable \"rds_name\" { default = \"devopsdemo-db\" } [...] Let us check whether Terraform is able to fetch the datasource details from AWS API. file: main.tf [...] output \"rds_endpoint\" { value = \"${data.aws_db_instance.database.endpoint}\" } [...] Let us plan and apply. terraform plan terraform apply [output] Acquiring state lock. This may take a few moments... aws_security_group.webserver_sg: Refreshing state... (ID: sg-0c740c046e9bcf571) aws_key_pair.webserver_key: Refreshing state... (ID: web-admin-key) data.aws_db_instance.database: Refreshing state... aws_instance.webserver: Refreshing state... (ID: i-082d8b9097ae94c53) Apply complete! Resources: 0 added, 0 changed, 0 destroyed. Releasing state lock. This may take a few moments... Outputs: rds_endpoint = devopsdemo-db.cewjdhpv9lg6.us-east-1.rds.amazonaws.com:3306 webserver_ip = 54.165.195.171 We are able to get the endpoint for a resource which was not created Terraform. Updating database configs using Templates (.tpl) We have already learnt how to discover RDS which was created outside of terraform. Now, its time to update application configurations to provide database connection information. To achieve this we would create a template file use a new provider, template along with a data source with vars. file: config.ini.tpl [database] hostname = \"${dbhost}\" username = \"${dbuser}\" password = \"${dbpass}\" dbname = \"${dbname}\" [environment] environment = DEV [prefs] color = white fruit = apple car = fiat laptop = dell file: main.tf data \"template_file\" \"dbconfig\" { template = \"${file(\"${path.module}/config.ini.tpl\")}\" vars { dbhost = \"${data.aws_db_instance.database.address}\" dbpass = \"${var.rds_pass}\" dbuser = \"${data.aws_db_instance.database.master_username}\" dbname = \"${data.aws_db_instance.database.db_name}\" } } file: variables.tf [...] variable \"rds_pass\" { default = \"password\" } [...] We need to run terraform init to install the template provider plugin. terraform init [output] Initializing the backend... Initializing provider plugins... - Checking for available provider plugins on https://releases.hashicorp.com... - Downloading plugin for provider \"template\" (1.0.0)... The following providers do not have any version constraints in configuration, so the latest version was installed. To prevent automatic upgrades to new major versions that may contain breaking changes, it is recommended to add version = \"...\" constraints to the corresponding provider blocks in configuration, with the constraint strings suggested below. * provider.aws: version = \"~> 1.37\" * provider.template: version = \"~> 1.0\" Terraform has been successfully initialized! You may now begin working with Terraform. Try running \"terraform plan\" to see any changes that are required for your infrastructure. All Terraform commands should now work. Updating instance to copy template with a file provisioner In addition to generating a template, it also needs to be copied over to the instance at /var/www/html/config.ini as thats where the application will look for the configs. file: main.tf provisioner \"file\" { content = \"${data.template_file.dbconfig.rendered}\" destination = \"/var/www/html/config.ini\" connection { type = \"ssh\" user = \"ubuntu\" private_key = \"${file(\"~/.ssh/terraform\")}\" } } Then run terraform plan and apply terraform plan terrafomr apply [output] Acquiring state lock. This may take a few moments... aws_key_pair.webserver_key: Refreshing state... (ID: web-admin-key) aws_security_group.webserver_sg: Refreshing state... (ID: sg-0c740c046e9bcf571) data.aws_db_instance.database: Refreshing state... aws_instance.webserver: Refreshing state... (ID: i-082d8b9097ae94c53) An execution plan has been generated and is shown below. Resource actions are indicated with the following symbols: + create Terraform will perform the following actions: + null_resource.populate_db_01 id: <computed> Plan: 1 to add, 0 to change, 0 to destroy. Do you want to perform these actions? Terraform will perform the actions described above. Only 'yes' will be accepted to approve. Enter a value: yes [...] null_resource.populate_db_01: Provisioning with 'local-exec'... null_resource.populate_db_01 (local-exec): Executing: [\"/bin/sh\" \"-c\" \"ssh ubuntu@54.165.195.171 'sudo service apache2 restart'\"] null_resource.populate_db_01 (local-exec): * Restarting web server apache2 null_resource.populate_db_01 (local-exec): ...done. null_resource.populate_db_01: Creation complete after 20s (ID: 8985065039495500214) Apply complete! Resources: 1 added, 0 changed, 1 destroyed.","title":"Data Sources"},{"location":"08-datasources/#data-source","text":"Data sources are read only information that Terraform can get from Provider's API. When we use data source, Terraform doesn't create/modify anything. It just queries the API, so that the data can be used by other resources. Let us create a RDS DB manually and we will refer to it in our manifest.","title":"Data Source"},{"location":"08-datasources/#creating-rds-db","text":"Go to RDS service page. Select MySQL DB Engine. Provide the DB instance the following name and enter some complex password. Provide the following network settings for the instance. Provide your DB a name and disable IAM authentication. Leave all other values to default and create the DB.","title":"Creating RDS DB"},{"location":"08-datasources/#using-datasource","text":"Let us add the datasource block for RDS in our main.tf file: main.tf [...] data \"aws_db_instance\" \"database\" { provider = \"aws.singapore\" db_instance_identifier = \"${var.rds_name}\" } We have parameterized the attribute db_instance_identifier which is the db instance's name. Define the variable rds_name in variables.tf . file: variables.tf [...] variable \"rds_name\" { default = \"devopsdemo-db\" } [...] Let us check whether Terraform is able to fetch the datasource details from AWS API. file: main.tf [...] output \"rds_endpoint\" { value = \"${data.aws_db_instance.database.endpoint}\" } [...] Let us plan and apply. terraform plan terraform apply [output] Acquiring state lock. This may take a few moments... aws_security_group.webserver_sg: Refreshing state... (ID: sg-0c740c046e9bcf571) aws_key_pair.webserver_key: Refreshing state... (ID: web-admin-key) data.aws_db_instance.database: Refreshing state... aws_instance.webserver: Refreshing state... (ID: i-082d8b9097ae94c53) Apply complete! Resources: 0 added, 0 changed, 0 destroyed. Releasing state lock. This may take a few moments... Outputs: rds_endpoint = devopsdemo-db.cewjdhpv9lg6.us-east-1.rds.amazonaws.com:3306 webserver_ip = 54.165.195.171 We are able to get the endpoint for a resource which was not created Terraform.","title":"Using Datasource"},{"location":"08-datasources/#updating-database-configs-using-templates-tpl","text":"We have already learnt how to discover RDS which was created outside of terraform. Now, its time to update application configurations to provide database connection information. To achieve this we would create a template file use a new provider, template along with a data source with vars. file: config.ini.tpl [database] hostname = \"${dbhost}\" username = \"${dbuser}\" password = \"${dbpass}\" dbname = \"${dbname}\" [environment] environment = DEV [prefs] color = white fruit = apple car = fiat laptop = dell file: main.tf data \"template_file\" \"dbconfig\" { template = \"${file(\"${path.module}/config.ini.tpl\")}\" vars { dbhost = \"${data.aws_db_instance.database.address}\" dbpass = \"${var.rds_pass}\" dbuser = \"${data.aws_db_instance.database.master_username}\" dbname = \"${data.aws_db_instance.database.db_name}\" } } file: variables.tf [...] variable \"rds_pass\" { default = \"password\" } [...] We need to run terraform init to install the template provider plugin. terraform init [output] Initializing the backend... Initializing provider plugins... - Checking for available provider plugins on https://releases.hashicorp.com... - Downloading plugin for provider \"template\" (1.0.0)... The following providers do not have any version constraints in configuration, so the latest version was installed. To prevent automatic upgrades to new major versions that may contain breaking changes, it is recommended to add version = \"...\" constraints to the corresponding provider blocks in configuration, with the constraint strings suggested below. * provider.aws: version = \"~> 1.37\" * provider.template: version = \"~> 1.0\" Terraform has been successfully initialized! You may now begin working with Terraform. Try running \"terraform plan\" to see any changes that are required for your infrastructure. All Terraform commands should now work.","title":"Updating database configs using Templates (.tpl)"},{"location":"08-datasources/#updating-instance-to-copy-template-with-a-file-provisioner","text":"In addition to generating a template, it also needs to be copied over to the instance at /var/www/html/config.ini as thats where the application will look for the configs. file: main.tf provisioner \"file\" { content = \"${data.template_file.dbconfig.rendered}\" destination = \"/var/www/html/config.ini\" connection { type = \"ssh\" user = \"ubuntu\" private_key = \"${file(\"~/.ssh/terraform\")}\" } } Then run terraform plan and apply terraform plan terrafomr apply [output] Acquiring state lock. This may take a few moments... aws_key_pair.webserver_key: Refreshing state... (ID: web-admin-key) aws_security_group.webserver_sg: Refreshing state... (ID: sg-0c740c046e9bcf571) data.aws_db_instance.database: Refreshing state... aws_instance.webserver: Refreshing state... (ID: i-082d8b9097ae94c53) An execution plan has been generated and is shown below. Resource actions are indicated with the following symbols: + create Terraform will perform the following actions: + null_resource.populate_db_01 id: <computed> Plan: 1 to add, 0 to change, 0 to destroy. Do you want to perform these actions? Terraform will perform the actions described above. Only 'yes' will be accepted to approve. Enter a value: yes [...] null_resource.populate_db_01: Provisioning with 'local-exec'... null_resource.populate_db_01 (local-exec): Executing: [\"/bin/sh\" \"-c\" \"ssh ubuntu@54.165.195.171 'sudo service apache2 restart'\"] null_resource.populate_db_01 (local-exec): * Restarting web server apache2 null_resource.populate_db_01 (local-exec): ...done. null_resource.populate_db_01: Creation complete after 20s (ID: 8985065039495500214) Apply complete! Resources: 1 added, 0 changed, 1 destroyed.","title":"Updating instance to copy template with a file provisioner"},{"location":"09-terraform-state/","text":"Terraform State One advantage, Terraform has over other configuration management tools like Ansible and Chef is State management. Terraform stores/tracks all our infrastructure information(that we have created using Terraform) in a file with the name terraform.tfstate . In the last chapter, we have ran terraform apply . This command would create the above mentioned JSON flavoured statefile. Let us look at its the content. terraform.tfstate { \"version\": 3, \"terraform_version\": \"0.11.7\", \"serial\": 1, \"lineage\": \"138bb0c6-ca69-0d39-aa90-5e08f29c8efb\", \"modules\": [ { \"path\": [ \"root\" ], \"outputs\": {}, \"resources\": { \"aws_instance.webserver\": { \"type\": \"aws_instance\", \"depends_on\": [], \"primary\": { \"id\": \"i-02489cdf638f05bbd\", \"attributes\": { \"ami\": \"ami-408c7f28\", \"arn\": \"arn:aws:ec2:us-east-1:822941572458:instance/i-02489cdf638f05bbd\", \"associate_public_ip_address\": \"true\", \"availability_zone\": \"us-east-1d\", \"cpu_core_count\": \"1\", \"cpu_threads_per_core\": \"1\", \"credit_specification.#\": \"1\", \"credit_specification.0.cpu_credits\": \"standard\", \"disable_api_termination\": \"false\", \"ebs_block_device.#\": \"0\", \"ebs_optimized\": \"false\", \"ephemeral_block_device.#\": \"0\", \"get_password_data\": \"false\", \"iam_instance_profile\": \"\", \"id\": \"i-02489cdf638f05bbd\", \"instance_state\": \"running\", \"instance_type\": \"t1.micro\", \"ipv6_addresses.#\": \"0\", \"key_name\": \"\", \"monitoring\": \"false\", \"network_interface.#\": \"0\", \"network_interface_id\": \"eni-00fbc08209349bb38\", \"password_data\": \"\", \"placement_group\": \"\", \"primary_network_interface_id\": \"eni-00fbc08209349bb38\", \"private_dns\": \"ip-172-31-24-184.ec2.internal\", \"private_ip\": \"172.31.24.184\", \"public_dns\": \"ec2-34-230-78-138.compute-1.amazonaws.com\", \"public_ip\": \"34.230.78.138\", \"root_block_device.#\": \"1\", \"root_block_device.0.delete_on_termination\": \"true\", \"root_block_device.0.iops\": \"0\", \"root_block_device.0.volume_id\": \"vol-0cc495c189e5c8dd2\", \"root_block_device.0.volume_size\": \"8\", \"root_block_device.0.volume_type\": \"standard\", \"security_groups.#\": \"1\", \"security_groups.3814588639\": \"default\", \"source_dest_check\": \"true\", \"subnet_id\": \"subnet-e8b3e6a2\", \"tags.%\": \"0\", \"tenancy\": \"default\", \"volume_tags.%\": \"0\", \"vpc_security_group_ids.#\": \"1\", \"vpc_security_group_ids.3314100969\": \"sg-a42b7ae9\" }, \"meta\": { \"e2bfb730-ecaa-11e6-8f88-34363bc7c4c0\": { \"create\": 600000000000, \"delete\": 1200000000000, \"update\": 600000000000 }, \"schema_version\": \"1\" }, \"tainted\": false }, \"deposed\": [], \"provider\": \"provider.aws\" } }, \"depends_on\": [] } ] } Usecase 1 This file contains the metadata of our ec2 instance that we have created in the last chapter. This information will be critical when we have to create other resources which references this ec2 instance. As we add more resources to the terrform template, this file will get populated with more metadata about each resource. Usecase 2 What happens when someone manually changes(which is not desirable) the properties of the instance created by Terraform? We can undo the manual changes just by running terraform apply again. One point to keep in mind though is, some property changes forces resource recreation which might result in data loss. Changes in Terrfaform state Let us see what happens to tfstate file when we destroy the ec2 instance terraform destroy [output] aws_instance.webserver: Refreshing state... (ID: i-02489cdf638f05bbd) An execution plan has been generated and is shown below. Resource actions are indicated with the following symbols: - destroy Terraform will perform the following actions: - aws_instance.webserver Plan: 0 to add, 0 to change, 1 to destroy. Do you really want to destroy? Terraform will destroy all your managed infrastructure, as shown above. There is no undo. Only 'yes' will be accepted to confirm. Enter a value: yes [...] aws_instance.webserver: Still destroying... (ID: i-02489cdf638f05bbd, 1m0s elapsed) aws_instance.webserver: Destruction complete after 1m0s Destroy complete! Resources: 1 destroyed. file: terraform.tfstate { \"version\": 3, \"terraform_version\": \"0.11.7\", \"serial\": 2, \"lineage\": \"138bb0c6-ca69-0d39-aa90-5e08f29c8efb\", \"modules\": [ { \"path\": [ \"root\" ], \"outputs\": {}, \"resources\": {}, \"depends_on\": [] } ] } Once the machine is destroyed, all metadata about that machine is also gone. References For more information about state management in Terraform, please visit this link .","title":"State Management in Terraform"},{"location":"09-terraform-state/#terraform-state","text":"One advantage, Terraform has over other configuration management tools like Ansible and Chef is State management. Terraform stores/tracks all our infrastructure information(that we have created using Terraform) in a file with the name terraform.tfstate . In the last chapter, we have ran terraform apply . This command would create the above mentioned JSON flavoured statefile. Let us look at its the content. terraform.tfstate { \"version\": 3, \"terraform_version\": \"0.11.7\", \"serial\": 1, \"lineage\": \"138bb0c6-ca69-0d39-aa90-5e08f29c8efb\", \"modules\": [ { \"path\": [ \"root\" ], \"outputs\": {}, \"resources\": { \"aws_instance.webserver\": { \"type\": \"aws_instance\", \"depends_on\": [], \"primary\": { \"id\": \"i-02489cdf638f05bbd\", \"attributes\": { \"ami\": \"ami-408c7f28\", \"arn\": \"arn:aws:ec2:us-east-1:822941572458:instance/i-02489cdf638f05bbd\", \"associate_public_ip_address\": \"true\", \"availability_zone\": \"us-east-1d\", \"cpu_core_count\": \"1\", \"cpu_threads_per_core\": \"1\", \"credit_specification.#\": \"1\", \"credit_specification.0.cpu_credits\": \"standard\", \"disable_api_termination\": \"false\", \"ebs_block_device.#\": \"0\", \"ebs_optimized\": \"false\", \"ephemeral_block_device.#\": \"0\", \"get_password_data\": \"false\", \"iam_instance_profile\": \"\", \"id\": \"i-02489cdf638f05bbd\", \"instance_state\": \"running\", \"instance_type\": \"t1.micro\", \"ipv6_addresses.#\": \"0\", \"key_name\": \"\", \"monitoring\": \"false\", \"network_interface.#\": \"0\", \"network_interface_id\": \"eni-00fbc08209349bb38\", \"password_data\": \"\", \"placement_group\": \"\", \"primary_network_interface_id\": \"eni-00fbc08209349bb38\", \"private_dns\": \"ip-172-31-24-184.ec2.internal\", \"private_ip\": \"172.31.24.184\", \"public_dns\": \"ec2-34-230-78-138.compute-1.amazonaws.com\", \"public_ip\": \"34.230.78.138\", \"root_block_device.#\": \"1\", \"root_block_device.0.delete_on_termination\": \"true\", \"root_block_device.0.iops\": \"0\", \"root_block_device.0.volume_id\": \"vol-0cc495c189e5c8dd2\", \"root_block_device.0.volume_size\": \"8\", \"root_block_device.0.volume_type\": \"standard\", \"security_groups.#\": \"1\", \"security_groups.3814588639\": \"default\", \"source_dest_check\": \"true\", \"subnet_id\": \"subnet-e8b3e6a2\", \"tags.%\": \"0\", \"tenancy\": \"default\", \"volume_tags.%\": \"0\", \"vpc_security_group_ids.#\": \"1\", \"vpc_security_group_ids.3314100969\": \"sg-a42b7ae9\" }, \"meta\": { \"e2bfb730-ecaa-11e6-8f88-34363bc7c4c0\": { \"create\": 600000000000, \"delete\": 1200000000000, \"update\": 600000000000 }, \"schema_version\": \"1\" }, \"tainted\": false }, \"deposed\": [], \"provider\": \"provider.aws\" } }, \"depends_on\": [] } ] }","title":"Terraform State"},{"location":"09-terraform-state/#usecase-1","text":"This file contains the metadata of our ec2 instance that we have created in the last chapter. This information will be critical when we have to create other resources which references this ec2 instance. As we add more resources to the terrform template, this file will get populated with more metadata about each resource.","title":"Usecase 1"},{"location":"09-terraform-state/#usecase-2","text":"What happens when someone manually changes(which is not desirable) the properties of the instance created by Terraform? We can undo the manual changes just by running terraform apply again. One point to keep in mind though is, some property changes forces resource recreation which might result in data loss.","title":"Usecase 2"},{"location":"09-terraform-state/#changes-in-terrfaform-state","text":"Let us see what happens to tfstate file when we destroy the ec2 instance terraform destroy [output] aws_instance.webserver: Refreshing state... (ID: i-02489cdf638f05bbd) An execution plan has been generated and is shown below. Resource actions are indicated with the following symbols: - destroy Terraform will perform the following actions: - aws_instance.webserver Plan: 0 to add, 0 to change, 1 to destroy. Do you really want to destroy? Terraform will destroy all your managed infrastructure, as shown above. There is no undo. Only 'yes' will be accepted to confirm. Enter a value: yes [...] aws_instance.webserver: Still destroying... (ID: i-02489cdf638f05bbd, 1m0s elapsed) aws_instance.webserver: Destruction complete after 1m0s Destroy complete! Resources: 1 destroyed. file: terraform.tfstate { \"version\": 3, \"terraform_version\": \"0.11.7\", \"serial\": 2, \"lineage\": \"138bb0c6-ca69-0d39-aa90-5e08f29c8efb\", \"modules\": [ { \"path\": [ \"root\" ], \"outputs\": {}, \"resources\": {}, \"depends_on\": [] } ] } Once the machine is destroyed, all metadata about that machine is also gone.","title":"Changes in Terrfaform state"},{"location":"09-terraform-state/#references","text":"For more information about state management in Terraform, please visit this link .","title":"References"},{"location":"10-backends/","text":"Backends Create S3 Bucket First create a S3 bucket which is going store the state file. Enable versioning to enable state recovery if something goes wrong. Create a directory called dev in that bucket. touch backend.tf file: backend.tf terraform { backend \"s3\" { bucket = \"devopsdemo-tf-backend\" key = \"/dev\" region = \"us-east-1\" } } Create DynamoDB Table for State Locking Update our backend file accordingly. file: backend.tf terraform { backend \"s3\" { bucket = \"devopsdemo-tf-backend\" key = \"dev\" region = \"us-east-1\" dynamodb_table = \"devops-demo-table\" } } Initialize the Backend terraform init [output] Initializing the backend... Do you want to copy existing state to the new backend? Pre-existing state was found while migrating the previous \"local\" backend to the newly configured \"s3\" backend. No existing state was found in the newly configured \"s3\" backend. Do you want to copy this state to the new \"s3\" backend? Enter \"yes\" to copy and \"no\" to start with an empty state. Enter a value: yes Successfully configured the backend \"s3\"! Terraform will automatically use this backend unless the backend configuration changes. Initializing provider plugins... The following providers do not have any version constraints in configuration, so the latest version was installed. To prevent automatic upgrades to new major versions that may contain breaking changes, it is recommended to add version = \"...\" constraints to the corresponding provider blocks in configuration, with the constraint strings suggested below. * provider.aws: version = \"~> 1.37\" Terraform has been successfully initialized! You may now begin working with Terraform. Try running \"terraform plan\" to see any changes that are required for your infrastructure. All Terraform commands should now work. If you ever set or change modules or backend configuration for Terraform, rerun this command to reinitialize your working directory. If you forget, other commands will detect it and remind you to do so if necessary. Reference If you want read more about AWS Remote Backends, follow this link .","title":"Backend and Statelocking"},{"location":"10-backends/#backends","text":"","title":"Backends"},{"location":"10-backends/#create-s3-bucket","text":"First create a S3 bucket which is going store the state file. Enable versioning to enable state recovery if something goes wrong. Create a directory called dev in that bucket. touch backend.tf file: backend.tf terraform { backend \"s3\" { bucket = \"devopsdemo-tf-backend\" key = \"/dev\" region = \"us-east-1\" } }","title":"Create S3 Bucket"},{"location":"10-backends/#create-dynamodb-table-for-state-locking","text":"Update our backend file accordingly. file: backend.tf terraform { backend \"s3\" { bucket = \"devopsdemo-tf-backend\" key = \"dev\" region = \"us-east-1\" dynamodb_table = \"devops-demo-table\" } }","title":"Create DynamoDB Table for State Locking"},{"location":"10-backends/#initialize-the-backend","text":"terraform init [output] Initializing the backend... Do you want to copy existing state to the new backend? Pre-existing state was found while migrating the previous \"local\" backend to the newly configured \"s3\" backend. No existing state was found in the newly configured \"s3\" backend. Do you want to copy this state to the new \"s3\" backend? Enter \"yes\" to copy and \"no\" to start with an empty state. Enter a value: yes Successfully configured the backend \"s3\"! Terraform will automatically use this backend unless the backend configuration changes. Initializing provider plugins... The following providers do not have any version constraints in configuration, so the latest version was installed. To prevent automatic upgrades to new major versions that may contain breaking changes, it is recommended to add version = \"...\" constraints to the corresponding provider blocks in configuration, with the constraint strings suggested below. * provider.aws: version = \"~> 1.37\" Terraform has been successfully initialized! You may now begin working with Terraform. Try running \"terraform plan\" to see any changes that are required for your infrastructure. All Terraform commands should now work. If you ever set or change modules or backend configuration for Terraform, rerun this command to reinitialize your working directory. If you forget, other commands will detect it and remind you to do so if necessary.","title":"Initialize the Backend"},{"location":"10-backends/#reference","text":"If you want read more about AWS Remote Backends, follow this link .","title":"Reference"},{"location":"11-modules/","text":"Modules Modules will help you to package your Terraform configurations in to groups. This will help us to organize our code in a better way. In fact, when you run terraform apply, the current working directory holding the Terraform files you're applying comprise what is called the root module . Modules are meant to be reused. Thats why it is recommended to abstract the data from code. Creating our first module So far, we have created 4 files in total which are namely, main.tf variables.tf backend.tf user-data.sh Let us convert this into a module. Remember, variables file will not be part of module.","title":"11 modules"},{"location":"11-modules/#modules","text":"Modules will help you to package your Terraform configurations in to groups. This will help us to organize our code in a better way. In fact, when you run terraform apply, the current working directory holding the Terraform files you're applying comprise what is called the root module . Modules are meant to be reused. Thats why it is recommended to abstract the data from code.","title":"Modules"},{"location":"11-modules/#creating-our-first-module","text":"So far, we have created 4 files in total which are namely, main.tf variables.tf backend.tf user-data.sh Let us convert this into a module. Remember, variables file will not be part of module.","title":"Creating our first module"},{"location":"XX-course-outline/","text":"Goal in mind: ============= \u2022 Deploy Devops Demo app using Terraform Outline: ======== \u2022 providers |---set up credential for AWS provisioner |---show how terraform init works \u2022 backends |---introduction to backends and state locking |---show local state file |---use s3+dynamo db as backend \u2022 resources |---create vpc and subnets |---create one ec2 resource without variables \u2022 variables & outputs |---introduction to variables |---create RDS resource |---parameterise ec2 template with variables(rds password, db name,user,pw, etc.,) |---print public IP of ec2 instance, rdp endpoints, etc., with outputs \u2022 data sources |---introduction to data sources |---use an existing AMI as reference(frontend installed) \u2022 provisioners |---introduction to provisioner |---file provisioner to copy the script |---remote-exec provisioner to execute the script(set up catalogue) \u2022 modules |---introduction to modules |---create a module which contains ec2 template \u2022 other useful terraform commands(graph, fmt, etc.,) \u2022 terraform with Packer(demo) |---creation of ami with packer |---use that ami in terraform \u2022 terraform with GCP(demo) |---start with GCP provider |---GCP backend setup |---Deployment of mogambo Stack on GCP \u2022 terraform with Azure(demo) |---start with Azure provider |---Azure backend setup |---Deployment of mogambo Stack on Azure \u2022 variable interpolation(conditionals) (advanced) \u2022 terraform enterprise(advanced) \u2022 import(advanced) \u2022 templates(advanced) \u2022 plugin development(advanced)","title":"Course Outline"}]}