{
    "docs": [
        {
            "location": "/", 
            "text": "Welcome to MkDocs\n\n\nFor full documentation visit \nmkdocs.org\n.\n\n\nCommands\n\n\n\n\nmkdocs new [dir-name]\n - Create a new project.\n\n\nmkdocs serve\n - Start the live-reloading docs server.\n\n\nmkdocs build\n - Build the documentation site.\n\n\nmkdocs help\n - Print this help message.\n\n\n\n\nProject layout\n\n\nmkdocs.yml    # The configuration file.\ndocs/\n    index.md  # The documentation homepage.\n    ...       # Other markdown pages, images and other files.", 
            "title": "Home"
        }, 
        {
            "location": "/#welcome-to-mkdocs", 
            "text": "For full documentation visit  mkdocs.org .", 
            "title": "Welcome to MkDocs"
        }, 
        {
            "location": "/#commands", 
            "text": "mkdocs new [dir-name]  - Create a new project.  mkdocs serve  - Start the live-reloading docs server.  mkdocs build  - Build the documentation site.  mkdocs help  - Print this help message.", 
            "title": "Commands"
        }, 
        {
            "location": "/#project-layout", 
            "text": "mkdocs.yml    # The configuration file.\ndocs/\n    index.md  # The documentation homepage.\n    ...       # Other markdown pages, images and other files.", 
            "title": "Project layout"
        }, 
        {
            "location": "/00-environment-setup/", 
            "text": "Environement Setup\n\n\nAWS Account Setup\n\n\nTerraform Installation\n\n\nUbuntu\n\n\nFollow the following steps to install Terraform on ubuntu.\n\n\nwget https://releases.hashicorp.com/terraform/0.11.8/terraform_0.11.8_linux_amd64.zip\nunzip terraform_0.11.8_linux_amd64.zip\nsudo mv terraform /usr/local/bin\nsudo chmod +x /usr/local/bin/terraform\n\n\n\n\nWindows\n\n\nVisit the following link to download the Terraform executable.\n\n\nTerraform for Windows\n.\n\n\nExtract the file.\n\n\n\n\nCopy the extracted file.\n\n\n\n\nCreate a new directory called \nTerrafrom\n insice \nC:\\Program Files\\\n\n\n\n\nPaste the file we have copied in the previous step.\n\n\n\n\nCopy the file path for the executable.\n\n\n\nSearch for \nenvironment\n from your start menu.\n\n\n\nThen select environment variables form the window.\n\n\n\nSelect Path variable and edit it.\n\n\n\nAdd the path that we have copied earlier.\n\n\n\nMacOS\n\n\nwget https://releases.hashicorp.com/terraform/0.11.8/terraform_0.11.8_darwin_amd64.zip\nunzip terraform_0.11.8_darwin_amd64.zip\nsudo mv terraform /usr/local/bin\nsudo chmod +x /usr/local/bin/terraform\n\n\n\n\nValidate the Installation\n\n\nOpen a Shell session and run \nterraform -v\n. This should produce the following output.\n\n\nterraform -v\n\n[output]\nTerraform v0.11.7", 
            "title": "Setting up the environment"
        }, 
        {
            "location": "/00-environment-setup/#environement-setup", 
            "text": "", 
            "title": "Environement Setup"
        }, 
        {
            "location": "/00-environment-setup/#aws-account-setup", 
            "text": "", 
            "title": "AWS Account Setup"
        }, 
        {
            "location": "/00-environment-setup/#terraform-installation", 
            "text": "", 
            "title": "Terraform Installation"
        }, 
        {
            "location": "/00-environment-setup/#ubuntu", 
            "text": "Follow the following steps to install Terraform on ubuntu.  wget https://releases.hashicorp.com/terraform/0.11.8/terraform_0.11.8_linux_amd64.zip\nunzip terraform_0.11.8_linux_amd64.zip\nsudo mv terraform /usr/local/bin\nsudo chmod +x /usr/local/bin/terraform", 
            "title": "Ubuntu"
        }, 
        {
            "location": "/00-environment-setup/#windows", 
            "text": "Visit the following link to download the Terraform executable.  Terraform for Windows .  Extract the file.   Copy the extracted file.   Create a new directory called  Terrafrom  insice  C:\\Program Files\\   Paste the file we have copied in the previous step.   Copy the file path for the executable.  Search for  environment  from your start menu.  Then select environment variables form the window.  Select Path variable and edit it.  Add the path that we have copied earlier.", 
            "title": "Windows"
        }, 
        {
            "location": "/00-environment-setup/#macos", 
            "text": "wget https://releases.hashicorp.com/terraform/0.11.8/terraform_0.11.8_darwin_amd64.zip\nunzip terraform_0.11.8_darwin_amd64.zip\nsudo mv terraform /usr/local/bin\nsudo chmod +x /usr/local/bin/terraform", 
            "title": "MacOS"
        }, 
        {
            "location": "/00-environment-setup/#validate-the-installation", 
            "text": "Open a Shell session and run  terraform -v . This should produce the following output.  terraform -v\n\n[output]\nTerraform v0.11.7", 
            "title": "Validate the Installation"
        }, 
        {
            "location": "/02-terraform-important-commands/", 
            "text": "Important Terraform Commands\n\n\nTerraform Plan\n\n\nWhen you run \nterraform plan\n it will present you with the \nexecution plan\n. This will show you which resources are going to be created/deleted or modified. This is more like a dry run, if you want to see what your code will do before you apply it. \n\n\nExample\n  \n\n\nterrform plan \n\n[output]\n Acquiring state lock. This may take a few moments...\nRefreshing Terraform state in-memory prior to plan...\nThe refreshed state will be used to calculate this plan, but will not be\npersisted to local or remote state storage.\n\naws_security_group.webserver_sg: Refreshing state... (ID: sg-04b81bcdfa7f287b0)\naws_key_pair.webserver_key: Refreshing state... (ID: web-admin-key)\naws_instance.webserver: Refreshing state... (ID: i-00ddea272445bd4ec)\n\n------------------------------------------------------------------------\n\nAn execution plan has been generated and is shown below.\nResource actions are indicated with the following symbols:\n-/+ destroy and then create replacement\n\nTerraform will perform the following actions:\n\n-/+ aws_instance.webserver (tainted) (new resource required)\n      id:                                \ni-00ddea272445bd4ec\n =\n \ncomputed\n (forces new resource)\n      ami:                               \nami-408c7f28\n =\n \nami-408c7f28\n\n      arn:                               \narn:aws:ec2:us-east-1:822941572458:instance/i-00ddea272445bd4ec\n =\n \ncomputed\n\n      associate_public_ip_address:       \ntrue\n =\n \ncomputed\n\n      availability_zone:                 \nus-east-1a\n =\n \ncomputed\n\n      cpu_core_count:                    \n1\n =\n \ncomputed\n\n      cpu_threads_per_core:              \n1\n =\n \ncomputed\n\n      ebs_block_device.#:                \n0\n =\n \ncomputed\n\n      ephemeral_block_device.#:          \n0\n =\n \ncomputed\n\n      get_password_data:                 \nfalse\n =\n \nfalse\n\n      instance_state:                    \nrunning\n =\n \ncomputed\n\n      instance_type:                     \nt1.micro\n =\n \nt1.micro\n\n      ipv6_address_count:                \n =\n \ncomputed\n\n      ipv6_addresses.#:                  \n0\n =\n \ncomputed\n\n      key_name:                          \nweb-admin-key\n =\n \nweb-admin-key\n\n      network_interface.#:               \n0\n =\n \ncomputed\n\n      network_interface_id:              \neni-0e92356540e1a2f47\n =\n \ncomputed\n\n      password_data:                     \n =\n \ncomputed\n\n      placement_group:                   \n =\n \ncomputed\n\n      primary_network_interface_id:      \neni-0e92356540e1a2f47\n =\n \ncomputed\n\n      private_dns:                       \nip-172-31-38-119.ec2.internal\n =\n \ncomputed\n\n      private_ip:                        \n172.31.38.119\n =\n \ncomputed\n\n      public_dns:                        \nec2-35-173-130-100.compute-1.amazonaws.com\n =\n \ncomputed\n\n      public_ip:                         \n35.173.130.100\n =\n \ncomputed\n\n      root_block_device.#:               \n1\n =\n \ncomputed\n\n      security_groups.#:                 \n1\n =\n \ncomputed\n\n      source_dest_check:                 \ntrue\n =\n \ntrue\n\n      subnet_id:                         \nsubnet-d363e58f\n =\n \ncomputed\n\n      tags.%:                            \n1\n =\n \n1\n\n      tags.Name:                         \ndemo-server\n =\n \ndemo-server\n\n      tenancy:                           \ndefault\n =\n \ncomputed\n\n      volume_tags.%:                     \n0\n =\n \ncomputed\n\n      vpc_security_group_ids.#:          \n1\n =\n \n1\n\n      vpc_security_group_ids.3215502186: \nsg-04b81bcdfa7f287b0\n =\n \nsg-04b81bcdfa7f287b0\n\n\n\nPlan: 1 to add, 0 to change, 1 to destroy.\n\n------------------------------------------------------------------------\n\nNote: You didn't specify an \n-out\n parameter to save this plan, so Terraform\ncan't guarantee that exactly these actions will be performed if\n\nterraform apply\n is subsequently run.\n\nReleasing state lock. This may take a few moments...\n\n\n\n\n\nTerraform Apply\n\n\nTerraform apply is command which creates the resources for us. The output will look similar to \nterraform plan\n but this time you will be prompted for permisson on your console. The output is truncated from the original.\n\n\nExample\n\n\naws_security_group.webserver_sg: Refreshing state... (ID: sg-04b81bcdfa7f287b0)\naws_key_pair.webserver_key: Refreshing state... (ID: web-admin-key)\naws_instance.webserver: Refreshing state... (ID: i-00ddea272445bd4ec)\n\nAn execution plan has been generated and is shown below.\nResource actions are indicated with the following symbols:\n-/+ destroy and then create replacement\n\nTerraform will perform the following actions:\n\n-/+ aws_instance.webserver (tainted) (new resource required)\n      id:                                \ni-00ddea272445bd4ec\n =\n \ncomputed\n (forces new resource)\n      ami:                               \nami-408c7f28\n =\n \nami-408c7f28\n\n      arn:                               \narn:aws:ec2:us-east-1:822941572458:instance/\n      [...]\n      volume_tags.%:                     \n0\n =\n \ncomputed\n\n      vpc_security_group_ids.#:          \n1\n =\n \n1\n\n      vpc_security_group_ids.3215502186: \nsg-04b81bcdfa7f287b0\n =\n \nsg-04b81bcdfa7f287b0\n\n\n\nPlan: 1 to add, 0 to change, 1 to destroy.\n\nDo you want to perform these actions?\n  Terraform will perform the actions described above.\n  Only 'yes' will be accepted to approve.\n\n  Enter a value: yes\n\naws_instance.webserver: Destroying... (ID: i-00ddea272445bd4ec)\naws_instance.webserver: Destruction complete after 49s\n[...]\n\n\n\n\nTerraform Destroy\n\n\nThis command will delete everything that terraform manages for you. So we need to be really careful when we run this command and only run it when you know what you are doing. \n\n\nExample\n\n\nterraform destroy\n\n[output]\nAcquiring state lock. This may take a few moments...\naws_security_group.webserver_sg: Refreshing state... (ID: sg-04b81bcdfa7f287b0)\naws_key_pair.webserver_key: Refreshing state... (ID: web-admin-key)\naws_instance.webserver: Refreshing state... (ID: i-04264d266661e096d)\n\nAn execution plan has been generated and is shown below.\nResource actions are indicated with the following symbols:\n  - destroy\n\nTerraform will perform the following actions:\n\n  - aws_instance.webserver\n\n  - aws_key_pair.webserver_key\n\n  - aws_security_group.webserver_sg\n\n\nPlan: 0 to add, 0 to change, 3 to destroy.\n\nDo you really want to destroy?\n  Terraform will destroy all your managed infrastructure, as shown above.\n  There is no undo. Only 'yes' will be accepted to confirm.\n\n  Enter a value: yes\n  [...]\n\n\n\n\nTerraform init\n\n\nThe terraform init command is used to initialize a working directory containing Terraform configuration files. This is the first command that should be run after writing a new Terraform configuration or cloning an existing one from version control. It is safe to run this command multiple times.\n\n\nExample\n\n\nterraform init\n\n[Output]\n\nInitializing provider plugins...\n- Checking for available provider plugins on https://releases.hashicorp.com...\n- Downloading plugin for provider \naws\n (1.37.0)...\n\nThe following providers do not have any version constraints in configuration,\nso the latest version was installed.\n\nTo prevent automatic upgrades to new major versions that may contain breaking\nchanges, it is recommended to add version = \n...\n constraints to the\ncorresponding provider blocks in configuration, with the constraint strings\nsuggested below.\n\n* provider.aws: version = \n~\n 1.37\n\nTerraform has been successfully initialized!\n\nYou may now begin working with Terraform. Try running \nterraform plan\n to see\nany changes that are required for your infrastructure. All Terraform commands\nshould now work.\n\nIf you ever set or change modules or backend configuration for Terraform,\nrerun this command to reinitialize your working directory. If you forget, other\ncommands will detect it and remind you to do so if necessary.\n\n\n\n\n\nTerraform fmt\n\n\nThe terraform fmt command is used to rewrite Terraform configuration files to a canonical format and style.", 
            "title": "Important Commands"
        }, 
        {
            "location": "/02-terraform-important-commands/#important-terraform-commands", 
            "text": "", 
            "title": "Important Terraform Commands"
        }, 
        {
            "location": "/02-terraform-important-commands/#terraform-plan", 
            "text": "When you run  terraform plan  it will present you with the  execution plan . This will show you which resources are going to be created/deleted or modified. This is more like a dry run, if you want to see what your code will do before you apply it.   Example     terrform plan \n\n[output]\n Acquiring state lock. This may take a few moments...\nRefreshing Terraform state in-memory prior to plan...\nThe refreshed state will be used to calculate this plan, but will not be\npersisted to local or remote state storage.\n\naws_security_group.webserver_sg: Refreshing state... (ID: sg-04b81bcdfa7f287b0)\naws_key_pair.webserver_key: Refreshing state... (ID: web-admin-key)\naws_instance.webserver: Refreshing state... (ID: i-00ddea272445bd4ec)\n\n------------------------------------------------------------------------\n\nAn execution plan has been generated and is shown below.\nResource actions are indicated with the following symbols:\n-/+ destroy and then create replacement\n\nTerraform will perform the following actions:\n\n-/+ aws_instance.webserver (tainted) (new resource required)\n      id:                                 i-00ddea272445bd4ec  =   computed  (forces new resource)\n      ami:                                ami-408c7f28  =   ami-408c7f28 \n      arn:                                arn:aws:ec2:us-east-1:822941572458:instance/i-00ddea272445bd4ec  =   computed \n      associate_public_ip_address:        true  =   computed \n      availability_zone:                  us-east-1a  =   computed \n      cpu_core_count:                     1  =   computed \n      cpu_threads_per_core:               1  =   computed \n      ebs_block_device.#:                 0  =   computed \n      ephemeral_block_device.#:           0  =   computed \n      get_password_data:                  false  =   false \n      instance_state:                     running  =   computed \n      instance_type:                      t1.micro  =   t1.micro \n      ipv6_address_count:                  =   computed \n      ipv6_addresses.#:                   0  =   computed \n      key_name:                           web-admin-key  =   web-admin-key \n      network_interface.#:                0  =   computed \n      network_interface_id:               eni-0e92356540e1a2f47  =   computed \n      password_data:                       =   computed \n      placement_group:                     =   computed \n      primary_network_interface_id:       eni-0e92356540e1a2f47  =   computed \n      private_dns:                        ip-172-31-38-119.ec2.internal  =   computed \n      private_ip:                         172.31.38.119  =   computed \n      public_dns:                         ec2-35-173-130-100.compute-1.amazonaws.com  =   computed \n      public_ip:                          35.173.130.100  =   computed \n      root_block_device.#:                1  =   computed \n      security_groups.#:                  1  =   computed \n      source_dest_check:                  true  =   true \n      subnet_id:                          subnet-d363e58f  =   computed \n      tags.%:                             1  =   1 \n      tags.Name:                          demo-server  =   demo-server \n      tenancy:                            default  =   computed \n      volume_tags.%:                      0  =   computed \n      vpc_security_group_ids.#:           1  =   1 \n      vpc_security_group_ids.3215502186:  sg-04b81bcdfa7f287b0  =   sg-04b81bcdfa7f287b0 \n\n\nPlan: 1 to add, 0 to change, 1 to destroy.\n\n------------------------------------------------------------------------\n\nNote: You didn't specify an  -out  parameter to save this plan, so Terraform\ncan't guarantee that exactly these actions will be performed if terraform apply  is subsequently run.\n\nReleasing state lock. This may take a few moments...", 
            "title": "Terraform Plan"
        }, 
        {
            "location": "/02-terraform-important-commands/#terraform-apply", 
            "text": "Terraform apply is command which creates the resources for us. The output will look similar to  terraform plan  but this time you will be prompted for permisson on your console. The output is truncated from the original.  Example  aws_security_group.webserver_sg: Refreshing state... (ID: sg-04b81bcdfa7f287b0)\naws_key_pair.webserver_key: Refreshing state... (ID: web-admin-key)\naws_instance.webserver: Refreshing state... (ID: i-00ddea272445bd4ec)\n\nAn execution plan has been generated and is shown below.\nResource actions are indicated with the following symbols:\n-/+ destroy and then create replacement\n\nTerraform will perform the following actions:\n\n-/+ aws_instance.webserver (tainted) (new resource required)\n      id:                                 i-00ddea272445bd4ec  =   computed  (forces new resource)\n      ami:                                ami-408c7f28  =   ami-408c7f28 \n      arn:                                arn:aws:ec2:us-east-1:822941572458:instance/\n      [...]\n      volume_tags.%:                      0  =   computed \n      vpc_security_group_ids.#:           1  =   1 \n      vpc_security_group_ids.3215502186:  sg-04b81bcdfa7f287b0  =   sg-04b81bcdfa7f287b0 \n\n\nPlan: 1 to add, 0 to change, 1 to destroy.\n\nDo you want to perform these actions?\n  Terraform will perform the actions described above.\n  Only 'yes' will be accepted to approve.\n\n  Enter a value: yes\n\naws_instance.webserver: Destroying... (ID: i-00ddea272445bd4ec)\naws_instance.webserver: Destruction complete after 49s\n[...]", 
            "title": "Terraform Apply"
        }, 
        {
            "location": "/02-terraform-important-commands/#terraform-destroy", 
            "text": "This command will delete everything that terraform manages for you. So we need to be really careful when we run this command and only run it when you know what you are doing.   Example  terraform destroy\n\n[output]\nAcquiring state lock. This may take a few moments...\naws_security_group.webserver_sg: Refreshing state... (ID: sg-04b81bcdfa7f287b0)\naws_key_pair.webserver_key: Refreshing state... (ID: web-admin-key)\naws_instance.webserver: Refreshing state... (ID: i-04264d266661e096d)\n\nAn execution plan has been generated and is shown below.\nResource actions are indicated with the following symbols:\n  - destroy\n\nTerraform will perform the following actions:\n\n  - aws_instance.webserver\n\n  - aws_key_pair.webserver_key\n\n  - aws_security_group.webserver_sg\n\n\nPlan: 0 to add, 0 to change, 3 to destroy.\n\nDo you really want to destroy?\n  Terraform will destroy all your managed infrastructure, as shown above.\n  There is no undo. Only 'yes' will be accepted to confirm.\n\n  Enter a value: yes\n  [...]", 
            "title": "Terraform Destroy"
        }, 
        {
            "location": "/02-terraform-important-commands/#terraform-init", 
            "text": "The terraform init command is used to initialize a working directory containing Terraform configuration files. This is the first command that should be run after writing a new Terraform configuration or cloning an existing one from version control. It is safe to run this command multiple times.  Example  terraform init\n\n[Output]\n\nInitializing provider plugins...\n- Checking for available provider plugins on https://releases.hashicorp.com...\n- Downloading plugin for provider  aws  (1.37.0)...\n\nThe following providers do not have any version constraints in configuration,\nso the latest version was installed.\n\nTo prevent automatic upgrades to new major versions that may contain breaking\nchanges, it is recommended to add version =  ...  constraints to the\ncorresponding provider blocks in configuration, with the constraint strings\nsuggested below.\n\n* provider.aws: version =  ~  1.37 \nTerraform has been successfully initialized!\n\nYou may now begin working with Terraform. Try running  terraform plan  to see\nany changes that are required for your infrastructure. All Terraform commands\nshould now work.\n\nIf you ever set or change modules or backend configuration for Terraform,\nrerun this command to reinitialize your working directory. If you forget, other\ncommands will detect it and remind you to do so if necessary.", 
            "title": "Terraform init"
        }, 
        {
            "location": "/02-terraform-important-commands/#terraform-fmt", 
            "text": "The terraform fmt command is used to rewrite Terraform configuration files to a canonical format and style.", 
            "title": "Terraform fmt"
        }, 
        {
            "location": "/03-providers/", 
            "text": "Providers\n\n\nIn Terraform, Providers are responsible for understanding API interactions from IaaS(AWS, Azure, etc.,), PaaS(Heroku) or SaaS(CloudFlare, DNSSimple, DNSMadeEasy, etc.,). \n\n\nExample Provider\n\n\nLet's look at AWS Provider as an example.\n\n\nprovider \naws\n {\n  access_key = \n${var.aws_access_key}\n\n  secret_key = \n${var.aws_secret_key}\n\n  region     = \nus-east-1\n\n}\n\n\n\n\nAs seen in the above given example, Provider is a way to instruct Terraform to interact with AWS API. Every provider needs some kind of credentials to get authenticated with the API. In our example, we have porvided AWS access key and secret key to perform the same. \n\n\nSetting up our environment for AWS\n\n\nLet us set up our environment by creating a directory called \naws\n.\n\n\nmkdir aws\ncd aws\n\n\n\n\nAfter changing directory into \naws\n, we need to create a file named \nmain.tf\n.\n\n\ntouch main.tf\n\n\n\n\nDefine your Provider details in this main manifest. Change the region if you want to create the resources elsewhere.\n\n\nprovider \naws\n {\n  region = \nus-east-1\n\n}\n\n\n\n\nExport your AWS access and secret keys as environment variables.\n\n\nexport AWS_ACCESS_KEY_ID=\nAccess-Key\n\nexport AWS_SECRET_ACCESS_KEY=\nSecret-Key\n\n\n\n\n\nFinally run the following command to initialize your environment.\n\n\nterraform init\n\n[output]\nInitializing provider plugins...\n- Checking for available provider plugins on https://releases.hashicorp.com...\n- Downloading plugin for provider \naws\n (1.37.0)...\n\nThe following providers do not have any version constraints in configuration,\nso the latest version was installed.\n\nTo prevent automatic upgrades to new major versions that may contain breaking\nchanges, it is recommended to add version = \n...\n constraints to the\ncorresponding provider blocks in configuration, with the constraint strings\nsuggested below.\n\n* provider.aws: version = \n~\n 1.37\n\n\nTerraform has been successfully initialized!\n\nYou may now begin working with Terraform. Try running \nterraform plan\n to see\nany changes that are required for your infrastructure. All Terraform commands\nshould now work.\n\nIf you ever set or change modules or backend configuration for Terraform,\nrerun this command to reinitialize your working directory. If you forget, other\ncommands will detect it and remind you to do so if necessary.\n\n\n\n\nThis should initialize the environment for our course.\n\n\nReference\n\n\nIf you want to learn more about providers, you can visit \nthis link\n.", 
            "title": "Terraform Providers"
        }, 
        {
            "location": "/03-providers/#providers", 
            "text": "In Terraform, Providers are responsible for understanding API interactions from IaaS(AWS, Azure, etc.,), PaaS(Heroku) or SaaS(CloudFlare, DNSSimple, DNSMadeEasy, etc.,).", 
            "title": "Providers"
        }, 
        {
            "location": "/03-providers/#example-provider", 
            "text": "Let's look at AWS Provider as an example.  provider  aws  {\n  access_key =  ${var.aws_access_key} \n  secret_key =  ${var.aws_secret_key} \n  region     =  us-east-1 \n}  As seen in the above given example, Provider is a way to instruct Terraform to interact with AWS API. Every provider needs some kind of credentials to get authenticated with the API. In our example, we have porvided AWS access key and secret key to perform the same.", 
            "title": "Example Provider"
        }, 
        {
            "location": "/03-providers/#setting-up-our-environment-for-aws", 
            "text": "Let us set up our environment by creating a directory called  aws .  mkdir aws\ncd aws  After changing directory into  aws , we need to create a file named  main.tf .  touch main.tf  Define your Provider details in this main manifest. Change the region if you want to create the resources elsewhere.  provider  aws  {\n  region =  us-east-1 \n}  Export your AWS access and secret keys as environment variables.  export AWS_ACCESS_KEY_ID= Access-Key \nexport AWS_SECRET_ACCESS_KEY= Secret-Key   Finally run the following command to initialize your environment.  terraform init\n\n[output]\nInitializing provider plugins...\n- Checking for available provider plugins on https://releases.hashicorp.com...\n- Downloading plugin for provider  aws  (1.37.0)...\n\nThe following providers do not have any version constraints in configuration,\nso the latest version was installed.\n\nTo prevent automatic upgrades to new major versions that may contain breaking\nchanges, it is recommended to add version =  ...  constraints to the\ncorresponding provider blocks in configuration, with the constraint strings\nsuggested below.\n\n* provider.aws: version =  ~  1.37 \n\nTerraform has been successfully initialized!\n\nYou may now begin working with Terraform. Try running  terraform plan  to see\nany changes that are required for your infrastructure. All Terraform commands\nshould now work.\n\nIf you ever set or change modules or backend configuration for Terraform,\nrerun this command to reinitialize your working directory. If you forget, other\ncommands will detect it and remind you to do so if necessary.  This should initialize the environment for our course.", 
            "title": "Setting up our environment for AWS"
        }, 
        {
            "location": "/03-providers/#reference", 
            "text": "If you want to learn more about providers, you can visit  this link .", 
            "title": "Reference"
        }, 
        {
            "location": "/04-resources/", 
            "text": "Resources\n\n\nResources are the building block in Terraform. These the actual cloud entities that you are either creating/deleting or modifying. To do so, you will have to define them in a terraform manifest and apply them. \n\n\nCreating our first Resource\n\n\nLet us create an EC2 instance, which is going to be our first resource on AWS using Terraform. \n\n\nEvery resorce has the following syntax.\n\n\nresource syntax\n\n\nresource \nresource_type\n \nresource_name\n {\n  config1 = value1\n  config2 = value2\n}\n\n\n\n\nHere, \n  resource_type = The type of the resouce that we create/delete/modfiy\n  resource_name = Give the resource a name for Terraform internal references.\n  config(1-n)   = The properties of the reosurce your manipulating.\n\n\nIn your main.tf, add this block next to your Provider definition. \n\n\nan ec2 resource\n\n\nresource \naws_instance\n \nfrontend\n {\n  ami           = \nami-0ac019f4fcb7cb7e6\n\n  instance_type = \nt2.micro\n\n}\n\n\n\n\nHere, to compare it with the syntax,\n```  resource_type = aws_instance\n     resource_name = frontend\n     config1       = ami\n     value1        = ami-0ac019f4fcb7cb7e6(ubuntu-14.04)\n     config2       = instance_type\n     value2        = t2.micro\n\n\nYour `main.tf` file should look like the following. \n\n\n\n\n\nprovider \"aws\" {\n  region = \"us-east-1\"\n}\n\n\nresource \"aws_instance\" \"frontend\" {\n  ami           = \"ami-0ac019f4fcb7cb7e6\"\n  instance_type = \"t2.micro\"\n}\n\n\n\n### Terraform Plan\n\nThen run `terraform plan` to see what will happen if we apply the manifest.\n\n\n\n\n\nterraform plan\n\n\n[output]\nRefreshing Terraform state in-memory prior to plan...\nThe refreshed state will be used to calculate this plan, but will not be\npersisted to local or remote state storage.\n\n\n\n\nAn execution plan has been generated and is shown below.\nResource actions are indicated with the following symbols:\n  + create\n\n\nTerraform will perform the following actions:\n\n\n\n\naws_instance.webserver\n      id:                           \n\n      ami:                          \"ami-0ac019f4fcb7cb7e6\"\n      arn:                          \n\n      associate_public_ip_address:  \n\n      availability_zone:            \n\n      cpu_core_count:               \n\n      cpu_threads_per_core:         \n\n      ebs_block_device.#:           \n\n      ephemeral_block_device.#:     \n\n      get_password_data:            \"false\"\n      instance_state:               \n\n      instance_type:                \"t2.micro\"\n[...]\n\n\n\n\nPlan: 1 to add, 0 to change, 0 to destroy.\n\n\n\n\nNote: You didn't specify an \"-out\" parameter to save this plan, so Terraform\ncan't guarantee that exactly these actions will be performed if\n\"terraform apply\" is subsequently run.\n\n\n\n### Terraform Apply\n\nThen run, `terraform apply` to actually create the resource on AWS.\n\n\n\n\n\nterraform apply\n\n\n[output]\n[...]\naws_instance.webserver: Still creating... (10s elapsed)\naws_instance.webserver: Still creating... (20s elapsed)\naws_instance.webserver: Still creating... (30s elapsed)\naws_instance.webserver: Still creating... (40s elapsed)\naws_instance.webserver: Creation complete after 49s (ID: i-02489cdf638f05bbd)\n\n\nApply complete! Resources: 1 added, 0 changed, 0 destroyed.\n\n\n\nWe have successfully created our first reosource on AWS. Please check your AWS console to check the properties(AMI and instance type) of the machine.\n\n![terraform apply](./images/04-resources-apply.png)\n\n## Resource Lifecycles  \n\nIn Terraform, a resource can be,  \n  * Created (+)  \n  * Destroyed (-)  \n  * Recreated (-/+) or  \n  * Updated (~)  \nLike in the previous example, when Terraform creates a resource, it represents it with `+` symbol. Similarly Destroy, Recreate and Modify are represented with `-`, `-/+` and `~` respectively.  \n\n### Resource Update  \nLet us see what happens when we apply a tag to the instance from `main.tf`.  \n`file: main.tf`\n\n\n\n\nprovider \"aws\" {\n  region = \"us-east-1\"\n}\n\n\nresource \"aws_instance\" \"frontend\" {\n  ami           = \"ami-0ac019f4fcb7cb7e6\"\n  instance_type = \"t2.micro\"\n\n\ntags {\n    Name       = \"tf-frontend-01\"\n    App        = \"devops-demo\"\n    Maintainer = \"Gourav Shah\"\n    Role =\"frontend\"\n  }\n}\n\n\nWe have added a tag block with in *aws_instance* resource which will add the name `instance-01` for our EC2 instance.\n\n\n\n\n\nterraform plan\nterraform apply\n\n\n[output]\nAcquiring state lock. This may take a few moments...\naws_instance.webserver: Refreshing state... (ID: i-0f6ab73cdd9d6882c)\n\n\nAn execution plan has been generated and is shown below.\nResource actions are indicated with the following symbols:\n  ~ update in-place\n\n\nTerraform will perform the following actions:\n\n\n~ aws_instance.webserver\n      tags.%:    \"0\" =\n \"1\"\n      tags.Name: \"\" =\n \"instance-01\"\n\n\nPlan: 0 to add, 1 to change, 0 to destroy.\n\n\nDo you want to perform these actions?\n  Terraform will perform the actions described above.\n  Only 'yes' will be accepted to approve.\n\n\nEnter a value: yes\n\n\naws_instance.webserver: Modifying... (ID: i-0f6ab73cdd9d6882c)\n  tags.%:    \"0\" =\n \"1\"\n  tags.Name: \"\" =\n \"instance-01\"\naws_instance.webserver: Still modifying... (ID: i-0f6ab73cdd9d6882c, 10s elapsed)\naws_instance.webserver: Modifications complete after 12s (ID: i-0f6ab73cdd9d6882c)\n\n\nApply complete! Resources: 0 added, 1 changed, 0 destroyed.\nReleasing state lock. This may take a few moments...\n\n\nThis did not recreate the instance, but just updated it. The instance still has the same internal and external IPs and other properties.\n\n### Resource Recreation  \nNow let us change the *ami* for the instance from *ami-408c7f28*(ubuntu 14.04) to *ami-0c11a0129f63fb571*(ubuntu 16.04).  \n\n`file: main.tf`\n\n\n\n\n\nprovider \"aws\" {\n  region = \"us-east-1\"\n}\n\n\nresource \"aws_instance\" \"frontend\" {\n  ami           = \"ami-0c11a0129f63fb571\"\n  instance_type = \"t2.micro\"\n\n\ntags {\n    Name       = \"tf-frontend-01\"\n    App        = \"devops-demo\"\n    Maintainer = \"Gourav Shah\"\n    Role =\"frontend\"\n  }\n}\n\n\n\nLet us plan and apply this manifest. \n\n\n\n\nterraform apply \n\n\n[output]\nAcquiring state lock. This may take a few moments...\naws_instance.webserver: Refreshing state... (ID: i-0f6ab73cdd9d6882c)\n\n\nAn execution plan has been generated and is shown below.\nResource actions are indicated with the following symbols:\n-/+ destroy and then create replacement\n\n\nTerraform will perform the following actions:\n\n\n-/+ aws_instance.webserver (new resource required)\n      id:                           \"i-0f6ab73cdd9d6882c\" =\n \n (forces new resource)\n      ami:                          \"ami-408c7f28\" =\n \"ami-0c11a0129f63fb571\" (forces new resource)\n      arn:                          \"arn:aws:ec2:us-east-1:822941572458:instance/i-0f6ab73cdd9d6882c\" =\n \n\n      associate_public_ip_address:  \"false\" =\n \n\n      availability_zone:            \"us-east-1a\" =\n \n\n      cpu_core_count:               \"1\" =\n \n\n      cpu_threads_per_core:         \"1\" =\n \n\n      ebs_block_device.#:           \"0\" =\n \n\n      ephemeral_block_device.#:     \"0\" =\n \n\n      get_password_data:            \"false\" =\n \"false\"\n      instance_state:               \"stopped\" =\n \n\n      instance_type:                \"t2.micro\" =\n \"t2.micro\"\n      ipv6_address_count:           \"\" =\n \n\n      ipv6_addresses.#:             \"0\" =\n \n\n      key_name:                     \"web-admin-key\" =\n \n\n      network_interface.#:          \"0\" =\n \n\n      network_interface_id:         \"eni-0c851ccf5348f539b\" =\n \n\n      password_data:                \"\" =\n \n\n      placement_group:              \"\" =\n \n\n      primary_network_interface_id: \"eni-0c851ccf5348f539b\" =\n \n\n      private_dns:                  \"ip-172-31-39-209.ec2.internal\" =\n \n\n      private_ip:                   \"172.31.39.209\" =\n \n\n      public_dns:                   \"\" =\n \n\n      public_ip:                    \"\" =\n \n\n      root_block_device.#:          \"1\" =\n \n\n      security_groups.#:            \"1\" =\n \n\n      source_dest_check:            \"true\" =\n \"true\"\n      subnet_id:                    \"subnet-d363e58f\" =\n \n\n      tags.%:                       \"1\" =\n \"1\"\n      tags.Name:                    \"instance-01\" =\n \"instance-01\"\n      tenancy:                      \"default\" =\n \n\n      volume_tags.%:                \"0\" =\n \n\n      vpc_security_group_ids.#:     \"1\" =\n \n\n\nPlan: 1 to add, 0 to change, 1 to destroy.\n\n\nDo you want to perform these actions?\n  Terraform will perform the actions described above.\n  Only 'yes' will be accepted to approve.\n\n\nEnter a value: yes\naws_instance.webserver: Destroying... (ID: i-0f6ab73cdd9d6882c)\naws_instance.webserver: Still destroying... (ID: i-0f6ab73cdd9d6882c, 10s elapsed)\naws_instance.webserver: Destruction complete after 13s\naws_instance.webserver: Creating...\naws_instance.webserver: Still creating... (10s elapsed)\naws_instance.webserver: Still creating... (20s elapsed)\naws_instance.webserver: Still creating... (30s elapsed)\naws_instance.webserver: Creation complete after 40s (ID: i-04aa34e873c5e4c63)\n\n\nIf we change `ami` attribute, it forces the instance to be recreated. \n\n### Resource Destruction  \nLet us see what happens when we run `terraform plan --destroy`\n\n\n\n\n\nterraform plan --destroy\n\n\n[output]\nAcquiring state lock. This may take a few moments...\nRefreshing Terraform state in-memory prior to plan...\nThe refreshed state will be used to calculate this plan, but will not be\npersisted to local or remote state storage.\n\n\naws_instance.webserver: Refreshing state... (ID: i-04aa34e873c5e4c63)\n\n\n\n\nAn execution plan has been generated and is shown below.\nResource actions are indicated with the following symbols:\n  - destroy\n\n\nTerraform will perform the following actions:\n\n\n\n\naws_instance.webserver\n\n\n\n\nPlan: 0 to add, 0 to change, 1 to destroy.\n\n\n\n\nNote: You didn't specify an \"-out\" parameter to save this plan, so Terraform\ncan't guarantee that exactly these actions will be performed if\n\"terraform apply\" is subsequently run.\n\n\nReleasing state lock. This may take a few moments...\n\n\nThis command will help you to see what will happen when you run `terraform destroy`. \n\n\n\n\n\nterraform destroy\n\n\n[output]\nAcquiring state lock. This may take a few moments...\naws_instance.webserver: Refreshing state... (ID: i-04aa34e873c5e4c63)\n\n\nAn execution plan has been generated and is shown below.\nResource actions are indicated with the following symbols:\n  - destroy\n\n\nTerraform will perform the following actions:\n\n\n\n\naws_instance.webserver\n\n\n\n\nPlan: 0 to add, 0 to change, 1 to destroy.\n\n\nDo you really want to destroy?\n  Terraform will destroy all your managed infrastructure, as shown above.\n  There is no undo. Only 'yes' will be accepted to confirm.\n\n\nEnter a value: yes\n\n\naws_instance.webserver: Destroying... (ID: i-04aa34e873c5e4c63)\naws_instance.webserver: Still destroying... (ID: i-04aa34e873c5e4c63, 10s elapsed)\naws_instance.webserver: Still destroying... (ID: i-04aa34e873c5e4c63, 20s elapsed)\naws_instance.webserver: Still destroying... (ID: i-04aa34e873c5e4c63, 30s elapsed)\naws_instance.webserver: Still destroying... (ID: i-04aa34e873c5e4c63, 40s elapsed)\naws_instance.webserver: Still destroying... (ID: i-04aa34e873c5e4c63, 50s elapsed)\naws_instance.webserver: Still destroying... (ID: i-04aa34e873c5e4c63, 1m0s elapsed)\naws_instance.webserver: Destruction complete after 1m0s\n\n\nDestroy complete! Resources: 1 destroyed.\nReleasing state lock. This may take a few moments...\n```\n\n\nReference\n\n\nIf you need further details about resources, please visit this \nlink", 
            "title": "Resources"
        }, 
        {
            "location": "/04-resources/#resources", 
            "text": "Resources are the building block in Terraform. These the actual cloud entities that you are either creating/deleting or modifying. To do so, you will have to define them in a terraform manifest and apply them.", 
            "title": "Resources"
        }, 
        {
            "location": "/04-resources/#creating-our-first-resource", 
            "text": "Let us create an EC2 instance, which is going to be our first resource on AWS using Terraform.   Every resorce has the following syntax.  resource syntax  resource  resource_type   resource_name  {\n  config1 = value1\n  config2 = value2\n}  Here, \n  resource_type = The type of the resouce that we create/delete/modfiy\n  resource_name = Give the resource a name for Terraform internal references.\n  config(1-n)   = The properties of the reosurce your manipulating.  In your main.tf, add this block next to your Provider definition.   an ec2 resource  resource  aws_instance   frontend  {\n  ami           =  ami-0ac019f4fcb7cb7e6 \n  instance_type =  t2.micro \n}  Here, to compare it with the syntax,\n```  resource_type = aws_instance\n     resource_name = frontend\n     config1       = ami\n     value1        = ami-0ac019f4fcb7cb7e6(ubuntu-14.04)\n     config2       = instance_type\n     value2        = t2.micro  Your `main.tf` file should look like the following.   provider \"aws\" {\n  region = \"us-east-1\"\n}  resource \"aws_instance\" \"frontend\" {\n  ami           = \"ami-0ac019f4fcb7cb7e6\"\n  instance_type = \"t2.micro\"\n}  \n### Terraform Plan\n\nThen run `terraform plan` to see what will happen if we apply the manifest.  terraform plan  [output]\nRefreshing Terraform state in-memory prior to plan...\nThe refreshed state will be used to calculate this plan, but will not be\npersisted to local or remote state storage.   An execution plan has been generated and is shown below.\nResource actions are indicated with the following symbols:\n  + create  Terraform will perform the following actions:   aws_instance.webserver\n      id:                            \n      ami:                          \"ami-0ac019f4fcb7cb7e6\"\n      arn:                           \n      associate_public_ip_address:   \n      availability_zone:             \n      cpu_core_count:                \n      cpu_threads_per_core:          \n      ebs_block_device.#:            \n      ephemeral_block_device.#:      \n      get_password_data:            \"false\"\n      instance_state:                \n      instance_type:                \"t2.micro\"\n[...]   Plan: 1 to add, 0 to change, 0 to destroy.   Note: You didn't specify an \"-out\" parameter to save this plan, so Terraform\ncan't guarantee that exactly these actions will be performed if\n\"terraform apply\" is subsequently run.  \n### Terraform Apply\n\nThen run, `terraform apply` to actually create the resource on AWS.  terraform apply  [output]\n[...]\naws_instance.webserver: Still creating... (10s elapsed)\naws_instance.webserver: Still creating... (20s elapsed)\naws_instance.webserver: Still creating... (30s elapsed)\naws_instance.webserver: Still creating... (40s elapsed)\naws_instance.webserver: Creation complete after 49s (ID: i-02489cdf638f05bbd)  Apply complete! Resources: 1 added, 0 changed, 0 destroyed.  \nWe have successfully created our first reosource on AWS. Please check your AWS console to check the properties(AMI and instance type) of the machine.\n\n![terraform apply](./images/04-resources-apply.png)\n\n## Resource Lifecycles  \n\nIn Terraform, a resource can be,  \n  * Created (+)  \n  * Destroyed (-)  \n  * Recreated (-/+) or  \n  * Updated (~)  \nLike in the previous example, when Terraform creates a resource, it represents it with `+` symbol. Similarly Destroy, Recreate and Modify are represented with `-`, `-/+` and `~` respectively.  \n\n### Resource Update  \nLet us see what happens when we apply a tag to the instance from `main.tf`.  \n`file: main.tf`  provider \"aws\" {\n  region = \"us-east-1\"\n}  resource \"aws_instance\" \"frontend\" {\n  ami           = \"ami-0ac019f4fcb7cb7e6\"\n  instance_type = \"t2.micro\"  tags {\n    Name       = \"tf-frontend-01\"\n    App        = \"devops-demo\"\n    Maintainer = \"Gourav Shah\"\n    Role =\"frontend\"\n  }\n}  We have added a tag block with in *aws_instance* resource which will add the name `instance-01` for our EC2 instance.  terraform plan\nterraform apply  [output]\nAcquiring state lock. This may take a few moments...\naws_instance.webserver: Refreshing state... (ID: i-0f6ab73cdd9d6882c)  An execution plan has been generated and is shown below.\nResource actions are indicated with the following symbols:\n  ~ update in-place  Terraform will perform the following actions:  ~ aws_instance.webserver\n      tags.%:    \"0\" =  \"1\"\n      tags.Name: \"\" =  \"instance-01\"  Plan: 0 to add, 1 to change, 0 to destroy.  Do you want to perform these actions?\n  Terraform will perform the actions described above.\n  Only 'yes' will be accepted to approve.  Enter a value: yes  aws_instance.webserver: Modifying... (ID: i-0f6ab73cdd9d6882c)\n  tags.%:    \"0\" =  \"1\"\n  tags.Name: \"\" =  \"instance-01\"\naws_instance.webserver: Still modifying... (ID: i-0f6ab73cdd9d6882c, 10s elapsed)\naws_instance.webserver: Modifications complete after 12s (ID: i-0f6ab73cdd9d6882c)  Apply complete! Resources: 0 added, 1 changed, 0 destroyed.\nReleasing state lock. This may take a few moments...  This did not recreate the instance, but just updated it. The instance still has the same internal and external IPs and other properties.\n\n### Resource Recreation  \nNow let us change the *ami* for the instance from *ami-408c7f28*(ubuntu 14.04) to *ami-0c11a0129f63fb571*(ubuntu 16.04).  \n\n`file: main.tf`  provider \"aws\" {\n  region = \"us-east-1\"\n}  resource \"aws_instance\" \"frontend\" {\n  ami           = \"ami-0c11a0129f63fb571\"\n  instance_type = \"t2.micro\"  tags {\n    Name       = \"tf-frontend-01\"\n    App        = \"devops-demo\"\n    Maintainer = \"Gourav Shah\"\n    Role =\"frontend\"\n  }\n}  \nLet us plan and apply this manifest.   terraform apply   [output]\nAcquiring state lock. This may take a few moments...\naws_instance.webserver: Refreshing state... (ID: i-0f6ab73cdd9d6882c)  An execution plan has been generated and is shown below.\nResource actions are indicated with the following symbols:\n-/+ destroy and then create replacement  Terraform will perform the following actions:  -/+ aws_instance.webserver (new resource required)\n      id:                           \"i-0f6ab73cdd9d6882c\" =    (forces new resource)\n      ami:                          \"ami-408c7f28\" =  \"ami-0c11a0129f63fb571\" (forces new resource)\n      arn:                          \"arn:aws:ec2:us-east-1:822941572458:instance/i-0f6ab73cdd9d6882c\" =   \n      associate_public_ip_address:  \"false\" =   \n      availability_zone:            \"us-east-1a\" =   \n      cpu_core_count:               \"1\" =   \n      cpu_threads_per_core:         \"1\" =   \n      ebs_block_device.#:           \"0\" =   \n      ephemeral_block_device.#:     \"0\" =   \n      get_password_data:            \"false\" =  \"false\"\n      instance_state:               \"stopped\" =   \n      instance_type:                \"t2.micro\" =  \"t2.micro\"\n      ipv6_address_count:           \"\" =   \n      ipv6_addresses.#:             \"0\" =   \n      key_name:                     \"web-admin-key\" =   \n      network_interface.#:          \"0\" =   \n      network_interface_id:         \"eni-0c851ccf5348f539b\" =   \n      password_data:                \"\" =   \n      placement_group:              \"\" =   \n      primary_network_interface_id: \"eni-0c851ccf5348f539b\" =   \n      private_dns:                  \"ip-172-31-39-209.ec2.internal\" =   \n      private_ip:                   \"172.31.39.209\" =   \n      public_dns:                   \"\" =   \n      public_ip:                    \"\" =   \n      root_block_device.#:          \"1\" =   \n      security_groups.#:            \"1\" =   \n      source_dest_check:            \"true\" =  \"true\"\n      subnet_id:                    \"subnet-d363e58f\" =   \n      tags.%:                       \"1\" =  \"1\"\n      tags.Name:                    \"instance-01\" =  \"instance-01\"\n      tenancy:                      \"default\" =   \n      volume_tags.%:                \"0\" =   \n      vpc_security_group_ids.#:     \"1\" =    Plan: 1 to add, 0 to change, 1 to destroy.  Do you want to perform these actions?\n  Terraform will perform the actions described above.\n  Only 'yes' will be accepted to approve.  Enter a value: yes\naws_instance.webserver: Destroying... (ID: i-0f6ab73cdd9d6882c)\naws_instance.webserver: Still destroying... (ID: i-0f6ab73cdd9d6882c, 10s elapsed)\naws_instance.webserver: Destruction complete after 13s\naws_instance.webserver: Creating...\naws_instance.webserver: Still creating... (10s elapsed)\naws_instance.webserver: Still creating... (20s elapsed)\naws_instance.webserver: Still creating... (30s elapsed)\naws_instance.webserver: Creation complete after 40s (ID: i-04aa34e873c5e4c63)  If we change `ami` attribute, it forces the instance to be recreated. \n\n### Resource Destruction  \nLet us see what happens when we run `terraform plan --destroy`  terraform plan --destroy  [output]\nAcquiring state lock. This may take a few moments...\nRefreshing Terraform state in-memory prior to plan...\nThe refreshed state will be used to calculate this plan, but will not be\npersisted to local or remote state storage.  aws_instance.webserver: Refreshing state... (ID: i-04aa34e873c5e4c63)   An execution plan has been generated and is shown below.\nResource actions are indicated with the following symbols:\n  - destroy  Terraform will perform the following actions:   aws_instance.webserver   Plan: 0 to add, 0 to change, 1 to destroy.   Note: You didn't specify an \"-out\" parameter to save this plan, so Terraform\ncan't guarantee that exactly these actions will be performed if\n\"terraform apply\" is subsequently run.  Releasing state lock. This may take a few moments...  This command will help you to see what will happen when you run `terraform destroy`.   terraform destroy  [output]\nAcquiring state lock. This may take a few moments...\naws_instance.webserver: Refreshing state... (ID: i-04aa34e873c5e4c63)  An execution plan has been generated and is shown below.\nResource actions are indicated with the following symbols:\n  - destroy  Terraform will perform the following actions:   aws_instance.webserver   Plan: 0 to add, 0 to change, 1 to destroy.  Do you really want to destroy?\n  Terraform will destroy all your managed infrastructure, as shown above.\n  There is no undo. Only 'yes' will be accepted to confirm.  Enter a value: yes  aws_instance.webserver: Destroying... (ID: i-04aa34e873c5e4c63)\naws_instance.webserver: Still destroying... (ID: i-04aa34e873c5e4c63, 10s elapsed)\naws_instance.webserver: Still destroying... (ID: i-04aa34e873c5e4c63, 20s elapsed)\naws_instance.webserver: Still destroying... (ID: i-04aa34e873c5e4c63, 30s elapsed)\naws_instance.webserver: Still destroying... (ID: i-04aa34e873c5e4c63, 40s elapsed)\naws_instance.webserver: Still destroying... (ID: i-04aa34e873c5e4c63, 50s elapsed)\naws_instance.webserver: Still destroying... (ID: i-04aa34e873c5e4c63, 1m0s elapsed)\naws_instance.webserver: Destruction complete after 1m0s  Destroy complete! Resources: 1 destroyed.\nReleasing state lock. This may take a few moments...\n```", 
            "title": "Creating our first Resource"
        }, 
        {
            "location": "/04-resources/#reference", 
            "text": "If you need further details about resources, please visit this  link", 
            "title": "Reference"
        }, 
        {
            "location": "/05-resource-dependencies/", 
            "text": "Resource Dependency\n\n\nThe ec2 instance that we have created is not that useful when we don't have access to it. So let us delete it and  we shall set up this again with additional resources. \n\n\nLet us create a security group, which allows us to ssh(port 22) into the machine.\n\n\nfile: main.tf\n \n\n\nprovider \naws\n {\n  region = \nus-east-1\n\n}\n\nresource \naws_instance\n \nfrontend\n {\n  ami           = \nami-0ac019f4fcb7cb7e6\n\n  instance_type = \nt2.micro\n\n}\n\nresource \naws_security_group\n \nfront-end\n {\n\n    name = \nfront-end\n\n\n    ingress {\n        cidr_blocks = [\n0.0.0.0/0\n]\n        from_port = 22\n        to_port = 22\n        protocol = \ntcp\n  \n        description = \nopen ssh port for all\n\n        }       \n    }\n}\n\n\n\n\nHere,\n  Resource type = aws_security_group,\n  Resource name = front-end\n\n\nThis \naws_security_group\n resource allows us to ssh into the instance.\n\n\nWe need to create the EC2 instance with this security group. To do that, \n\n\nThe final requirement is a \nkey pair\n using which we can login to the machine. Let us use \naws_key_pair\n to register the key with AWS and then use in our ec2 instance.\n\n\nTo do this, you will need to create a key pair in your local machine. Run the following commands. This will create one public key and a private key.\n\n\nroot@vibe$ ssh-keygen -t rsa\n\n[output]\nGenerating public/private rsa key pair.\nEnter file in which to save the key (/home/vibe/.ssh/id_rsa):\nEnter passphrase (empty for no passphrase):\nEnter same passphrase again:\nYour identification has been saved in /home/vibe/.ssh/id_rsa.\nYour public key has been saved in /home/vibe/.ssh/id_rsa.pub.\nThe key fingerprint is:\nSHA256:nSnSLKDvnLv22LFX+wKYMa0TvSt3AL406z+Asj/GSak vibe@vibes-MacBook-Air.local\nThe key's randomart image is:\n+---[RSA 2048]----+\n|                 |\n|                 |\n|    .  o         |\n|   . .=oo. o     |\n|  .  +oOS.+      |\n|  ..+ Xo+..      |\n|   *.o.* = .     |\n|  Eo*++o= +      |\n|   +O*==.o o.    |\n+----[SHA256]-----+\n\n\n\n\nCopy the content of your public key\n\n\ncat ~/.ssh/id_rsa.pub\n\n[output]\nssh-rsa AAAAB3NzaC1yc2EAAAADAQABAAABAQC4Q2TBuAD7ijkPjp+/Hl/QnrNo4hoZEz/l+UBsfvlDuJk8zfh0ivnQLtoYyXNuJ3/BjTVVIchrGo8CLZdTco//n+YBvMqgW4Wg5F92JNNkR5L5x04ELRUmC3ed1ZqbwrLmujzB33nMJ8Ld5dJjtS55KJa5MwkCaP7lqGicU2NgXe+if2DhCKW/lZyCpkkvRgmB7oEqj6aBWNjp+FMY4v6BtcmmB/+1Ry+GMvmZJO1EjSeUHAWCec3snX7TxJKHf4opwTHxknmhRKkz8+pS8rxyjiBeyncxP9jL9Tx/Zh6qmExCUfuhAWk87sjbb3j0enVs2LtzJOG9eBZ726wD83TJ vibe@vibes-MacBook-Air.local\n\n\n\n\nPaste the content of public key in the public_key\n\n\nfile: main.tf\n\n\n[...]\n\nresource \naws_security_group\n \nfront-end\n {\n\n    name = \nfront-end\n\n\n    ingress {\n        cidr_blocks = [\n0.0.0.0/0\n]\n        from_port = 22\n        to_port = 22\n        protocol = \ntcp\n  \n        description = \nopen ssh port for all\n\n}   }\n}\n\nresource \naws_key_pair\n \nterraform\n {\n  key_name   = \nterraform\n\n  public_key = \nssh-rsa AAAAB3NzaC1yc2EAAAADAQABAAABAQC4Q2TBuAD7ijkPjp+/Hl/QnrNo4hoZEz/l+UBsfvlDuJk8zfh0ivnQLtoYyXNuJ3/BjTVVIchrGo8CLZdTco//n+YBvMqgW4Wg5F92JNNkR5L5x04ELRUmC3ed1ZqbwrLmujzB33nMJ8Ld5dJjtS55KJa5MwkCaP7lqGicU2NgXe+if2DhCKW/lZyCpkkvRgmB7oEqj6aBWNjp+FMY4v6BtcmmB/+1Ry+GMvmZJO1EjSeUHAWCec3snX7TxJKHf4opwTHxknmhRKkz8+pS8rxyjiBeyncxP9jL9Tx/Zh6qmExCUfuhAWk87sjbb3j0enVs2LtzJOG9eBZ726wD83TJ vibe@vibes-MacBook-Air.local\n}\n\n\n\n\nWe need to make sure our instance uses this key. To do that, we should add one more attribute to our \naws_instance\n module. We will also tag the instace with a name.\n\n\nfile: main.tf\n\n\nprovider \naws\n {\n  region = \nus-east-1\n\n}\n\nresource \naws_instance\n \nfrontend\n {\n  ami           = \nami-0ac019f4fcb7cb7e6\n\n  instance_type = \nt2.micro\n\n  key_name      = \nterraform\n\n\n  tags {\n    Name       = \ntf-frontend-01\n\n    App        = \ndevops-demo\n\n    Maintainer = \nGourav Shah\n\n    Role =\nfrontend\n\n  }\n}\n\n[...]\n\n\n\n\nThe final file should look like the following.\n\n\nprovider \naws\n {\n  region = \nus-east-1\n\n}\n\nresource \naws_instance\n \nfrontend\n {\n  ami           = \nami-0ac019f4fcb7cb7e6\n\n  instance_type = \nt2.micro\n\n  key_name      = \nterraform\n\n\n  tags {\n    Name       = \ntf-frontend-01\n\n    App        = \ndevops-demo\n\n    Maintainer = \nGourav Shah\n\n    Role       = \nfrontend\n\n  }\n}\n\nresource \naws_security_group\n \nfront-end\n {\n\n        name = \nfrontend\n\n\n        ingress {\n                cidr_blocks = [\n0.0.0.0/0\n]\n        from_port = 22\n        to_port = 22\n        protocol = \ntcp\n  \n        description = \nopen ssh port for all\n        \n        }\n}\n\nresource \naws_key_pair\n \nterraform\n {\n  key_name   = \nterraform\n\n  public_key = \nssh-rsa AAAAB3NzaC1yc2EAAAADAQABAAABAQC4Q2TBuAD7ijkPjp+/Hl/QnrNo4hoZEz/l+UBsfvlDuJk8zfh0ivnQLtoYyXNuJ3/BjTVVIchrGo8CLZdTco//n+YBvMqgW4Wg5F92JNNkR5L5x04ELRUmC3ed1ZqbwrLmujzB33nMJ8Ld5dJjtS55KJa5MwkCaP7lqGicU2NgXe+if2DhCKW/lZyCpkkvRgmB7oEqj6aBWNjp+FMY4v6BtcmmB/+1Ry+GMvmZJO1EjSeUHAWCec3snX7TxJKHf4opwTHxknmhRKkz8+pS8rxyjiBeyncxP9jL9Tx/Zh6qmExCUfuhAWk87sjbb3j0enVs2LtzJOG9eBZ726wD83TJ vibe@vibes-MacBook-Air.local\n\n}\n\n\n\n\nExplicit Dependency\n\n\nWe can control the order of execution in two ways.\n\n  * Implicit Dependecy (Automatic Dependency)\n\n  * Explicit Dependency (Manual Dependency)  \n\n\nWe will learn more about \nImplicit Dependency\n in the next chapter. Now we will focus on adding \nExplicit Dependency\n to \naws_instance\n resource to depend on \naws_key_pair\n resource.\n\n\nThis will guarantee the creation of key pair before the instance get's created. In your instance block add the following,\n\n\nfile: main.tf\n\n\n[...]\nresource \naws_instance\n \nfrontend\n {\n  ami           = \nami-0ac019f4fcb7cb7e6\n\n  instance_type = \nt2.micro\n\n  key_name      = \nterraform\n\n\n  depends_on = [\naws_key_pair.webserver_key\n]\n  tags {\n    Name = \nterraform\n\n  }\n}\n[...]\n\n\n\n\nSyntax: \ndepends_on = [\"resource_type.resource_name\"]\n\n\nExercise: Create an explicit dependency on security group in ec2 instance block just like key pair dependecy\n\n\nIdempotency\n\n\nFinally apply the manifest by running\n\n\nterraform apply\n\n[output]\nPlan: 2 to add, 0 to change, 0 to destroy.\n\nDo you want to perform these actions?\n  Terraform will perform the actions described above.\n  Only 'yes' will be accepted to approve.\n\n  Enter a value: yes\n\naws_key_pair.webserver_key: Creating...\n  fingerprint: \n =\n \ncomputed\n\n  key_name:    \n =\n \nterraform\n\n  public_key:  \n =\n \nssh-rsa AAAAB3NzaC1yc2EAAAADAQABAAABAQC4Q2TBuAD7ijkPjp+/Hl/QnrNo4hoZEz/l+UBsfvlDuJk8zfh0ivnQLtoYyXNuJ3/BjTVVIchrGo8CLZdTco//n+YBvMqgW4Wg5F92JNNkR5L5x04ELRUmC3ed1ZqbwrLmujzB33nMJ8Ld5dJjtS55KJa5MwkCaP7lqGicU2NgXe+if2DhCKW/lZyCpkkvRgmB7oEqj6aBWNjp+FMY4v6BtcmmB/+1Ry+GMvmZJO1EjSeUHAWCec3snX7TxJKHf4opwTHxknmhRKkz8+pS8rxyjiBeyncxP9jL9Tx/Zh6qmExCUfuhAWk87sjbb3j0enVs2LtzJOG9eBZ726wD83TJ vibe@vibes-MacBook-Air.local\n\naws_key_pair.webserver_key: Creation complete after 3s (ID: web-admin-key)\naws_instance.webserver: Creating...\n  ami:                          \n =\n \nami-0ac019f4fcb7cb7e6\n\n  arn:                          \n =\n \ncomputed\n\n  associate_public_ip_address:  \n =\n \ncomputed\n\n  availability_zone:            \n =\n \ncomputed\n\n  cpu_core_count:               \n =\n \ncomputed\n\n  cpu_threads_per_core:         \n =\n \ncomputed\n\n  ebs_block_device.#:           \n =\n \ncomputed\n\n  ephemeral_block_device.#:     \n =\n \ncomputed\n\n  get_password_data:            \n =\n \nfalse\n\n  instance_state:               \n =\n \ncomputed\n\n  instance_type:                \n =\n \nt2.micro\n\n  ipv6_address_count:           \n =\n \ncomputed\n\n  ipv6_addresses.#:             \n =\n \ncomputed\n\n  key_name:                     \n =\n \nterraform\n\n  network_interface.#:          \n =\n \ncomputed\n\n  network_interface_id:         \n =\n \ncomputed\n\n  password_data:                \n =\n \ncomputed\n\n  placement_group:              \n =\n \ncomputed\n\n  primary_network_interface_id: \n =\n \ncomputed\n\n  private_dns:                  \n =\n \ncomputed\n\n  private_ip:                   \n =\n \ncomputed\n\n  public_dns:                   \n =\n \ncomputed\n\n  public_ip:                    \n =\n \ncomputed\n\n  root_block_device.#:          \n =\n \ncomputed\n\n  security_groups.#:            \n =\n \ncomputed\n\n  source_dest_check:            \n =\n \ntrue\n\n  subnet_id:                    \n =\n \ncomputed\n\n  tags.%:                       \n =\n \n1\n\n  tags.Name:                    \n =\n \nfrontend\n\n  tenancy:                      \n =\n \ncomputed\n\n  volume_tags.%:                \n =\n \ncomputed\n\n  vpc_security_group_ids.#:     \n =\n \ncomputed\n\naws_instance.webserver: Still creating... (10s elapsed)\naws_instance.webserver: Still creating... (20s elapsed)\naws_instance.webserver: Still creating... (30s elapsed)\naws_instance.webserver: Creation complete after 37s (ID: i-0a7d259b3126e16b8)\n\nApply complete! Resources: 2 added, 0 changed, 0 destroyed.\n\n\n\n\nIf you have noticed, Terraform did not create the security group this time around. The reason for this behaviour is, it had created the security group resource in the first run itself. So it did not create the same resource again when we applied the second time. This behaviour is called \nIdempotency\n.\n\n\nReference\n\n\nIf you want to know more about, resource dependencies then please refer \nthis link\n.", 
            "title": "Resource Dependencies"
        }, 
        {
            "location": "/05-resource-dependencies/#resource-dependency", 
            "text": "The ec2 instance that we have created is not that useful when we don't have access to it. So let us delete it and  we shall set up this again with additional resources.   Let us create a security group, which allows us to ssh(port 22) into the machine.  file: main.tf    provider  aws  {\n  region =  us-east-1 \n}\n\nresource  aws_instance   frontend  {\n  ami           =  ami-0ac019f4fcb7cb7e6 \n  instance_type =  t2.micro \n}\n\nresource  aws_security_group   front-end  {\n\n    name =  front-end \n\n    ingress {\n        cidr_blocks = [ 0.0.0.0/0 ]\n        from_port = 22\n        to_port = 22\n        protocol =  tcp   \n        description =  open ssh port for all \n        }       \n    }\n}  Here,\n  Resource type = aws_security_group,\n  Resource name = front-end  This  aws_security_group  resource allows us to ssh into the instance.  We need to create the EC2 instance with this security group. To do that,   The final requirement is a  key pair  using which we can login to the machine. Let us use  aws_key_pair  to register the key with AWS and then use in our ec2 instance.  To do this, you will need to create a key pair in your local machine. Run the following commands. This will create one public key and a private key.  root@vibe$ ssh-keygen -t rsa\n\n[output]\nGenerating public/private rsa key pair.\nEnter file in which to save the key (/home/vibe/.ssh/id_rsa):\nEnter passphrase (empty for no passphrase):\nEnter same passphrase again:\nYour identification has been saved in /home/vibe/.ssh/id_rsa.\nYour public key has been saved in /home/vibe/.ssh/id_rsa.pub.\nThe key fingerprint is:\nSHA256:nSnSLKDvnLv22LFX+wKYMa0TvSt3AL406z+Asj/GSak vibe@vibes-MacBook-Air.local\nThe key's randomart image is:\n+---[RSA 2048]----+\n|                 |\n|                 |\n|    .  o         |\n|   . .=oo. o     |\n|  .  +oOS.+      |\n|  ..+ Xo+..      |\n|   *.o.* = .     |\n|  Eo*++o= +      |\n|   +O*==.o o.    |\n+----[SHA256]-----+  Copy the content of your public key  cat ~/.ssh/id_rsa.pub\n\n[output]\nssh-rsa AAAAB3NzaC1yc2EAAAADAQABAAABAQC4Q2TBuAD7ijkPjp+/Hl/QnrNo4hoZEz/l+UBsfvlDuJk8zfh0ivnQLtoYyXNuJ3/BjTVVIchrGo8CLZdTco//n+YBvMqgW4Wg5F92JNNkR5L5x04ELRUmC3ed1ZqbwrLmujzB33nMJ8Ld5dJjtS55KJa5MwkCaP7lqGicU2NgXe+if2DhCKW/lZyCpkkvRgmB7oEqj6aBWNjp+FMY4v6BtcmmB/+1Ry+GMvmZJO1EjSeUHAWCec3snX7TxJKHf4opwTHxknmhRKkz8+pS8rxyjiBeyncxP9jL9Tx/Zh6qmExCUfuhAWk87sjbb3j0enVs2LtzJOG9eBZ726wD83TJ vibe@vibes-MacBook-Air.local  Paste the content of public key in the public_key  file: main.tf  [...]\n\nresource  aws_security_group   front-end  {\n\n    name =  front-end \n\n    ingress {\n        cidr_blocks = [ 0.0.0.0/0 ]\n        from_port = 22\n        to_port = 22\n        protocol =  tcp   \n        description =  open ssh port for all \n}   }\n}\n\nresource  aws_key_pair   terraform  {\n  key_name   =  terraform \n  public_key =  ssh-rsa AAAAB3NzaC1yc2EAAAADAQABAAABAQC4Q2TBuAD7ijkPjp+/Hl/QnrNo4hoZEz/l+UBsfvlDuJk8zfh0ivnQLtoYyXNuJ3/BjTVVIchrGo8CLZdTco//n+YBvMqgW4Wg5F92JNNkR5L5x04ELRUmC3ed1ZqbwrLmujzB33nMJ8Ld5dJjtS55KJa5MwkCaP7lqGicU2NgXe+if2DhCKW/lZyCpkkvRgmB7oEqj6aBWNjp+FMY4v6BtcmmB/+1Ry+GMvmZJO1EjSeUHAWCec3snX7TxJKHf4opwTHxknmhRKkz8+pS8rxyjiBeyncxP9jL9Tx/Zh6qmExCUfuhAWk87sjbb3j0enVs2LtzJOG9eBZ726wD83TJ vibe@vibes-MacBook-Air.local\n}  We need to make sure our instance uses this key. To do that, we should add one more attribute to our  aws_instance  module. We will also tag the instace with a name.  file: main.tf  provider  aws  {\n  region =  us-east-1 \n}\n\nresource  aws_instance   frontend  {\n  ami           =  ami-0ac019f4fcb7cb7e6 \n  instance_type =  t2.micro \n  key_name      =  terraform \n\n  tags {\n    Name       =  tf-frontend-01 \n    App        =  devops-demo \n    Maintainer =  Gourav Shah \n    Role = frontend \n  }\n}\n\n[...]  The final file should look like the following.  provider  aws  {\n  region =  us-east-1 \n}\n\nresource  aws_instance   frontend  {\n  ami           =  ami-0ac019f4fcb7cb7e6 \n  instance_type =  t2.micro \n  key_name      =  terraform \n\n  tags {\n    Name       =  tf-frontend-01 \n    App        =  devops-demo \n    Maintainer =  Gourav Shah \n    Role       =  frontend \n  }\n}\n\nresource  aws_security_group   front-end  {\n\n        name =  frontend \n\n        ingress {\n                cidr_blocks = [ 0.0.0.0/0 ]\n        from_port = 22\n        to_port = 22\n        protocol =  tcp   \n        description =  open ssh port for all         \n        }\n}\n\nresource  aws_key_pair   terraform  {\n  key_name   =  terraform \n  public_key =  ssh-rsa AAAAB3NzaC1yc2EAAAADAQABAAABAQC4Q2TBuAD7ijkPjp+/Hl/QnrNo4hoZEz/l+UBsfvlDuJk8zfh0ivnQLtoYyXNuJ3/BjTVVIchrGo8CLZdTco//n+YBvMqgW4Wg5F92JNNkR5L5x04ELRUmC3ed1ZqbwrLmujzB33nMJ8Ld5dJjtS55KJa5MwkCaP7lqGicU2NgXe+if2DhCKW/lZyCpkkvRgmB7oEqj6aBWNjp+FMY4v6BtcmmB/+1Ry+GMvmZJO1EjSeUHAWCec3snX7TxJKHf4opwTHxknmhRKkz8+pS8rxyjiBeyncxP9jL9Tx/Zh6qmExCUfuhAWk87sjbb3j0enVs2LtzJOG9eBZ726wD83TJ vibe@vibes-MacBook-Air.local \n}", 
            "title": "Resource Dependency"
        }, 
        {
            "location": "/05-resource-dependencies/#explicit-dependency", 
            "text": "We can control the order of execution in two ways. \n  * Implicit Dependecy (Automatic Dependency) \n  * Explicit Dependency (Manual Dependency)    We will learn more about  Implicit Dependency  in the next chapter. Now we will focus on adding  Explicit Dependency  to  aws_instance  resource to depend on  aws_key_pair  resource.  This will guarantee the creation of key pair before the instance get's created. In your instance block add the following,  file: main.tf  [...]\nresource  aws_instance   frontend  {\n  ami           =  ami-0ac019f4fcb7cb7e6 \n  instance_type =  t2.micro \n  key_name      =  terraform \n\n  depends_on = [ aws_key_pair.webserver_key ]\n  tags {\n    Name =  terraform \n  }\n}\n[...]  Syntax:  depends_on = [\"resource_type.resource_name\"]  Exercise: Create an explicit dependency on security group in ec2 instance block just like key pair dependecy", 
            "title": "Explicit Dependency"
        }, 
        {
            "location": "/05-resource-dependencies/#idempotency", 
            "text": "Finally apply the manifest by running  terraform apply\n\n[output]\nPlan: 2 to add, 0 to change, 0 to destroy.\n\nDo you want to perform these actions?\n  Terraform will perform the actions described above.\n  Only 'yes' will be accepted to approve.\n\n  Enter a value: yes\n\naws_key_pair.webserver_key: Creating...\n  fingerprint:   =   computed \n  key_name:      =   terraform \n  public_key:    =   ssh-rsa AAAAB3NzaC1yc2EAAAADAQABAAABAQC4Q2TBuAD7ijkPjp+/Hl/QnrNo4hoZEz/l+UBsfvlDuJk8zfh0ivnQLtoYyXNuJ3/BjTVVIchrGo8CLZdTco//n+YBvMqgW4Wg5F92JNNkR5L5x04ELRUmC3ed1ZqbwrLmujzB33nMJ8Ld5dJjtS55KJa5MwkCaP7lqGicU2NgXe+if2DhCKW/lZyCpkkvRgmB7oEqj6aBWNjp+FMY4v6BtcmmB/+1Ry+GMvmZJO1EjSeUHAWCec3snX7TxJKHf4opwTHxknmhRKkz8+pS8rxyjiBeyncxP9jL9Tx/Zh6qmExCUfuhAWk87sjbb3j0enVs2LtzJOG9eBZ726wD83TJ vibe@vibes-MacBook-Air.local \naws_key_pair.webserver_key: Creation complete after 3s (ID: web-admin-key)\naws_instance.webserver: Creating...\n  ami:                            =   ami-0ac019f4fcb7cb7e6 \n  arn:                            =   computed \n  associate_public_ip_address:    =   computed \n  availability_zone:              =   computed \n  cpu_core_count:                 =   computed \n  cpu_threads_per_core:           =   computed \n  ebs_block_device.#:             =   computed \n  ephemeral_block_device.#:       =   computed \n  get_password_data:              =   false \n  instance_state:                 =   computed \n  instance_type:                  =   t2.micro \n  ipv6_address_count:             =   computed \n  ipv6_addresses.#:               =   computed \n  key_name:                       =   terraform \n  network_interface.#:            =   computed \n  network_interface_id:           =   computed \n  password_data:                  =   computed \n  placement_group:                =   computed \n  primary_network_interface_id:   =   computed \n  private_dns:                    =   computed \n  private_ip:                     =   computed \n  public_dns:                     =   computed \n  public_ip:                      =   computed \n  root_block_device.#:            =   computed \n  security_groups.#:              =   computed \n  source_dest_check:              =   true \n  subnet_id:                      =   computed \n  tags.%:                         =   1 \n  tags.Name:                      =   frontend \n  tenancy:                        =   computed \n  volume_tags.%:                  =   computed \n  vpc_security_group_ids.#:       =   computed \naws_instance.webserver: Still creating... (10s elapsed)\naws_instance.webserver: Still creating... (20s elapsed)\naws_instance.webserver: Still creating... (30s elapsed)\naws_instance.webserver: Creation complete after 37s (ID: i-0a7d259b3126e16b8)\n\nApply complete! Resources: 2 added, 0 changed, 0 destroyed.  If you have noticed, Terraform did not create the security group this time around. The reason for this behaviour is, it had created the security group resource in the first run itself. So it did not create the same resource again when we applied the second time. This behaviour is called  Idempotency .", 
            "title": "Idempotency"
        }, 
        {
            "location": "/05-resource-dependencies/#reference", 
            "text": "If you want to know more about, resource dependencies then please refer  this link .", 
            "title": "Reference"
        }, 
        {
            "location": "/06-variables-and-outputs/", 
            "text": "Variables\n\n\nLet us try to ssh into the machine that we've just created. Get the public IP from the AWS console.\n\n\nssh ubuntu@34.203.194.201\n\n[output]\nssh: connect to host 34.203.194.201 port 22: Operation timed out\n\n\n\n\nYou will not be able to SSH. The reason is we have not associated the security group that we have created with this instance. The instance is still using the default security group which doesn't allow ssh. \n\n\n\n\nWe need to fix this issue. Let us associate our security group with this machine.\n\n\nfile: main.tf\n\n\nBad Practice\n\n\nresource \naws_instance\n \nfrontend\n {\n  ami                    = \nami-0ac019f4fcb7cb7e6\n\n  instance_type          = \nt2.micro\n\n  key_name               = \nterraform\n\n  vpc_security_group_ids = \nsg-0c22a3497351d1caa\n\n  depends_on             = [\naws_key_pair.terraform\n]\n\n  tags {\n    Name       = \ntf-frontend-01\n\n    App        = \ndevops-demo\n\n    Maintainer = \nGourav Shah\n\n    Role =\nfrontend\n\n\n  }\n}\n\n\n\n\nWe can manually copy the ID of the security group and apply the manifest. This would work but this is an ugly fix. We should let Terraform to find the these kind of mutable data. Thats where \nVariables\n come into picture.\n\n\nType 1: Attribute of a Resource\n\n\nfile: main.tf\n\n\nGood Practice\n\n\nresource \naws_instance\n \nfrontend\n {\n  ami                    = \nami-0ac019f4fcb7cb7e6\n\n  instance_type          = \nt2.micro\n\n  key_name               = \nterraform\n\n  vpc_security_group_ids = [\n${aws_security_group.front-end.id}\n]\n  depends_on             = [\naws_key_pair.terraform\n]\n\n  tags {\n    Name       = \ntf-frontend-01\n\n    App        = \ndevops-demo\n\n    Maintainer = \nGourav Shah\n\n    Role =\nfrontend\n\n  }\n}\n\n\n\n\nThis is how variable interpolation works in Terraform. \n\n\nSyntax: ${TYPE.NAME.ATTRIBUTE}\n\n\nIn our case, it is, \n${aws_security_group.fornt-end.id}\n.\nHere,\n  aws_security_group =\n TYPE\n  webserver_sg       =\n NAME\n  id                 =\n ATTRIBUTE\n\n\nEvery resource has set of attribute that can be referred as a variable. \naws_security_group\n resource has the following attributes which can be referred.\n\n  * id - The ID of the security group\n\n  * arn - The ARN of the security group\n\n  * vpc_id - The VPC ID.\n\n  * owner_id - The owner ID.\n\n  * name - The name of the security group\n\n  * description - The description of the security group\n\n  * ingress - The ingress rules. See above for more.\n\n  * egress - The egress rules. See above for more.  \n\n\nThis also creates an \nImplicit Dependency\n. Terraform will know that this security group has to be created before the EC2 instance since the later refers to it. Let us apply the given manifest.  \n\n\nLet us apply the manifest.\n\n\nterraform apply \n\n[output]\nAn execution plan has been generated and is shown below.\nResource actions are indicated with the following symbols:\n  ~ update in-place\n\nTerraform will perform the following actions:\n\n  ~ aws_instance.webserver\n      vpc_security_group_ids.118229083:  \n =\n \nsg-0c22a3497351d1caa\n\n      vpc_security_group_ids.3314100969: \nsg-a42b7ae9\n =\n \n\n\n\nPlan: 0 to add, 1 to change, 0 to destroy.\n\nDo you want to perform these actions?\n  Terraform will perform the actions described above.\n  Only 'yes' will be accepted to approve.\n\n  Enter a value: yes\n\naws_instance.webserver: Modifying... (ID: i-0a7d259b3126e16b8)\n  vpc_security_group_ids.118229083:  \n =\n \nsg-0c22a3497351d1caa\n\n  vpc_security_group_ids.3314100969: \nsg-a42b7ae9\n =\n \n\naws_instance.webserver: Still modifying... (ID: i-0a7d259b3126e16b8, 10s elapsed)\naws_instance.webserver: Modifications complete after 13s (ID: i-0a7d259b3126e16b8)\n\nApply complete! Resources: 0 added, 1 changed, 0 destroyed.\n\n\n\n\nCheck in your AWS console to check the same.\n\n\n\n\nNow you should be able to SSH into the machine.\n\n\nssh ubuntu@34.203.194.201\n\n[output]\nWarning: Permanently added '34.203.194.201' (ECDSA) to the list of known hosts.\nWelcome to Ubuntu 14.04 LTS (GNU/Linux 3.13.0-29-generic x86_64)\n\nubuntu@ip-172-31-40-32:~$\n\n\n\n\nExercise: Remove the explicit dependecy by using the key_pair with above given attribute reference method\n \n\n\nType 2: User Defined(Input) Variables\n\n\nIt is always a good practice to remove data from code. In our manifest, we are hardcoding all the values. Instead we should use variables to define the values and reference them in the manifest. \n\n\nCreate a new file with the name \nvariables.tf\n\n\ntouch variables.tf\n\n\n\n\nSyntax\n:\n\n\nvariable \nname\n {\n  description = \ndescribe your variable\n\n  default     = \ndefault value\n\n}\n\n\n\n\nLet us define our first variable in this file.\n\n\nfile: variables.tf\n\n\nvariable \nami\n {\n  description = \nami for the instance\n\n  default     = \nami-0ac019f4fcb7cb7e6\n\n}\n\n\n\n\nThis variable can be referenced in the main manifest like the following.\n\n\n[...]\nresource \naws_instance\n \nfrontend\n {\n  ami                    = \n${var.ami}\n\n  instance_type          = \nt2.micro\n\n  key_name               = \nterraform\n\n  vpc_security_group_ids = [\n${aws_security_group.front-end.id}\n]\n  depends_on             = [\naws_key_pair.terraform\n]\n\n  tags {    \n    Name       = \ntf-frontend-01\n\n    App        = \ndevops-demo\n\n    Maintainer = \nGourav Shah\n\n    Role =\nfrontend\n\n  }\n}\n[...]\n\n\n\n\nLet us apply the manifest to see if this works. Terraform automatically loads all the files with \n.tf\n extension from the working directory. So we do not need to implicitly mention about the variable file.\n\n\nterraform apply\n\n[output]\naws_key_pair.webserver_key: Refreshing state... (ID: web-admin-key)\naws_security_group.webserver_sg: Refreshing state... (ID: sg-0c22a3497351d1caa)\naws_instance.webserver: Refreshing state... (ID: i-0a7d259b3126e16b8)\n\nApply complete! Resources: 0 added, 0 changed, 0 destroyed.\n\n\n\n\nLet us parameterize some properties from our main manifest.\n\n\nfile: variables.tf\n\n\n# default type is string\nvariable \nami\n {\n  description = \nami for the instance\n\n  default     = \nami-0ac019f4fcb7cb7e6\n\n}\n\n# map type variable definition\nvariable \ninstance\n {\n  description = \ninstance parameters\n\n  type        = \nmap\n\n\n  default = {\n    type = \nt2.micro\n\n    name = \ntf-frontend-01\n\n  }\n}\n\nvariable \nkey_name\n {\n  description = \nname of the key\n\n  default     = \nterraform\n\n}\n\nvariable \nkey_pub\n {\n  description = \ncontent of public key\n\n  default     = \nssh-rsa AAAAB3NzaC1yc2EAAAADAQABAAABAQC4Q2TBuAD7ijkPjp+/Hl/QnrNo4hoZEz/l+UBsfvlDuJk8zfh0ivnQLtoYyXNuJ3/BjTVVIchrGo8CLZdTco//n+YBvMqgW4Wg5F92JNNkR5L5x04ELRUmC3ed1ZqbwrLmujzB33nMJ8Ld5dJjtS55KJa5MwkCaP7lqGicU2NgXe+if2DhCKW/lZyCpkkvRgmB7oEqj6aBWNjp+FMY4v6BtcmmB/+1Ry+GMvmZJO1EjSeUHAWCec3snX7TxJKHf4opwTHxknmhRKkz8+pS8rxyjiBeyncxP9jL9Tx/Zh6qmExCUfuhAWk87sjbb3j0enVs2LtzJOG9eBZ726wD83TJ vibe@vibes-MacBook-Air.local\n\n}\n\n\n\n\nHere is fully parameterized main manifest.\n\nfile: main.tf\n\n\nprovider \naws\n {\n  region = \nap-southeast-1\n\n}\n\nresource \naws_instance\n \nfrontend\n {\n  ami                    = \n${var.ami}\n\n  instance_type          = \n${var.instance[\ntype\n]}\n\n  key_name               = \nweb-admin-key\n\n  vpc_security_group_ids = [\n${aws_security_group.front-end.id}\n]\n  depends_on             = [\naws_key_pair.terraform\n]\n\n  tags {\n    Name = \n${var.instance[\nname\n]}\n\n  }\n}\n\nresource \naws_security_group\n \nfront-end\n {\n  name = \nfront-end\n\n\n  ingress {\n    from_port   = 22\n    to_port     = 22\n    protocol    = \ntcp\n\n    cidr_blocks = [\n0.0.0.0/0\n]\n  }\n}\n\nresource \naws_key_pair\n \nterraform\n {\n  key_name   = \n${var.key_name}\n\n  public_key = \n${var.key_pub}\n\n}\n\n\n\n\nI've intentionally set the variable \ninstance.name\n to \ndemo-server\n. Let us apply the manifest.\n\n\nterraform apply\n\n[output]\naws_security_group.webserver_sg: Refreshing state... (ID: sg-0c22a3497351d1caa)\naws_key_pair.webserver_key: Refreshing state... (ID: web-admin-key)\naws_instance.webserver: Refreshing state... (ID: i-0a7d259b3126e16b8)\n\nAn execution plan has been generated and is shown below.\nResource actions are indicated with the following symbols:\n  ~ update in-place\n\nTerraform will perform the following actions:\n\n  ~ aws_instance.webserver\n      tags.Name: \nweberserver\n =\n \ndevops-server\n\n\n\nPlan: 0 to add, 1 to change, 0 to destroy.\n\nDo you want to perform these actions?\n  Terraform will perform the actions described above.\n  Only 'yes' will be accepted to approve.\n\n  Enter a value: yes\n\naws_instance.webserver: Modifying... (ID: i-0a7d259b3126e16b8)\n  tags.Name: \nweberserver\n =\n \ndevops-server\n\naws_instance.webserver: Still modifying... (ID: i-0a7d259b3126e16b8, 10s elapsed)\naws_instance.webserver: Modifications complete after 14s (ID: i-0a7d259b3126e16b8)\n\nApply complete! Resources: 0 added, 1 changed, 0 destroyed.\n\n\n\n\nTerraform has substituted the value of \ninstance name\n from variables, thus it has changed the resource as well.\n\n\nType 3: Output Variables\n\n\nOutput variables help us to refer the metadata of resources after they are applied. This saves a lot of time, because we don't have to find go to AWS web console to find the details.\n\n\nLet us get the public ip of the instance we've created by using output variable.\n\n\nfile: main.tf\n\n\n[...]\noutput \nwebserver_ip\n {\n    value = \n${aws_instance.webserver.public_ip}\n\n}\n[...]\n\n\n\n\nOutput variables also uses variable interpolation. \n\n\nRun \nterraform apply\n to see output variables in action.\n\n\nterraform apply\n\n[output]\naws_security_group.webserver_sg: Refreshing state... (ID: sg-0c22a3497351d1caa)\naws_key_pair.webserver_key: Refreshing state... (ID: web-admin-key)\naws_instance.webserver: Refreshing state... (ID: i-0a7d259b3126e16b8)\n\nApply complete! Resources: 0 added, 0 changed, 0 destroyed.\n\nOutputs:\n\nwebserver_ip = 34.203.194.201\n\n\n\n\nTODO\n\n\n\n\nusage of environment vars\n\n\n\n\nReference\n\n\nIf you want know more about variables, please visit the \nofficial documentation\n.", 
            "title": "Input and Output Variables"
        }, 
        {
            "location": "/06-variables-and-outputs/#variables", 
            "text": "Let us try to ssh into the machine that we've just created. Get the public IP from the AWS console.  ssh ubuntu@34.203.194.201\n\n[output]\nssh: connect to host 34.203.194.201 port 22: Operation timed out  You will not be able to SSH. The reason is we have not associated the security group that we have created with this instance. The instance is still using the default security group which doesn't allow ssh.    We need to fix this issue. Let us associate our security group with this machine.  file: main.tf  Bad Practice  resource  aws_instance   frontend  {\n  ami                    =  ami-0ac019f4fcb7cb7e6 \n  instance_type          =  t2.micro \n  key_name               =  terraform \n  vpc_security_group_ids =  sg-0c22a3497351d1caa \n  depends_on             = [ aws_key_pair.terraform ]\n\n  tags {\n    Name       =  tf-frontend-01 \n    App        =  devops-demo \n    Maintainer =  Gourav Shah \n    Role = frontend \n\n  }\n}  We can manually copy the ID of the security group and apply the manifest. This would work but this is an ugly fix. We should let Terraform to find the these kind of mutable data. Thats where  Variables  come into picture.", 
            "title": "Variables"
        }, 
        {
            "location": "/06-variables-and-outputs/#type-1-attribute-of-a-resource", 
            "text": "file: main.tf  Good Practice  resource  aws_instance   frontend  {\n  ami                    =  ami-0ac019f4fcb7cb7e6 \n  instance_type          =  t2.micro \n  key_name               =  terraform \n  vpc_security_group_ids = [ ${aws_security_group.front-end.id} ]\n  depends_on             = [ aws_key_pair.terraform ]\n\n  tags {\n    Name       =  tf-frontend-01 \n    App        =  devops-demo \n    Maintainer =  Gourav Shah \n    Role = frontend \n  }\n}  This is how variable interpolation works in Terraform.   Syntax: ${TYPE.NAME.ATTRIBUTE}  In our case, it is,  ${aws_security_group.fornt-end.id} .\nHere,\n  aws_security_group =  TYPE\n  webserver_sg       =  NAME\n  id                 =  ATTRIBUTE  Every resource has set of attribute that can be referred as a variable.  aws_security_group  resource has the following attributes which can be referred. \n  * id - The ID of the security group \n  * arn - The ARN of the security group \n  * vpc_id - The VPC ID. \n  * owner_id - The owner ID. \n  * name - The name of the security group \n  * description - The description of the security group \n  * ingress - The ingress rules. See above for more. \n  * egress - The egress rules. See above for more.    This also creates an  Implicit Dependency . Terraform will know that this security group has to be created before the EC2 instance since the later refers to it. Let us apply the given manifest.    Let us apply the manifest.  terraform apply \n\n[output]\nAn execution plan has been generated and is shown below.\nResource actions are indicated with the following symbols:\n  ~ update in-place\n\nTerraform will perform the following actions:\n\n  ~ aws_instance.webserver\n      vpc_security_group_ids.118229083:    =   sg-0c22a3497351d1caa \n      vpc_security_group_ids.3314100969:  sg-a42b7ae9  =   \n\n\nPlan: 0 to add, 1 to change, 0 to destroy.\n\nDo you want to perform these actions?\n  Terraform will perform the actions described above.\n  Only 'yes' will be accepted to approve.\n\n  Enter a value: yes\n\naws_instance.webserver: Modifying... (ID: i-0a7d259b3126e16b8)\n  vpc_security_group_ids.118229083:    =   sg-0c22a3497351d1caa \n  vpc_security_group_ids.3314100969:  sg-a42b7ae9  =   \naws_instance.webserver: Still modifying... (ID: i-0a7d259b3126e16b8, 10s elapsed)\naws_instance.webserver: Modifications complete after 13s (ID: i-0a7d259b3126e16b8)\n\nApply complete! Resources: 0 added, 1 changed, 0 destroyed.  Check in your AWS console to check the same.   Now you should be able to SSH into the machine.  ssh ubuntu@34.203.194.201\n\n[output]\nWarning: Permanently added '34.203.194.201' (ECDSA) to the list of known hosts.\nWelcome to Ubuntu 14.04 LTS (GNU/Linux 3.13.0-29-generic x86_64)\n\nubuntu@ip-172-31-40-32:~$  Exercise: Remove the explicit dependecy by using the key_pair with above given attribute reference method", 
            "title": "Type 1: Attribute of a Resource"
        }, 
        {
            "location": "/06-variables-and-outputs/#type-2-user-definedinput-variables", 
            "text": "It is always a good practice to remove data from code. In our manifest, we are hardcoding all the values. Instead we should use variables to define the values and reference them in the manifest.   Create a new file with the name  variables.tf  touch variables.tf  Syntax :  variable  name  {\n  description =  describe your variable \n  default     =  default value \n}  Let us define our first variable in this file.  file: variables.tf  variable  ami  {\n  description =  ami for the instance \n  default     =  ami-0ac019f4fcb7cb7e6 \n}  This variable can be referenced in the main manifest like the following.  [...]\nresource  aws_instance   frontend  {\n  ami                    =  ${var.ami} \n  instance_type          =  t2.micro \n  key_name               =  terraform \n  vpc_security_group_ids = [ ${aws_security_group.front-end.id} ]\n  depends_on             = [ aws_key_pair.terraform ]\n\n  tags {    \n    Name       =  tf-frontend-01 \n    App        =  devops-demo \n    Maintainer =  Gourav Shah \n    Role = frontend \n  }\n}\n[...]  Let us apply the manifest to see if this works. Terraform automatically loads all the files with  .tf  extension from the working directory. So we do not need to implicitly mention about the variable file.  terraform apply\n\n[output]\naws_key_pair.webserver_key: Refreshing state... (ID: web-admin-key)\naws_security_group.webserver_sg: Refreshing state... (ID: sg-0c22a3497351d1caa)\naws_instance.webserver: Refreshing state... (ID: i-0a7d259b3126e16b8)\n\nApply complete! Resources: 0 added, 0 changed, 0 destroyed.  Let us parameterize some properties from our main manifest.  file: variables.tf  # default type is string\nvariable  ami  {\n  description =  ami for the instance \n  default     =  ami-0ac019f4fcb7cb7e6 \n}\n\n# map type variable definition\nvariable  instance  {\n  description =  instance parameters \n  type        =  map \n\n  default = {\n    type =  t2.micro \n    name =  tf-frontend-01 \n  }\n}\n\nvariable  key_name  {\n  description =  name of the key \n  default     =  terraform \n}\n\nvariable  key_pub  {\n  description =  content of public key \n  default     =  ssh-rsa AAAAB3NzaC1yc2EAAAADAQABAAABAQC4Q2TBuAD7ijkPjp+/Hl/QnrNo4hoZEz/l+UBsfvlDuJk8zfh0ivnQLtoYyXNuJ3/BjTVVIchrGo8CLZdTco//n+YBvMqgW4Wg5F92JNNkR5L5x04ELRUmC3ed1ZqbwrLmujzB33nMJ8Ld5dJjtS55KJa5MwkCaP7lqGicU2NgXe+if2DhCKW/lZyCpkkvRgmB7oEqj6aBWNjp+FMY4v6BtcmmB/+1Ry+GMvmZJO1EjSeUHAWCec3snX7TxJKHf4opwTHxknmhRKkz8+pS8rxyjiBeyncxP9jL9Tx/Zh6qmExCUfuhAWk87sjbb3j0enVs2LtzJOG9eBZ726wD83TJ vibe@vibes-MacBook-Air.local \n}  Here is fully parameterized main manifest. file: main.tf  provider  aws  {\n  region =  ap-southeast-1 \n}\n\nresource  aws_instance   frontend  {\n  ami                    =  ${var.ami} \n  instance_type          =  ${var.instance[ type ]} \n  key_name               =  web-admin-key \n  vpc_security_group_ids = [ ${aws_security_group.front-end.id} ]\n  depends_on             = [ aws_key_pair.terraform ]\n\n  tags {\n    Name =  ${var.instance[ name ]} \n  }\n}\n\nresource  aws_security_group   front-end  {\n  name =  front-end \n\n  ingress {\n    from_port   = 22\n    to_port     = 22\n    protocol    =  tcp \n    cidr_blocks = [ 0.0.0.0/0 ]\n  }\n}\n\nresource  aws_key_pair   terraform  {\n  key_name   =  ${var.key_name} \n  public_key =  ${var.key_pub} \n}  I've intentionally set the variable  instance.name  to  demo-server . Let us apply the manifest.  terraform apply\n\n[output]\naws_security_group.webserver_sg: Refreshing state... (ID: sg-0c22a3497351d1caa)\naws_key_pair.webserver_key: Refreshing state... (ID: web-admin-key)\naws_instance.webserver: Refreshing state... (ID: i-0a7d259b3126e16b8)\n\nAn execution plan has been generated and is shown below.\nResource actions are indicated with the following symbols:\n  ~ update in-place\n\nTerraform will perform the following actions:\n\n  ~ aws_instance.webserver\n      tags.Name:  weberserver  =   devops-server \n\n\nPlan: 0 to add, 1 to change, 0 to destroy.\n\nDo you want to perform these actions?\n  Terraform will perform the actions described above.\n  Only 'yes' will be accepted to approve.\n\n  Enter a value: yes\n\naws_instance.webserver: Modifying... (ID: i-0a7d259b3126e16b8)\n  tags.Name:  weberserver  =   devops-server \naws_instance.webserver: Still modifying... (ID: i-0a7d259b3126e16b8, 10s elapsed)\naws_instance.webserver: Modifications complete after 14s (ID: i-0a7d259b3126e16b8)\n\nApply complete! Resources: 0 added, 1 changed, 0 destroyed.  Terraform has substituted the value of  instance name  from variables, thus it has changed the resource as well.", 
            "title": "Type 2: User Defined(Input) Variables"
        }, 
        {
            "location": "/06-variables-and-outputs/#type-3-output-variables", 
            "text": "Output variables help us to refer the metadata of resources after they are applied. This saves a lot of time, because we don't have to find go to AWS web console to find the details.  Let us get the public ip of the instance we've created by using output variable.  file: main.tf  [...]\noutput  webserver_ip  {\n    value =  ${aws_instance.webserver.public_ip} \n}\n[...]  Output variables also uses variable interpolation.   Run  terraform apply  to see output variables in action.  terraform apply\n\n[output]\naws_security_group.webserver_sg: Refreshing state... (ID: sg-0c22a3497351d1caa)\naws_key_pair.webserver_key: Refreshing state... (ID: web-admin-key)\naws_instance.webserver: Refreshing state... (ID: i-0a7d259b3126e16b8)\n\nApply complete! Resources: 0 added, 0 changed, 0 destroyed.\n\nOutputs:\n\nwebserver_ip = 34.203.194.201", 
            "title": "Type 3: Output Variables"
        }, 
        {
            "location": "/06-variables-and-outputs/#todo", 
            "text": "usage of environment vars", 
            "title": "TODO"
        }, 
        {
            "location": "/06-variables-and-outputs/#reference", 
            "text": "If you want know more about variables, please visit the  official documentation .", 
            "title": "Reference"
        }, 
        {
            "location": "/07-provisioners/", 
            "text": "Provisioners\n\n\nProvisioners are used to execute scripts either on local machines or on remote machines. \nProvisioners will run at either\n  * Resource creation time , hence called \nCreation-Time provisioner\n or\n\n  * Resource destruction time, hence called \nDestroy-Time provisioner\n  \n\n\nMost generally used provisioners are,\n\n  * file        =\n copy file from local to remote\n  * local-exec  =\n execute on the machine where you run Terraform commands\n  * remote-exec =\n execute on the machine created/modified by Terrform\n\n\nDevops Demo Application\n\n\nWe will set up \nthis application\n using creation-time provisioner. \n\n\nFile Provisioner\n\n\nCreate a new file with the name \nuser-data.sh\n\n\ntouch user-data.sh\n\n\n\n\nfile: user-data.sh\n\n\n#!/bin/bash\nsudo apt update\nsudo apt install -y software-properties-common language-pack-en-base dialog apt-utils\nsudo update-locale LC_ALL=en_US.UTF-8 LANG=en_US.UTF-8\nsudo cp /usr/share/zoneinfo/America/New_York /etc/localtime\nsudo LC_ALL=en_US.UTF-8 add-apt-repository -y ppa:ondrej/php\nsudo apt update\nsudo apt install -yq apache2 php5.6 php5.6-mysql mysql-client\nsudo rm -rf /var/www/html/*\nsudo wget https://github.com/devopsdemoapps/devops-demo/raw/master/devops-demo.tar.gz\nsudo tar -xvzf devops-demo.tar.gz -C /var/www/html/\nsudo wget https://raw.githubusercontent.com/devopsdemoapps/devops-demo/master/devops-demo.sql\nsudo service apache2 restart\n\n\n\n\nfile: main.tf\n\n\n[...]\nresource \naws_instance\n \nwebserver\n {\n  ami                    = \n${var.ami}\n\n  instance_type          = \n${var.instance[\ntype\n]}\n\n  key_name               = \nweb-admin-key\n\n  vpc_security_group_ids = [\n${aws_security_group.webserver_sg.id}\n]\n  depends_on             = [\naws_key_pair.webserver_key\n]\n\n  tags {\n    Name = \n${var.instance[\nname\n]}\n\n  }\n\n  provisioner \nfile\n {\n    source      = \nuser-data.sh\n\n    destination = \n/tmp/user-data.sh\n\n\n    connection {\n      type        = \nssh\n\n      user        = \n${var.ssh_user}\n\n      private_key = \n${file(var.ssh_pvtkey)}\n\n    }\n  }\n}\n[...]\n\n\n\n\nThis \nfile\n type provisioner copies the user-data from our local machine to the remote instance on \n/tmp/user-data.sh\n path. It requires authentication details to scp the file to the machine. Let us set the credentials in our \nvariables.tf\n file.\n\n\nfile: variables.tf\n\n\n[...]\nvariable \nssh_user\n {\n  default = \nubuntu\n\n}\n\nvariable \nssh_pvtkey\n {\n  default = \n~/.ssh/id_rsa\n\n}\n[...]\n\n\n\n\nWe will need to destroy and recreate the resources to apply this provisioner\n\n\nterraform destroy\n\n[output]\nDestroy complete! Resources: 2 destroyed.\n\n\n\n\nterraform apply\n\n[output]\naws_instance.webserver: Still creating... (10s elapsed)\naws_instance.webserver: Still creating... (20s elapsed)\naws_instance.webserver: Still creating... (30s elapsed)\naws_instance.webserver: Provisioning with 'file'...\naws_instance.webserver: Still creating... (40s elapsed)\naws_instance.webserver: Still creating... (50s elapsed)\naws_instance.webserver: Still creating... (1m0s elapsed)\naws_instance.webserver: Still creating... (1m10s elapsed)\naws_instance.webserver: Creation complete after 1m11s (ID: i-02888bbc102c4d0ed)\n\nApply complete! Resources: 3 added, 0 changed, 0 destroyed.\n\nOutputs:\n\nwebserver_ip = 35.173.254.26\n\n\n\n\nRemote-Exec Provisioner\n\n\nNow we will execute the script that we have just copied over.\n\n\nfile: main.tf\n\n\nresource \naws_instance\n \nwebserver\n {\n  ami                    = \n${var.ami}\n\n  instance_type          = \n${var.instance[\ntype\n]}\n\n  key_name               = \nweb-admin-key\n\n  vpc_security_group_ids = [\n${aws_security_group.webserver_sg.id}\n]\n  depends_on             = [\naws_key_pair.webserver_key\n]\n\n  tags {\n    Name = \n${var.instance[\nname\n]}\n\n  }\n\n  provisioner \nfile\n {\n    source      = \nuser-data.sh\n\n    destination = \n/tmp/user-data.sh\n\n\n    connection {\n      type        = \nssh\n\n      user        = \n${var.ssh_user}\n\n      private_key = \n${file(var.ssh_pvtkey)}\n\n    }\n  }\n  provisioner \nremote-exec\n {\n    inline = [\n      \nchmod +x /tmp/user-data.sh\n,\n      \n/tmp/user-data.sh\n,\n    ]\n\n    connection {\n      type        = \nssh\n\n      user        = \n${var.ssh_user}\n\n      private_key = \n${file(var.ssh_pvtkey)}\n\n    }\n  }\n}\n\n\n\n\nWe will also add the ingress policy port \n80\n and egress policy for allo traffic in our security group.\n\n\nfile: main.tf\n\n\n[...]\nresource \naws_security_group\n \nwebserver_sg\n {\n  name = \nwebserver-sg\n\n\n  ingress {\n    from_port   = 22\n    to_port     = 22\n    protocol    = \ntcp\n\n    cidr_blocks = [\n0.0.0.0/0\n]\n  }\n\n  ingress {\n    from_port   = 80\n    to_port     = 80\n    protocol    = \ntcp\n\n    cidr_blocks = [\n0.0.0.0/0\n]\n  }\n\n  egress {\n    from_port   = 0\n    to_port     = 0\n    protocol    = \n-1\n\n    cidr_blocks = [\n0.0.0.0/0\n]\n  }\n}\n[...]\n\n\n\n\nFor this \nremote-exec\n provisioner to take effect, we need to recreate the resources(since these are creation-time provisoners).\n\n\nterraform destroy\n\n[output]\naws_instance.webserver: Still destroying... (ID: i-02888bbc102c4d0ed, 30s elapsed)\naws_instance.webserver: Still destroying... (ID: i-02888bbc102c4d0ed, 40s elapsed)\naws_instance.webserver: Destruction complete after 48s\naws_key_pair.webserver_key: Destroying... (ID: web-admin-key)\naws_security_group.webserver_sg: Destroying... (ID: sg-097c880ffd1c9f6c3)\naws_key_pair.webserver_key: Destruction complete after 1s\naws_security_group.webserver_sg: Destruction complete after 3s\n\nDestroy complete! Resources: 3 destroyed.\n\n\n\n\nterrform apply\n\n[output]\naws_instance.webserver (remote-exec): Connecting to raw.githubusercontent.com (raw.githubusercontent.com)|151.101.200.133|:443... connected.\naws_instance.webserver (remote-exec): HTTP request sent, awaiting response... 200 OK\naws_instance.webserver (remote-exec): Length: 233 [text/plain]\naws_instance.webserver (remote-exec): Saving to: \u2018devops-demo.sql\u2019\n\naws_instance.webserver (remote-exec):  0%  0           --.-K/s\naws_instance.webserver (remote-exec): 100% 233         --.-K/s   in 0s\n\naws_instance.webserver (remote-exec): 2018-09-24 12:36:02 (9.54 MB/s) - \u2018devops-demo.sql\u2019 saved [233/233]\naws_instance.webserver: Creation complete after 5m11s (ID: i-02848bbc106c45ced)\n\nApply complete! Resources: 3 added, 0 changed, 0 destroyed.\n\nOutputs:\n\nwebserver_ip = 35.173.130.100\n\n\n\n\nOnce the creation is complete, you should be able to access the application by visiting the instance's public IP.\n\n\n\n\nWe shall discuss about \nlocal-exec\n provisioner in the next chapter.\n\n\nReference\n\n\nFor more details about provisioners, please visit \nthis link\n.", 
            "title": "Provisioners in detail"
        }, 
        {
            "location": "/07-provisioners/#provisioners", 
            "text": "Provisioners are used to execute scripts either on local machines or on remote machines. \nProvisioners will run at either\n  * Resource creation time , hence called  Creation-Time provisioner  or \n  * Resource destruction time, hence called  Destroy-Time provisioner     Most generally used provisioners are, \n  * file        =  copy file from local to remote\n  * local-exec  =  execute on the machine where you run Terraform commands\n  * remote-exec =  execute on the machine created/modified by Terrform", 
            "title": "Provisioners"
        }, 
        {
            "location": "/07-provisioners/#devops-demo-application", 
            "text": "We will set up  this application  using creation-time provisioner.", 
            "title": "Devops Demo Application"
        }, 
        {
            "location": "/07-provisioners/#file-provisioner", 
            "text": "Create a new file with the name  user-data.sh  touch user-data.sh  file: user-data.sh  #!/bin/bash\nsudo apt update\nsudo apt install -y software-properties-common language-pack-en-base dialog apt-utils\nsudo update-locale LC_ALL=en_US.UTF-8 LANG=en_US.UTF-8\nsudo cp /usr/share/zoneinfo/America/New_York /etc/localtime\nsudo LC_ALL=en_US.UTF-8 add-apt-repository -y ppa:ondrej/php\nsudo apt update\nsudo apt install -yq apache2 php5.6 php5.6-mysql mysql-client\nsudo rm -rf /var/www/html/*\nsudo wget https://github.com/devopsdemoapps/devops-demo/raw/master/devops-demo.tar.gz\nsudo tar -xvzf devops-demo.tar.gz -C /var/www/html/\nsudo wget https://raw.githubusercontent.com/devopsdemoapps/devops-demo/master/devops-demo.sql\nsudo service apache2 restart  file: main.tf  [...]\nresource  aws_instance   webserver  {\n  ami                    =  ${var.ami} \n  instance_type          =  ${var.instance[ type ]} \n  key_name               =  web-admin-key \n  vpc_security_group_ids = [ ${aws_security_group.webserver_sg.id} ]\n  depends_on             = [ aws_key_pair.webserver_key ]\n\n  tags {\n    Name =  ${var.instance[ name ]} \n  }\n\n  provisioner  file  {\n    source      =  user-data.sh \n    destination =  /tmp/user-data.sh \n\n    connection {\n      type        =  ssh \n      user        =  ${var.ssh_user} \n      private_key =  ${file(var.ssh_pvtkey)} \n    }\n  }\n}\n[...]  This  file  type provisioner copies the user-data from our local machine to the remote instance on  /tmp/user-data.sh  path. It requires authentication details to scp the file to the machine. Let us set the credentials in our  variables.tf  file.  file: variables.tf  [...]\nvariable  ssh_user  {\n  default =  ubuntu \n}\n\nvariable  ssh_pvtkey  {\n  default =  ~/.ssh/id_rsa \n}\n[...]  We will need to destroy and recreate the resources to apply this provisioner  terraform destroy\n\n[output]\nDestroy complete! Resources: 2 destroyed.  terraform apply\n\n[output]\naws_instance.webserver: Still creating... (10s elapsed)\naws_instance.webserver: Still creating... (20s elapsed)\naws_instance.webserver: Still creating... (30s elapsed)\naws_instance.webserver: Provisioning with 'file'...\naws_instance.webserver: Still creating... (40s elapsed)\naws_instance.webserver: Still creating... (50s elapsed)\naws_instance.webserver: Still creating... (1m0s elapsed)\naws_instance.webserver: Still creating... (1m10s elapsed)\naws_instance.webserver: Creation complete after 1m11s (ID: i-02888bbc102c4d0ed)\n\nApply complete! Resources: 3 added, 0 changed, 0 destroyed.\n\nOutputs:\n\nwebserver_ip = 35.173.254.26", 
            "title": "File Provisioner"
        }, 
        {
            "location": "/07-provisioners/#remote-exec-provisioner", 
            "text": "Now we will execute the script that we have just copied over.  file: main.tf  resource  aws_instance   webserver  {\n  ami                    =  ${var.ami} \n  instance_type          =  ${var.instance[ type ]} \n  key_name               =  web-admin-key \n  vpc_security_group_ids = [ ${aws_security_group.webserver_sg.id} ]\n  depends_on             = [ aws_key_pair.webserver_key ]\n\n  tags {\n    Name =  ${var.instance[ name ]} \n  }\n\n  provisioner  file  {\n    source      =  user-data.sh \n    destination =  /tmp/user-data.sh \n\n    connection {\n      type        =  ssh \n      user        =  ${var.ssh_user} \n      private_key =  ${file(var.ssh_pvtkey)} \n    }\n  }\n  provisioner  remote-exec  {\n    inline = [\n       chmod +x /tmp/user-data.sh ,\n       /tmp/user-data.sh ,\n    ]\n\n    connection {\n      type        =  ssh \n      user        =  ${var.ssh_user} \n      private_key =  ${file(var.ssh_pvtkey)} \n    }\n  }\n}  We will also add the ingress policy port  80  and egress policy for allo traffic in our security group.  file: main.tf  [...]\nresource  aws_security_group   webserver_sg  {\n  name =  webserver-sg \n\n  ingress {\n    from_port   = 22\n    to_port     = 22\n    protocol    =  tcp \n    cidr_blocks = [ 0.0.0.0/0 ]\n  }\n\n  ingress {\n    from_port   = 80\n    to_port     = 80\n    protocol    =  tcp \n    cidr_blocks = [ 0.0.0.0/0 ]\n  }\n\n  egress {\n    from_port   = 0\n    to_port     = 0\n    protocol    =  -1 \n    cidr_blocks = [ 0.0.0.0/0 ]\n  }\n}\n[...]  For this  remote-exec  provisioner to take effect, we need to recreate the resources(since these are creation-time provisoners).  terraform destroy\n\n[output]\naws_instance.webserver: Still destroying... (ID: i-02888bbc102c4d0ed, 30s elapsed)\naws_instance.webserver: Still destroying... (ID: i-02888bbc102c4d0ed, 40s elapsed)\naws_instance.webserver: Destruction complete after 48s\naws_key_pair.webserver_key: Destroying... (ID: web-admin-key)\naws_security_group.webserver_sg: Destroying... (ID: sg-097c880ffd1c9f6c3)\naws_key_pair.webserver_key: Destruction complete after 1s\naws_security_group.webserver_sg: Destruction complete after 3s\n\nDestroy complete! Resources: 3 destroyed.  terrform apply\n\n[output]\naws_instance.webserver (remote-exec): Connecting to raw.githubusercontent.com (raw.githubusercontent.com)|151.101.200.133|:443... connected.\naws_instance.webserver (remote-exec): HTTP request sent, awaiting response... 200 OK\naws_instance.webserver (remote-exec): Length: 233 [text/plain]\naws_instance.webserver (remote-exec): Saving to: \u2018devops-demo.sql\u2019\n\naws_instance.webserver (remote-exec):  0%  0           --.-K/s\naws_instance.webserver (remote-exec): 100% 233         --.-K/s   in 0s\n\naws_instance.webserver (remote-exec): 2018-09-24 12:36:02 (9.54 MB/s) - \u2018devops-demo.sql\u2019 saved [233/233]\naws_instance.webserver: Creation complete after 5m11s (ID: i-02848bbc106c45ced)\n\nApply complete! Resources: 3 added, 0 changed, 0 destroyed.\n\nOutputs:\n\nwebserver_ip = 35.173.130.100  Once the creation is complete, you should be able to access the application by visiting the instance's public IP.   We shall discuss about  local-exec  provisioner in the next chapter.", 
            "title": "Remote-Exec Provisioner"
        }, 
        {
            "location": "/07-provisioners/#reference", 
            "text": "For more details about provisioners, please visit  this link .", 
            "title": "Reference"
        }, 
        {
            "location": "/08-datasources/", 
            "text": "Data Source\n\n\nData sources are read only information that Terraform can get from Provider's API. When we use data source, Terraform doesn't create/modify anything. It just queries the API, so that the data can be used by other resources.\n\n\nLet us create a RDS DB manually and we will refer to it in our manifest.\n\n\nCreating RDS DB\n\n\n\n\n\n\nGo to RDS service page.\n  \n\n\n\n\n\n\nSelect MySQL DB Engine.\n  \n\n\n\n\n\n\nProvide the DB instance the following name and enter some complex password.\n  \n\n\n\n\n\n\nProvide the following network settings for the instance.\n  \n\n\n\n\n\n\nProvide your DB a name and disable IAM authentication.\n  \n\n\n\n\n\n\nLeave all other values to default and create the DB.\n  \n\n\n\n\n\n\nUsing Datasource\n\n\nLet us add the \ndatasource block\n  for RDS in our \nmain.tf\n\n\nfile: main.tf\n\n\n[...]\ndata \naws_db_instance\n \ndatabase\n {\n  db_instance_identifier = \n${var.rds_name}\n\n}\n\n\n\n\nWe have parameterized the attribute \ndb_instance_identifier\n which is the db instance's name.\n\n\nDefine the variable \nrds_name\n in \nvariables.tf\n.\n\n\nfile: variables.tf\n\n\n[...]\nvariable \nrds_name\n {\n  default = \ndevopsdemo-db\n\n}\n[...]\n\n\n\n\nLet us check whether Terraform is able to fetch the datasource details from AWS API.\n\n\nfile: main.tf\n \n\n\n[...]\noutput \nrds_endpoint\n {\n  value = \n${data.aws_db_instance.database.endpoint}\n\n}\n[...]\n\n\n\n\nLet us plan and apply.\n\n\nterraform plan\nterraform apply\n\n[output]\nAcquiring state lock. This may take a few moments...\naws_security_group.webserver_sg: Refreshing state... (ID: sg-0c740c046e9bcf571)\naws_key_pair.webserver_key: Refreshing state... (ID: web-admin-key)\ndata.aws_db_instance.database: Refreshing state...\naws_instance.webserver: Refreshing state... (ID: i-082d8b9097ae94c53)\n\nApply complete! Resources: 0 added, 0 changed, 0 destroyed.\nReleasing state lock. This may take a few moments...\n\nOutputs:\n\nrds_endpoint = devopsdemo-db.cewjdhpv9lg6.us-east-1.rds.amazonaws.com:3306\nwebserver_ip = 54.165.195.171\n\n\n\n\nWe are able to get the endpoint for a resource which was not created Terraform.\n\n\nWe need to change the placeholder values with our rds db values, from \n/var/www/html/config.ini\n in our instance.\n\n\nfile: main.tf\n\n\n[...]\nresource \nnull_resource\n \npopulate_db_01\n {\n  provisioner \nlocal-exec\n {\n    command = \nssh ubuntu@${aws_instance.webserver.public_ip} 'sudo sed -i -e 's/DBHOST/${data.aws_db_instance.database.address}/g' /var/www/html/config.ini'\n\n  }\n\n  provisioner \nlocal-exec\n {\n    command = \nssh ubuntu@${aws_instance.webserver.public_ip} 'sudo sed -i -e 's/SQLUSER/${data.aws_db_instance.database.master_username}/g' /var/www/html/config.ini'\n\n  }\n\n  provisioner \nlocal-exec\n {\n    command = \nssh ubuntu@${aws_instance.webserver.public_ip} 'sudo sed -i -e 's/SQLPASSWORD/${var.rds_pass}/g' /var/www/html/config.ini'\n\n  }\n\n  provisioner \nlocal-exec\n {\n    command = \nssh ubuntu@${aws_instance.webserver.public_ip} 'sudo sed -i -e 's/SQLDBNAME/${data.aws_db_instance.database.db_name}/g' /var/www/html/config.ini'\n\n  }\n\n  provisioner \nlocal-exec\n {\n    command = \nssh ubuntu@${aws_instance.webserver.public_ip} 'sudo service apache2 restart'\n\n  }\n}\n\n[...]\n\n\n\n\nWe also need to define the \nrds_pass\n variable in \nvariables.tf\n.\n\n\nfile: variables.tf\n\n\n[...]\nvariable \nrds_pass\n {\n  default = \nSup3rS3cr3t\n\n}\n[...]\n\n\n\n\nIn this given example, we introduce a new resource called \nnull\n, which helps us to use \nlocal-exec\n provisioner. \n\n\nWe need to run \nterraform init\n to install the \nnull provider\n plugin.\n\n\nterraform init\n\n[output]\nInitializing the backend...\n\nInitializing provider plugins...\n- Checking for available provider plugins on https://releases.hashicorp.com...\n- Downloading plugin for provider \nnull\n (1.0.0)...\n\nThe following providers do not have any version constraints in configuration,\nso the latest version was installed.\n\nTo prevent automatic upgrades to new major versions that may contain breaking\nchanges, it is recommended to add version = \n...\n constraints to the\ncorresponding provider blocks in configuration, with the constraint strings\nsuggested below.\n\n* provider.aws: version = \n~\n 1.37\n\n* provider.null: version = \n~\n 1.0\n\n\nTerraform has been successfully initialized!\n\nYou may now begin working with Terraform. Try running \nterraform plan\n to see\nany changes that are required for your infrastructure. All Terraform commands\nshould now work.\n\nIf you ever set or change modules or backend configuration for Terraform,\nrerun this command to reinitialize your working directory. If you forget, other\ncommands will detect it and remind you to do so if necessary.\n\n\n\n\nThen run \nterraform plan and apply\n\n\nterraform plan\nterrafomr apply\n\n[output]\n\nAcquiring state lock. This may take a few moments...\naws_key_pair.webserver_key: Refreshing state... (ID: web-admin-key)\naws_security_group.webserver_sg: Refreshing state... (ID: sg-0c740c046e9bcf571)\ndata.aws_db_instance.database: Refreshing state...\naws_instance.webserver: Refreshing state... (ID: i-082d8b9097ae94c53)\n\nAn execution plan has been generated and is shown below.\nResource actions are indicated with the following symbols:\n  + create\n\nTerraform will perform the following actions:\n\n  + null_resource.populate_db_01\n      id: \ncomputed\n\n\n\nPlan: 1 to add, 0 to change, 0 to destroy.\n\nDo you want to perform these actions?\n  Terraform will perform the actions described above.\n  Only 'yes' will be accepted to approve.\n\n  Enter a value: yes\n\n[...]\nnull_resource.populate_db_01: Provisioning with 'local-exec'...\nnull_resource.populate_db_01 (local-exec): Executing: [\n/bin/sh\n \n-c\n \nssh ubuntu@54.165.195.171 'sudo service apache2 restart'\n]\nnull_resource.populate_db_01 (local-exec):  * Restarting web server apache2\nnull_resource.populate_db_01 (local-exec):    ...done.\nnull_resource.populate_db_01: Creation complete after 20s (ID: 8985065039495500214)\n\nApply complete! Resources: 1 added, 0 changed, 1 destroyed.", 
            "title": "Data Sources"
        }, 
        {
            "location": "/08-datasources/#data-source", 
            "text": "Data sources are read only information that Terraform can get from Provider's API. When we use data source, Terraform doesn't create/modify anything. It just queries the API, so that the data can be used by other resources.  Let us create a RDS DB manually and we will refer to it in our manifest.", 
            "title": "Data Source"
        }, 
        {
            "location": "/08-datasources/#creating-rds-db", 
            "text": "Go to RDS service page.\n      Select MySQL DB Engine.\n      Provide the DB instance the following name and enter some complex password.\n      Provide the following network settings for the instance.\n      Provide your DB a name and disable IAM authentication.\n      Leave all other values to default and create the DB.", 
            "title": "Creating RDS DB"
        }, 
        {
            "location": "/08-datasources/#using-datasource", 
            "text": "Let us add the  datasource block   for RDS in our  main.tf  file: main.tf  [...]\ndata  aws_db_instance   database  {\n  db_instance_identifier =  ${var.rds_name} \n}  We have parameterized the attribute  db_instance_identifier  which is the db instance's name.  Define the variable  rds_name  in  variables.tf .  file: variables.tf  [...]\nvariable  rds_name  {\n  default =  devopsdemo-db \n}\n[...]  Let us check whether Terraform is able to fetch the datasource details from AWS API.  file: main.tf    [...]\noutput  rds_endpoint  {\n  value =  ${data.aws_db_instance.database.endpoint} \n}\n[...]  Let us plan and apply.  terraform plan\nterraform apply\n\n[output]\nAcquiring state lock. This may take a few moments...\naws_security_group.webserver_sg: Refreshing state... (ID: sg-0c740c046e9bcf571)\naws_key_pair.webserver_key: Refreshing state... (ID: web-admin-key)\ndata.aws_db_instance.database: Refreshing state...\naws_instance.webserver: Refreshing state... (ID: i-082d8b9097ae94c53)\n\nApply complete! Resources: 0 added, 0 changed, 0 destroyed.\nReleasing state lock. This may take a few moments...\n\nOutputs:\n\nrds_endpoint = devopsdemo-db.cewjdhpv9lg6.us-east-1.rds.amazonaws.com:3306\nwebserver_ip = 54.165.195.171  We are able to get the endpoint for a resource which was not created Terraform.  We need to change the placeholder values with our rds db values, from  /var/www/html/config.ini  in our instance.  file: main.tf  [...]\nresource  null_resource   populate_db_01  {\n  provisioner  local-exec  {\n    command =  ssh ubuntu@${aws_instance.webserver.public_ip} 'sudo sed -i -e 's/DBHOST/${data.aws_db_instance.database.address}/g' /var/www/html/config.ini' \n  }\n\n  provisioner  local-exec  {\n    command =  ssh ubuntu@${aws_instance.webserver.public_ip} 'sudo sed -i -e 's/SQLUSER/${data.aws_db_instance.database.master_username}/g' /var/www/html/config.ini' \n  }\n\n  provisioner  local-exec  {\n    command =  ssh ubuntu@${aws_instance.webserver.public_ip} 'sudo sed -i -e 's/SQLPASSWORD/${var.rds_pass}/g' /var/www/html/config.ini' \n  }\n\n  provisioner  local-exec  {\n    command =  ssh ubuntu@${aws_instance.webserver.public_ip} 'sudo sed -i -e 's/SQLDBNAME/${data.aws_db_instance.database.db_name}/g' /var/www/html/config.ini' \n  }\n\n  provisioner  local-exec  {\n    command =  ssh ubuntu@${aws_instance.webserver.public_ip} 'sudo service apache2 restart' \n  }\n}\n\n[...]  We also need to define the  rds_pass  variable in  variables.tf .  file: variables.tf  [...]\nvariable  rds_pass  {\n  default =  Sup3rS3cr3t \n}\n[...]  In this given example, we introduce a new resource called  null , which helps us to use  local-exec  provisioner.   We need to run  terraform init  to install the  null provider  plugin.  terraform init\n\n[output]\nInitializing the backend...\n\nInitializing provider plugins...\n- Checking for available provider plugins on https://releases.hashicorp.com...\n- Downloading plugin for provider  null  (1.0.0)...\n\nThe following providers do not have any version constraints in configuration,\nso the latest version was installed.\n\nTo prevent automatic upgrades to new major versions that may contain breaking\nchanges, it is recommended to add version =  ...  constraints to the\ncorresponding provider blocks in configuration, with the constraint strings\nsuggested below.\n\n* provider.aws: version =  ~  1.37 \n* provider.null: version =  ~  1.0 \n\nTerraform has been successfully initialized!\n\nYou may now begin working with Terraform. Try running  terraform plan  to see\nany changes that are required for your infrastructure. All Terraform commands\nshould now work.\n\nIf you ever set or change modules or backend configuration for Terraform,\nrerun this command to reinitialize your working directory. If you forget, other\ncommands will detect it and remind you to do so if necessary.  Then run  terraform plan and apply  terraform plan\nterrafomr apply\n\n[output]\n\nAcquiring state lock. This may take a few moments...\naws_key_pair.webserver_key: Refreshing state... (ID: web-admin-key)\naws_security_group.webserver_sg: Refreshing state... (ID: sg-0c740c046e9bcf571)\ndata.aws_db_instance.database: Refreshing state...\naws_instance.webserver: Refreshing state... (ID: i-082d8b9097ae94c53)\n\nAn execution plan has been generated and is shown below.\nResource actions are indicated with the following symbols:\n  + create\n\nTerraform will perform the following actions:\n\n  + null_resource.populate_db_01\n      id:  computed \n\n\nPlan: 1 to add, 0 to change, 0 to destroy.\n\nDo you want to perform these actions?\n  Terraform will perform the actions described above.\n  Only 'yes' will be accepted to approve.\n\n  Enter a value: yes\n\n[...]\nnull_resource.populate_db_01: Provisioning with 'local-exec'...\nnull_resource.populate_db_01 (local-exec): Executing: [ /bin/sh   -c   ssh ubuntu@54.165.195.171 'sudo service apache2 restart' ]\nnull_resource.populate_db_01 (local-exec):  * Restarting web server apache2\nnull_resource.populate_db_01 (local-exec):    ...done.\nnull_resource.populate_db_01: Creation complete after 20s (ID: 8985065039495500214)\n\nApply complete! Resources: 1 added, 0 changed, 1 destroyed.", 
            "title": "Using Datasource"
        }, 
        {
            "location": "/09-terraform-state/", 
            "text": "Terraform State\n\n\nOne advantage, Terraform has over other configuration management tools like Ansible and Chef is State management. Terraform stores/tracks all our infrastructure information(that we have created using Terraform) in a file with the name \nterraform.tfstate\n. \n\n\nIn the last chapter, we have ran \nterraform apply\n. This command would create the above mentioned JSON flavoured statefile. Let us look at its the content.\n\n\nterraform.tfstate\n\n\n{\n    \nversion\n: 3,\n    \nterraform_version\n: \n0.11.7\n,\n    \nserial\n: 1,\n    \nlineage\n: \n138bb0c6-ca69-0d39-aa90-5e08f29c8efb\n,\n    \nmodules\n: [\n        {\n            \npath\n: [\n                \nroot\n\n            ],\n            \noutputs\n: {},\n            \nresources\n: {\n                \naws_instance.webserver\n: {\n                    \ntype\n: \naws_instance\n,\n                    \ndepends_on\n: [],\n                    \nprimary\n: {\n                        \nid\n: \ni-02489cdf638f05bbd\n,\n                        \nattributes\n: {\n                            \nami\n: \nami-408c7f28\n,\n                            \narn\n: \narn:aws:ec2:us-east-1:822941572458:instance/i-02489cdf638f05bbd\n,\n                            \nassociate_public_ip_address\n: \ntrue\n,\n                            \navailability_zone\n: \nus-east-1d\n,\n                            \ncpu_core_count\n: \n1\n,\n                            \ncpu_threads_per_core\n: \n1\n,\n                            \ncredit_specification.#\n: \n1\n,\n                            \ncredit_specification.0.cpu_credits\n: \nstandard\n,\n                            \ndisable_api_termination\n: \nfalse\n,\n                            \nebs_block_device.#\n: \n0\n,\n                            \nebs_optimized\n: \nfalse\n,\n                            \nephemeral_block_device.#\n: \n0\n,\n                            \nget_password_data\n: \nfalse\n,\n                            \niam_instance_profile\n: \n,\n                            \nid\n: \ni-02489cdf638f05bbd\n,\n                            \ninstance_state\n: \nrunning\n,\n                            \ninstance_type\n: \nt1.micro\n,\n                            \nipv6_addresses.#\n: \n0\n,\n                            \nkey_name\n: \n,\n                            \nmonitoring\n: \nfalse\n,\n                            \nnetwork_interface.#\n: \n0\n,\n                            \nnetwork_interface_id\n: \neni-00fbc08209349bb38\n,\n                            \npassword_data\n: \n,\n                            \nplacement_group\n: \n,\n                            \nprimary_network_interface_id\n: \neni-00fbc08209349bb38\n,\n                            \nprivate_dns\n: \nip-172-31-24-184.ec2.internal\n,\n                            \nprivate_ip\n: \n172.31.24.184\n,\n                            \npublic_dns\n: \nec2-34-230-78-138.compute-1.amazonaws.com\n,\n                            \npublic_ip\n: \n34.230.78.138\n,\n                            \nroot_block_device.#\n: \n1\n,\n                            \nroot_block_device.0.delete_on_termination\n: \ntrue\n,\n                            \nroot_block_device.0.iops\n: \n0\n,\n                            \nroot_block_device.0.volume_id\n: \nvol-0cc495c189e5c8dd2\n,\n                            \nroot_block_device.0.volume_size\n: \n8\n,\n                            \nroot_block_device.0.volume_type\n: \nstandard\n,\n                            \nsecurity_groups.#\n: \n1\n,\n                            \nsecurity_groups.3814588639\n: \ndefault\n,\n                            \nsource_dest_check\n: \ntrue\n,\n                            \nsubnet_id\n: \nsubnet-e8b3e6a2\n,\n                            \ntags.%\n: \n0\n,\n                            \ntenancy\n: \ndefault\n,\n                            \nvolume_tags.%\n: \n0\n,\n                            \nvpc_security_group_ids.#\n: \n1\n,\n                            \nvpc_security_group_ids.3314100969\n: \nsg-a42b7ae9\n\n                        },\n                        \nmeta\n: {\n                            \ne2bfb730-ecaa-11e6-8f88-34363bc7c4c0\n: {\n                                \ncreate\n: 600000000000,\n                                \ndelete\n: 1200000000000,\n                                \nupdate\n: 600000000000\n                            },\n                            \nschema_version\n: \n1\n\n                        },\n                        \ntainted\n: false\n                    },\n                    \ndeposed\n: [],\n                    \nprovider\n: \nprovider.aws\n\n                }\n            },\n            \ndepends_on\n: []\n        }\n    ]\n}\n\n\n\n\nUsecase 1\n\n\nThis file contains the metadata of our ec2 instance that we have created in the last chapter. This information will be critical when we have to create \nother resources which references this\n ec2 instance. As we add more resources to the terrform template, this file will get populated with more metadata about each resource.\n\n\nUsecase 2\n\n\nWhat happens when someone manually changes(which is not desirable) the properties of the instance created by Terraform? We can undo the manual changes just by running \nterraform apply\n again. One point to keep in mind though is, some property changes forces resource recreation which might result in data loss.\n\n\nChanges in Terrfaform state\n\n\nLet us see what happens to tfstate file when we destroy the ec2 instance\n\n\nterraform destroy\n\n\n\n\n[output]\naws_instance.webserver: Refreshing state... (ID: i-02489cdf638f05bbd)\n\nAn execution plan has been generated and is shown below.\nResource actions are indicated with the following symbols:\n  - destroy\n\nTerraform will perform the following actions:\n\n  - aws_instance.webserver\n\n\nPlan: 0 to add, 0 to change, 1 to destroy.\n\nDo you really want to destroy?\n  Terraform will destroy all your managed infrastructure, as shown above.\n  There is no undo. Only 'yes' will be accepted to confirm.\n\n  Enter a value: yes\n  [...]\naws_instance.webserver: Still destroying... (ID: i-02489cdf638f05bbd, 1m0s elapsed)\naws_instance.webserver: Destruction complete after 1m0s\n\nDestroy complete! Resources: 1 destroyed.\n\n\n\n\nfile: terraform.tfstate\n\n\n{\n    \nversion\n: 3,\n    \nterraform_version\n: \n0.11.7\n,\n    \nserial\n: 2,\n    \nlineage\n: \n138bb0c6-ca69-0d39-aa90-5e08f29c8efb\n,\n    \nmodules\n: [\n        {\n            \npath\n: [\n                \nroot\n\n            ],\n            \noutputs\n: {},\n            \nresources\n: {},\n            \ndepends_on\n: []\n        }\n    ]\n}\n\n\n\n\nOnce the machine is destroyed, all metadata about that machine is also gone.\n\n\nReferences\n\n\nFor more information about state management in Terraform, please visit \nthis link\n.", 
            "title": "State Management in Terraform"
        }, 
        {
            "location": "/09-terraform-state/#terraform-state", 
            "text": "One advantage, Terraform has over other configuration management tools like Ansible and Chef is State management. Terraform stores/tracks all our infrastructure information(that we have created using Terraform) in a file with the name  terraform.tfstate .   In the last chapter, we have ran  terraform apply . This command would create the above mentioned JSON flavoured statefile. Let us look at its the content.  terraform.tfstate  {\n     version : 3,\n     terraform_version :  0.11.7 ,\n     serial : 1,\n     lineage :  138bb0c6-ca69-0d39-aa90-5e08f29c8efb ,\n     modules : [\n        {\n             path : [\n                 root \n            ],\n             outputs : {},\n             resources : {\n                 aws_instance.webserver : {\n                     type :  aws_instance ,\n                     depends_on : [],\n                     primary : {\n                         id :  i-02489cdf638f05bbd ,\n                         attributes : {\n                             ami :  ami-408c7f28 ,\n                             arn :  arn:aws:ec2:us-east-1:822941572458:instance/i-02489cdf638f05bbd ,\n                             associate_public_ip_address :  true ,\n                             availability_zone :  us-east-1d ,\n                             cpu_core_count :  1 ,\n                             cpu_threads_per_core :  1 ,\n                             credit_specification.# :  1 ,\n                             credit_specification.0.cpu_credits :  standard ,\n                             disable_api_termination :  false ,\n                             ebs_block_device.# :  0 ,\n                             ebs_optimized :  false ,\n                             ephemeral_block_device.# :  0 ,\n                             get_password_data :  false ,\n                             iam_instance_profile :  ,\n                             id :  i-02489cdf638f05bbd ,\n                             instance_state :  running ,\n                             instance_type :  t1.micro ,\n                             ipv6_addresses.# :  0 ,\n                             key_name :  ,\n                             monitoring :  false ,\n                             network_interface.# :  0 ,\n                             network_interface_id :  eni-00fbc08209349bb38 ,\n                             password_data :  ,\n                             placement_group :  ,\n                             primary_network_interface_id :  eni-00fbc08209349bb38 ,\n                             private_dns :  ip-172-31-24-184.ec2.internal ,\n                             private_ip :  172.31.24.184 ,\n                             public_dns :  ec2-34-230-78-138.compute-1.amazonaws.com ,\n                             public_ip :  34.230.78.138 ,\n                             root_block_device.# :  1 ,\n                             root_block_device.0.delete_on_termination :  true ,\n                             root_block_device.0.iops :  0 ,\n                             root_block_device.0.volume_id :  vol-0cc495c189e5c8dd2 ,\n                             root_block_device.0.volume_size :  8 ,\n                             root_block_device.0.volume_type :  standard ,\n                             security_groups.# :  1 ,\n                             security_groups.3814588639 :  default ,\n                             source_dest_check :  true ,\n                             subnet_id :  subnet-e8b3e6a2 ,\n                             tags.% :  0 ,\n                             tenancy :  default ,\n                             volume_tags.% :  0 ,\n                             vpc_security_group_ids.# :  1 ,\n                             vpc_security_group_ids.3314100969 :  sg-a42b7ae9 \n                        },\n                         meta : {\n                             e2bfb730-ecaa-11e6-8f88-34363bc7c4c0 : {\n                                 create : 600000000000,\n                                 delete : 1200000000000,\n                                 update : 600000000000\n                            },\n                             schema_version :  1 \n                        },\n                         tainted : false\n                    },\n                     deposed : [],\n                     provider :  provider.aws \n                }\n            },\n             depends_on : []\n        }\n    ]\n}", 
            "title": "Terraform State"
        }, 
        {
            "location": "/09-terraform-state/#usecase-1", 
            "text": "This file contains the metadata of our ec2 instance that we have created in the last chapter. This information will be critical when we have to create  other resources which references this  ec2 instance. As we add more resources to the terrform template, this file will get populated with more metadata about each resource.", 
            "title": "Usecase 1"
        }, 
        {
            "location": "/09-terraform-state/#usecase-2", 
            "text": "What happens when someone manually changes(which is not desirable) the properties of the instance created by Terraform? We can undo the manual changes just by running  terraform apply  again. One point to keep in mind though is, some property changes forces resource recreation which might result in data loss.", 
            "title": "Usecase 2"
        }, 
        {
            "location": "/09-terraform-state/#changes-in-terrfaform-state", 
            "text": "Let us see what happens to tfstate file when we destroy the ec2 instance  terraform destroy  [output]\naws_instance.webserver: Refreshing state... (ID: i-02489cdf638f05bbd)\n\nAn execution plan has been generated and is shown below.\nResource actions are indicated with the following symbols:\n  - destroy\n\nTerraform will perform the following actions:\n\n  - aws_instance.webserver\n\n\nPlan: 0 to add, 0 to change, 1 to destroy.\n\nDo you really want to destroy?\n  Terraform will destroy all your managed infrastructure, as shown above.\n  There is no undo. Only 'yes' will be accepted to confirm.\n\n  Enter a value: yes\n  [...]\naws_instance.webserver: Still destroying... (ID: i-02489cdf638f05bbd, 1m0s elapsed)\naws_instance.webserver: Destruction complete after 1m0s\n\nDestroy complete! Resources: 1 destroyed.  file: terraform.tfstate  {\n     version : 3,\n     terraform_version :  0.11.7 ,\n     serial : 2,\n     lineage :  138bb0c6-ca69-0d39-aa90-5e08f29c8efb ,\n     modules : [\n        {\n             path : [\n                 root \n            ],\n             outputs : {},\n             resources : {},\n             depends_on : []\n        }\n    ]\n}  Once the machine is destroyed, all metadata about that machine is also gone.", 
            "title": "Changes in Terrfaform state"
        }, 
        {
            "location": "/09-terraform-state/#references", 
            "text": "For more information about state management in Terraform, please visit  this link .", 
            "title": "References"
        }, 
        {
            "location": "/10-backends/", 
            "text": "Backends\n\n\nCreate S3 Bucket\n\n\nFirst create a S3 bucket which is going store the state file. Enable \nversioning\n to enable state recovery if something goes wrong.\n\n\n\n\nCreate a directory called \ndev\n in that bucket.\n\n\n\n\ntouch backend.tf\n\n\n\n\nfile: backend.tf\n\n\nterraform {\n  backend \ns3\n {\n    bucket = \ndevopsdemo-tf-backend\n\n    key    = \n/dev\n\n    region = \nus-east-1\n\n  }\n}\n\n\n\n\nCreate DynamoDB Table for State Locking\n\n\n\n\nUpdate our backend file accordingly.\n\n\nfile: backend.tf\n\n\nterraform {\n  backend \ns3\n {\n    bucket         = \ndevopsdemo-tf-backend\n\n    key            = \ndev\n\n    region         = \nus-east-1\n\n    dynamodb_table = \ndevops-demo-table\n\n  }\n}\n\n\n\n\nInitialize the Backend\n\n\nterraform init\n\n[output]\nInitializing the backend...\nDo you want to copy existing state to the new backend?\n  Pre-existing state was found while migrating the previous \nlocal\n backend to the\n  newly configured \ns3\n backend. No existing state was found in the newly\n  configured \ns3\n backend. Do you want to copy this state to the new \ns3\n\n  backend? Enter \nyes\n to copy and \nno\n to start with an empty state.\n\n  Enter a value: yes\n\n\nSuccessfully configured the backend \ns3\n! Terraform will automatically\nuse this backend unless the backend configuration changes.\n\nInitializing provider plugins...\n\nThe following providers do not have any version constraints in configuration,\nso the latest version was installed.\n\nTo prevent automatic upgrades to new major versions that may contain breaking\nchanges, it is recommended to add version = \n...\n constraints to the\ncorresponding provider blocks in configuration, with the constraint strings\nsuggested below.\n\n* provider.aws: version = \n~\n 1.37\n\n\nTerraform has been successfully initialized!\n\nYou may now begin working with Terraform. Try running \nterraform plan\n to see\nany changes that are required for your infrastructure. All Terraform commands\nshould now work.\n\nIf you ever set or change modules or backend configuration for Terraform,\nrerun this command to reinitialize your working directory. If you forget, other\ncommands will detect it and remind you to do so if necessary.\n\n\n\n\nReference\n\n\nIf you want read more about AWS Remote Backends, follow \nthis link\n.", 
            "title": "Backend and Statelocking"
        }, 
        {
            "location": "/10-backends/#backends", 
            "text": "", 
            "title": "Backends"
        }, 
        {
            "location": "/10-backends/#create-s3-bucket", 
            "text": "First create a S3 bucket which is going store the state file. Enable  versioning  to enable state recovery if something goes wrong.   Create a directory called  dev  in that bucket.   touch backend.tf  file: backend.tf  terraform {\n  backend  s3  {\n    bucket =  devopsdemo-tf-backend \n    key    =  /dev \n    region =  us-east-1 \n  }\n}", 
            "title": "Create S3 Bucket"
        }, 
        {
            "location": "/10-backends/#create-dynamodb-table-for-state-locking", 
            "text": "Update our backend file accordingly.  file: backend.tf  terraform {\n  backend  s3  {\n    bucket         =  devopsdemo-tf-backend \n    key            =  dev \n    region         =  us-east-1 \n    dynamodb_table =  devops-demo-table \n  }\n}", 
            "title": "Create DynamoDB Table for State Locking"
        }, 
        {
            "location": "/10-backends/#initialize-the-backend", 
            "text": "terraform init\n\n[output]\nInitializing the backend...\nDo you want to copy existing state to the new backend?\n  Pre-existing state was found while migrating the previous  local  backend to the\n  newly configured  s3  backend. No existing state was found in the newly\n  configured  s3  backend. Do you want to copy this state to the new  s3 \n  backend? Enter  yes  to copy and  no  to start with an empty state.\n\n  Enter a value: yes\n\n\nSuccessfully configured the backend  s3 ! Terraform will automatically\nuse this backend unless the backend configuration changes.\n\nInitializing provider plugins...\n\nThe following providers do not have any version constraints in configuration,\nso the latest version was installed.\n\nTo prevent automatic upgrades to new major versions that may contain breaking\nchanges, it is recommended to add version =  ...  constraints to the\ncorresponding provider blocks in configuration, with the constraint strings\nsuggested below.\n\n* provider.aws: version =  ~  1.37 \n\nTerraform has been successfully initialized!\n\nYou may now begin working with Terraform. Try running  terraform plan  to see\nany changes that are required for your infrastructure. All Terraform commands\nshould now work.\n\nIf you ever set or change modules or backend configuration for Terraform,\nrerun this command to reinitialize your working directory. If you forget, other\ncommands will detect it and remind you to do so if necessary.", 
            "title": "Initialize the Backend"
        }, 
        {
            "location": "/10-backends/#reference", 
            "text": "If you want read more about AWS Remote Backends, follow  this link .", 
            "title": "Reference"
        }, 
        {
            "location": "/XX-course-outline/", 
            "text": "Goal in mind:\n=============\n  \u2022 Deploy Devops Demo app using Terraform\nOutline:\n========\n  \u2022 providers\n       |---set up credential for AWS provisioner\n       |---show how terraform init works\n  \u2022 backends \n       |---introduction to backends and state locking\n       |---show local state file\n       |---use s3+dynamo db as backend\n  \u2022 resources\n       |---create vpc and subnets\n       |---create one ec2 resource without variables\n  \u2022 variables \n outputs\n       |---introduction to variables\n       |---create RDS resource\n       |---parameterise ec2 template with variables(rds password, db name,user,pw, etc.,)\n       |---print public IP of ec2 instance, rdp endpoints, etc., with outputs\n  \u2022 data sources\n       |---introduction to data sources\n       |---use an existing AMI as reference(frontend installed)\n  \u2022 provisioners\n       |---introduction to provisioner\n       |---file provisioner to copy the script\n       |---remote-exec provisioner to execute the script(set up catalogue)\n  \u2022 modules\n       |---introduction to modules\n       |---create a module which contains ec2 template\n  \u2022 other useful terraform commands(graph, fmt, etc.,)\n  \u2022 terraform with Packer(demo)\n      |---creation of ami with packer\n      |---use that ami in terraform\n  \u2022 terraform with GCP(demo)\n      |---start with GCP provider\n      |---GCP backend setup\n      |---Deployment of mogambo Stack on GCP\n  \u2022 terraform with Azure(demo)\n     |---start with Azure provider\n     |---Azure backend setup\n     |---Deployment of mogambo Stack on Azure\n  \u2022 variable interpolation(conditionals) (advanced)\n  \u2022 terraform enterprise(advanced)\n  \u2022 import(advanced)\n  \u2022 templates(advanced)\n  \u2022 plugin development(advanced)", 
            "title": "Course Outline"
        }
    ]
}