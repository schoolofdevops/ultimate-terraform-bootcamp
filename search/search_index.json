{
    "docs": [
        {
            "location": "/", 
            "text": "Welcome to MkDocs\n\n\nFor full documentation visit \nmkdocs.org\n.\n\n\nCommands\n\n\n\n\nmkdocs new [dir-name]\n - Create a new project.\n\n\nmkdocs serve\n - Start the live-reloading docs server.\n\n\nmkdocs build\n - Build the documentation site.\n\n\nmkdocs help\n - Print this help message.\n\n\n\n\nProject layout\n\n\nmkdocs.yml    # The configuration file.\ndocs/\n    index.md  # The documentation homepage.\n    ...       # Other markdown pages, images and other files.", 
            "title": "Home"
        }, 
        {
            "location": "/#welcome-to-mkdocs", 
            "text": "For full documentation visit  mkdocs.org .", 
            "title": "Welcome to MkDocs"
        }, 
        {
            "location": "/#commands", 
            "text": "mkdocs new [dir-name]  - Create a new project.  mkdocs serve  - Start the live-reloading docs server.  mkdocs build  - Build the documentation site.  mkdocs help  - Print this help message.", 
            "title": "Commands"
        }, 
        {
            "location": "/#project-layout", 
            "text": "mkdocs.yml    # The configuration file.\ndocs/\n    index.md  # The documentation homepage.\n    ...       # Other markdown pages, images and other files.", 
            "title": "Project layout"
        }, 
        {
            "location": "/00-environment-setup/", 
            "text": "", 
            "title": "Setting up the environment"
        }, 
        {
            "location": "/01-getting-started/", 
            "text": "Getting started with Terraform\n\n\nTerraform Commands\n\n\nYou can check the list of commands for Terraform by running, \n\n\nterrform -h\n\n\nbash-root$ terraform -h\nsage: terraform [--version] [--help] \ncommand\n [args]\n\nThe available commands for execution are listed below.\nThe most common, useful commands are shown first, followed by\nless common or more advanced commands. If you're just getting\nstarted with Terraform, stick with the common commands. For the\nother commands, please read the help and docs before usage.\n\nCommon commands:\n    apply              Builds or changes infrastructure\n    console            Interactive console for Terraform interpolations\n    destroy            Destroy Terraform-managed infrastructure\n    env                Workspace management\n    fmt                Rewrites config files to canonical format\n    get                Download and install modules for the configuration\n    graph              Create a visual graph of Terraform resources\n    import             Import existing infrastructure into Terraform\n    init               Initialize a Terraform working directory\n    output             Read an output from a state file\n    plan               Generate and show an execution plan\n    providers          Prints a tree of the providers used in the configuration\n    push               Upload this Terraform module to Atlas to run\n    refresh            Update local state file against real resources\n    show               Inspect Terraform state or plan\n    taint              Manually mark a resource for recreation\n    untaint            Manually unmark a resource as tainted\n    validate           Validates the Terraform files\n    version            Prints the Terraform version\n    workspace          Workspace management\n\nAll other commands:\n    debug              Debug output management (experimental)\n    force-unlock       Manually unlock the terraform state\n    state              Advanced state management\n\n\n\n\nFrom those commands, the following are important.\n\n\nterraform plan\nterraform apply\nterraform destroy\nterraform init\nterraform fmt\n\n\n\n\nProviders\n\n\nProviders are a way to define where you want to create your infrastructure. Usually Providers are,\n\n\n\n\nIaaS\n\n\nPaaS\n\n\nSaaS\n\n\n\n\nMostly we will be using IaaS providers(Ex: AWS, Azure, GCP, etc.,)\n\n\nEx: AWS Provider\n\n\nprovider \naws\n {\n  region = \nus-east-1\n\n}\n\n\n\n\nResources\n\n\nResources are the different entities you want to create on given provider. As an example, for AWS provider, if you want to create an EC2 machine, you have to create the following resource.\n\n\nEx: EC2 Resource\n\n\nresource \naws_instance\n \nweb\n {\n  ami           = \nami-04169656fea786776\n\n  instance_type = \nt2.micro\n\n  key_name      = \nschoolofdevops\n\n\n  tags {\n    Name = \nterraform-second-machine\n\n  }\n}", 
            "title": "Getting Started"
        }, 
        {
            "location": "/01-getting-started/#getting-started-with-terraform", 
            "text": "", 
            "title": "Getting started with Terraform"
        }, 
        {
            "location": "/01-getting-started/#terraform-commands", 
            "text": "You can check the list of commands for Terraform by running,   terrform -h  bash-root$ terraform -h\nsage: terraform [--version] [--help]  command  [args]\n\nThe available commands for execution are listed below.\nThe most common, useful commands are shown first, followed by\nless common or more advanced commands. If you're just getting\nstarted with Terraform, stick with the common commands. For the\nother commands, please read the help and docs before usage.\n\nCommon commands:\n    apply              Builds or changes infrastructure\n    console            Interactive console for Terraform interpolations\n    destroy            Destroy Terraform-managed infrastructure\n    env                Workspace management\n    fmt                Rewrites config files to canonical format\n    get                Download and install modules for the configuration\n    graph              Create a visual graph of Terraform resources\n    import             Import existing infrastructure into Terraform\n    init               Initialize a Terraform working directory\n    output             Read an output from a state file\n    plan               Generate and show an execution plan\n    providers          Prints a tree of the providers used in the configuration\n    push               Upload this Terraform module to Atlas to run\n    refresh            Update local state file against real resources\n    show               Inspect Terraform state or plan\n    taint              Manually mark a resource for recreation\n    untaint            Manually unmark a resource as tainted\n    validate           Validates the Terraform files\n    version            Prints the Terraform version\n    workspace          Workspace management\n\nAll other commands:\n    debug              Debug output management (experimental)\n    force-unlock       Manually unlock the terraform state\n    state              Advanced state management  From those commands, the following are important.  terraform plan\nterraform apply\nterraform destroy\nterraform init\nterraform fmt", 
            "title": "Terraform Commands"
        }, 
        {
            "location": "/01-getting-started/#providers", 
            "text": "Providers are a way to define where you want to create your infrastructure. Usually Providers are,   IaaS  PaaS  SaaS   Mostly we will be using IaaS providers(Ex: AWS, Azure, GCP, etc.,)  Ex: AWS Provider  provider  aws  {\n  region =  us-east-1 \n}", 
            "title": "Providers"
        }, 
        {
            "location": "/01-getting-started/#resources", 
            "text": "Resources are the different entities you want to create on given provider. As an example, for AWS provider, if you want to create an EC2 machine, you have to create the following resource.  Ex: EC2 Resource  resource  aws_instance   web  {\n  ami           =  ami-04169656fea786776 \n  instance_type =  t2.micro \n  key_name      =  schoolofdevops \n\n  tags {\n    Name =  terraform-second-machine \n  }\n}", 
            "title": "Resources"
        }, 
        {
            "location": "/02-terraform-important-commands/", 
            "text": "Important Terraform Commands\n\n\nTerraform Plan\n\n\nWhen you run \nterraform plan\n it will present you with the \nexecution plan", 
            "title": "Important Commands"
        }, 
        {
            "location": "/02-terraform-important-commands/#important-terraform-commands", 
            "text": "", 
            "title": "Important Terraform Commands"
        }, 
        {
            "location": "/02-terraform-important-commands/#terraform-plan", 
            "text": "When you run  terraform plan  it will present you with the  execution plan", 
            "title": "Terraform Plan"
        }, 
        {
            "location": "/03-providers/", 
            "text": "Providers\n\n\nIn Terraform, Providers are responsible for understanding API interactions from IaaS(AWS, Azure, etc.,), PaaS(Heroku) or SaaS(CloudFlare, DNSSimple, DNSMadeEasy, etc.,). \n\n\nExample Provider\n\n\nLet's look at AWS Provider as an example.\n\n\nprovider \naws\n {\n  access_key = \n${var.aws_access_key}\n\n  secret_key = \n${var.aws_secret_key}\n\n  region     = \nus-east-1\n\n}\n\n\n\n\nAs seen in the above given example, Provider is a way to instruct Terraform to interact with AWS API. Every provider needs some kind of credentials to get authenticated with the API. In our example, we have porvided AWS access key and secret key to perform the same. \n\n\nSetting up our environment for AWS\n\n\nLet us set up our environment by creating a directory called \naws\n.\n\n\nmkdir aws\ncd aws\n\n\n\n\nAfter changing directory into \naws\n, we need to create a file named \nmain.tf\n.\n\n\ntouch main.tf\n\n\n\n\nDefine your Provider details in this main manifest. Change the region if you want to create the resources elsewhere.\n\n\nprovider \naws\n {\n  region = \nus-east-1\n\n}\n\n\n\n\nExport your AWS access and secret keys as environment variables.\n\n\nexport AWS_ACCESS_KEY_ID=\nAKIAI3NYUWMNORYTDYBC\n\nexport AWS_SECRET_ACCESS_KEY=\ntoOh/ejVKe44wx3ujr7scaehdy4\n\n\n\n\n\nFinally run the following command to initialize your environment.\n\n\nterraform init\n\n[output]\nInitializing provider plugins...\n- Checking for available provider plugins on https://releases.hashicorp.com...\n- Downloading plugin for provider \naws\n (1.37.0)...\n\nThe following providers do not have any version constraints in configuration,\nso the latest version was installed.\n\nTo prevent automatic upgrades to new major versions that may contain breaking\nchanges, it is recommended to add version = \n...\n constraints to the\ncorresponding provider blocks in configuration, with the constraint strings\nsuggested below.\n\n* provider.aws: version = \n~\n 1.37\n\n\nTerraform has been successfully initialized!\n\nYou may now begin working with Terraform. Try running \nterraform plan\n to see\nany changes that are required for your infrastructure. All Terraform commands\nshould now work.\n\nIf you ever set or change modules or backend configuration for Terraform,\nrerun this command to reinitialize your working directory. If you forget, other\ncommands will detect it and remind you to do so if necessary.\n\n\n\n\nThis should initialize the environment for our course.\n\n\nReference\n\n\nIf you want to learn more about providers, you can visit \nthis link\n.", 
            "title": "Terraform Providers"
        }, 
        {
            "location": "/03-providers/#providers", 
            "text": "In Terraform, Providers are responsible for understanding API interactions from IaaS(AWS, Azure, etc.,), PaaS(Heroku) or SaaS(CloudFlare, DNSSimple, DNSMadeEasy, etc.,).", 
            "title": "Providers"
        }, 
        {
            "location": "/03-providers/#example-provider", 
            "text": "Let's look at AWS Provider as an example.  provider  aws  {\n  access_key =  ${var.aws_access_key} \n  secret_key =  ${var.aws_secret_key} \n  region     =  us-east-1 \n}  As seen in the above given example, Provider is a way to instruct Terraform to interact with AWS API. Every provider needs some kind of credentials to get authenticated with the API. In our example, we have porvided AWS access key and secret key to perform the same.", 
            "title": "Example Provider"
        }, 
        {
            "location": "/03-providers/#setting-up-our-environment-for-aws", 
            "text": "Let us set up our environment by creating a directory called  aws .  mkdir aws\ncd aws  After changing directory into  aws , we need to create a file named  main.tf .  touch main.tf  Define your Provider details in this main manifest. Change the region if you want to create the resources elsewhere.  provider  aws  {\n  region =  us-east-1 \n}  Export your AWS access and secret keys as environment variables.  export AWS_ACCESS_KEY_ID= AKIAI3NYUWMNORYTDYBC \nexport AWS_SECRET_ACCESS_KEY= toOh/ejVKe44wx3ujr7scaehdy4   Finally run the following command to initialize your environment.  terraform init\n\n[output]\nInitializing provider plugins...\n- Checking for available provider plugins on https://releases.hashicorp.com...\n- Downloading plugin for provider  aws  (1.37.0)...\n\nThe following providers do not have any version constraints in configuration,\nso the latest version was installed.\n\nTo prevent automatic upgrades to new major versions that may contain breaking\nchanges, it is recommended to add version =  ...  constraints to the\ncorresponding provider blocks in configuration, with the constraint strings\nsuggested below.\n\n* provider.aws: version =  ~  1.37 \n\nTerraform has been successfully initialized!\n\nYou may now begin working with Terraform. Try running  terraform plan  to see\nany changes that are required for your infrastructure. All Terraform commands\nshould now work.\n\nIf you ever set or change modules or backend configuration for Terraform,\nrerun this command to reinitialize your working directory. If you forget, other\ncommands will detect it and remind you to do so if necessary.  This should initialize the environment for our course.", 
            "title": "Setting up our environment for AWS"
        }, 
        {
            "location": "/03-providers/#reference", 
            "text": "If you want to learn more about providers, you can visit  this link .", 
            "title": "Reference"
        }, 
        {
            "location": "/04-resources-part1/", 
            "text": "Resources\n\n\nResources are the building block in Terraform. These the actual cloud entities that you are either creating/deleting or modifying. To do so, you will have to define them in a terraform manifest and apply them. \n\n\nCreating our first Resource\n\n\nLet us create an EC2 instance, which is going to be our first resource on AWS using Terraform. \n\n\nEvery resorce has the following syntax.\n\n\nresource syntax\n\n\nresource \nresource_type\n \nresource_name\n {\n  config1 = value1\n  config2 = value2\n}\n\n\n\n\nHere, \n  resource_type = The type of the resouce that we create/delete/modfiy\n  resource_name = Give the resource a name for Terraform internal references.\n  config(1-n)   = The properties of the reosurce your manipulating.\n\n\nIn your main.tf, add this block next to your Provider definition. \n\n\nan ec2 resource\n\n\nresource \naws_instance\n \nwebserver\n {\n  ami           = \nami-408c7f28\n\n  instance_type = \nt1.micro\n\n}\n\n\n\n\nHere, to compare it with the syntax,\n  resource_type = aws_instance\n  resource_name = webserver\n  config1       = ami\n  value1        = ami-408c7f28(ubuntu-14.04)\n  config2       = instance_type\n  value2        = t1.micro\n\n\nYour \nmain.tf\n file should look like the following. \n\n\nprovider \naws\n {\n  region = \nus-east-1\n\n}\n\nresource \naws_instance\n \nwebserver\n {\n  ami           = \nami-408c7f28\n\n  instance_type = \nt1.micro\n\n}\n\n\n\n\nTerraform Plan\n\n\nThen run \nterraform plan\n to see what will happen if we apply the manifest.\n\n\nterraform plan\n\n[output]\nRefreshing Terraform state in-memory prior to plan...\nThe refreshed state will be used to calculate this plan, but will not be\npersisted to local or remote state storage.\n\n\n------------------------------------------------------------------------\n\nAn execution plan has been generated and is shown below.\nResource actions are indicated with the following symbols:\n  + create\n\nTerraform will perform the following actions:\n\n  + aws_instance.webserver\n      id:                           \ncomputed\n\n      ami:                          \nami-408c7f28\n\n      arn:                          \ncomputed\n\n      associate_public_ip_address:  \ncomputed\n\n      availability_zone:            \ncomputed\n\n      cpu_core_count:               \ncomputed\n\n      cpu_threads_per_core:         \ncomputed\n\n      ebs_block_device.#:           \ncomputed\n\n      ephemeral_block_device.#:     \ncomputed\n\n      get_password_data:            \nfalse\n\n      instance_state:               \ncomputed\n\n      instance_type:                \nt1.micro\n\n[...]\n\nPlan: 1 to add, 0 to change, 0 to destroy.\n\n------------------------------------------------------------------------\n\nNote: You didn't specify an \n-out\n parameter to save this plan, so Terraform\ncan't guarantee that exactly these actions will be performed if\n\nterraform apply\n is subsequently run.\n\n\n\n\nTerraform Apply\n\n\nThen run, \nterraform apply\n to actually create the resource on AWS.\n\n\nterraform apply\n\n[output]\n[...]\naws_instance.webserver: Still creating... (10s elapsed)\naws_instance.webserver: Still creating... (20s elapsed)\naws_instance.webserver: Still creating... (30s elapsed)\naws_instance.webserver: Still creating... (40s elapsed)\naws_instance.webserver: Creation complete after 49s (ID: i-02489cdf638f05bbd)\n\nApply complete! Resources: 1 added, 0 changed, 0 destroyed.\n\n\n\n\nWe have successfully created our first reosource on AWS. Please check your AWS console to check the properties(AMI and instance type) of the machine.\n\n\n\n\nReference\n\n\nIf you need further details about resources, please visit this \nlink", 
            "title": "Terraform Building Blocks - Part 1"
        }, 
        {
            "location": "/04-resources-part1/#resources", 
            "text": "Resources are the building block in Terraform. These the actual cloud entities that you are either creating/deleting or modifying. To do so, you will have to define them in a terraform manifest and apply them.", 
            "title": "Resources"
        }, 
        {
            "location": "/04-resources-part1/#creating-our-first-resource", 
            "text": "Let us create an EC2 instance, which is going to be our first resource on AWS using Terraform.   Every resorce has the following syntax.  resource syntax  resource  resource_type   resource_name  {\n  config1 = value1\n  config2 = value2\n}  Here, \n  resource_type = The type of the resouce that we create/delete/modfiy\n  resource_name = Give the resource a name for Terraform internal references.\n  config(1-n)   = The properties of the reosurce your manipulating.  In your main.tf, add this block next to your Provider definition.   an ec2 resource  resource  aws_instance   webserver  {\n  ami           =  ami-408c7f28 \n  instance_type =  t1.micro \n}  Here, to compare it with the syntax,\n  resource_type = aws_instance\n  resource_name = webserver\n  config1       = ami\n  value1        = ami-408c7f28(ubuntu-14.04)\n  config2       = instance_type\n  value2        = t1.micro  Your  main.tf  file should look like the following.   provider  aws  {\n  region =  us-east-1 \n}\n\nresource  aws_instance   webserver  {\n  ami           =  ami-408c7f28 \n  instance_type =  t1.micro \n}", 
            "title": "Creating our first Resource"
        }, 
        {
            "location": "/04-resources-part1/#terraform-plan", 
            "text": "Then run  terraform plan  to see what will happen if we apply the manifest.  terraform plan\n\n[output]\nRefreshing Terraform state in-memory prior to plan...\nThe refreshed state will be used to calculate this plan, but will not be\npersisted to local or remote state storage.\n\n\n------------------------------------------------------------------------\n\nAn execution plan has been generated and is shown below.\nResource actions are indicated with the following symbols:\n  + create\n\nTerraform will perform the following actions:\n\n  + aws_instance.webserver\n      id:                            computed \n      ami:                           ami-408c7f28 \n      arn:                           computed \n      associate_public_ip_address:   computed \n      availability_zone:             computed \n      cpu_core_count:                computed \n      cpu_threads_per_core:          computed \n      ebs_block_device.#:            computed \n      ephemeral_block_device.#:      computed \n      get_password_data:             false \n      instance_state:                computed \n      instance_type:                 t1.micro \n[...]\n\nPlan: 1 to add, 0 to change, 0 to destroy.\n\n------------------------------------------------------------------------\n\nNote: You didn't specify an  -out  parameter to save this plan, so Terraform\ncan't guarantee that exactly these actions will be performed if terraform apply  is subsequently run.", 
            "title": "Terraform Plan"
        }, 
        {
            "location": "/04-resources-part1/#terraform-apply", 
            "text": "Then run,  terraform apply  to actually create the resource on AWS.  terraform apply\n\n[output]\n[...]\naws_instance.webserver: Still creating... (10s elapsed)\naws_instance.webserver: Still creating... (20s elapsed)\naws_instance.webserver: Still creating... (30s elapsed)\naws_instance.webserver: Still creating... (40s elapsed)\naws_instance.webserver: Creation complete after 49s (ID: i-02489cdf638f05bbd)\n\nApply complete! Resources: 1 added, 0 changed, 0 destroyed.  We have successfully created our first reosource on AWS. Please check your AWS console to check the properties(AMI and instance type) of the machine.", 
            "title": "Terraform Apply"
        }, 
        {
            "location": "/04-resources-part1/#reference", 
            "text": "If you need further details about resources, please visit this  link", 
            "title": "Reference"
        }, 
        {
            "location": "/05-resources-part2/", 
            "text": "Resources - Part 2\n\n\nThe ec2 instance that we have created is not that useful when we don't have access to it. So let us delete it and  we shall set up this again with additional resources. \n\n\nLet us create a security group, which allows us to ssh(port 22) into the machine.\n\n\nfile: main.tf\n\n\nprovider \naws\n {\n  region = \nus-east-1\n\n}\n\nresource \naws_instance\n \nwebserver\n {\n  ami           = \nami-408c7f28\n\n  instance_type = \nt1.micro\n\n}\n\nresource \naws_security_group\n \nwebserver_sg\n {\n\n    name = \nwebserver-sg\n\n\n    ingress {\n        from_port   = 22\n        to_port     = 22\n        protocol    = \ntcp\n\n        cidr_blocks = [\n0.0.0.0/0\n]\n    }\n}\n\n\n\n\nHere,\n  Resource type = aws_security_group,\n  Resource name = webserver_sg\n\n\nThis \naws_security_group\n resource allows us to ssh into the instance.\n\n\nWe need to create the EC2 instance with this security group. To do that, \n\n\nThe final requirement is a \nkey pair\n using which we can login to the machine. Let us use \naws_key_pair\n to register the key with AWS and then use in our ec2 instance.\n\n\nTo do this, you will need to create a key pair in your local machine. Run the following commands. This will create one public key and a private key.\n\n\nroot@vibe$ ssh-keygen -t rsa\n\n[output]\nGenerating public/private rsa key pair.\nEnter file in which to save the key (/home/vibe/.ssh/id_rsa):\nEnter passphrase (empty for no passphrase):\nEnter same passphrase again:\nYour identification has been saved in /home/vibe/.ssh/id_rsa.\nYour public key has been saved in /home/vibe/.ssh/id_rsa.pub.\nThe key fingerprint is:\nSHA256:nSnSLKDvnLv22LFX+wKYMa0TvSt3AL406z+Asj/GSak vibe@vibes-MacBook-Air.local\nThe key's randomart image is:\n+---[RSA 2048]----+\n|                 |\n|                 |\n|    .  o         |\n|   . .=oo. o     |\n|  .  +oOS.+      |\n|  ..+ Xo+..      |\n|   *.o.* = .     |\n|  Eo*++o= +      |\n|   +O*==.o o.    |\n+----[SHA256]-----+\n\n\n\n\nCopy the content of your public key\n\n\ncat ~/.ssh/id_rsa.pub\n\n[output]\nssh-rsa AAAAB3NzaC1yc2EAAAADAQABAAABAQC4Q2TBuAD7ijkPjp+/Hl/QnrNo4hoZEz/l+UBsfvlDuJk8zfh0ivnQLtoYyXNuJ3/BjTVVIchrGo8CLZdTco//n+YBvMqgW4Wg5F92JNNkR5L5x04ELRUmC3ed1ZqbwrLmujzB33nMJ8Ld5dJjtS55KJa5MwkCaP7lqGicU2NgXe+if2DhCKW/lZyCpkkvRgmB7oEqj6aBWNjp+FMY4v6BtcmmB/+1Ry+GMvmZJO1EjSeUHAWCec3snX7TxJKHf4opwTHxknmhRKkz8+pS8rxyjiBeyncxP9jL9Tx/Zh6qmExCUfuhAWk87sjbb3j0enVs2LtzJOG9eBZ726wD83TJ vibe@vibes-MacBook-Air.local\n\n\n\n\nPaste the content of public key in the public_key\n\n\nfile: main.tf\n\n\n[...]\n\nresource \naws_security_group\n \nwebserver_sg\n {\n\n    name = \nwebserver-sg\n\n\n    ingress {\n        from_port   = 22\n        to_port     = 22\n        protocol    = \ntcp\n\n        cidr_blocks = [\n0.0.0.0/0\n]\n    }\n}\n\nresource \naws_key_pair\n \nwebserver_key\n {\n  key_name   = \nweb-admin-key\n\n  public_key = \nssh-rsa sh-rsa AAAAB3NzaC1yc2EAAAADAQABAAABAQC4Q2TBuAD7ijkPjp+/Hl/QnrNo4hoZEz/l+UBsfvlDuJk8zfh0ivnQLtoYyXNuJ3/BjTVVIchrGo8CLZdTco//n+YBvMqgW4Wg5F92JNNkR5L5x04ELRUmC3ed1ZqbwrLmujzB33nMJ8Ld5dJjtS55KJa5MwkCaP7lqGicU2NgXe+if2DhCKW/lZyCpkkvRgmB7oEqj6aBWNjp+FMY4v6BtcmmB/+1Ry+GMvmZJO1EjSeUHAWCec3snX7TxJKHf4opwTHxknmhRKkz8+pS8rxyjiBeyncxP9jL9Tx/Zh6qmExCUfuhAWk87sjbb3j0enVs2LtzJOG9eBZ726wD83TJ vibe@vibes-MacBook-Air.local\n}\n\n\n\n\nWe need to make sure our instance uses this key. To do that, we should add one more attribute to our \naws_instance\n module. We will also tag the instace with a name.\n\n\nfile: main.tf\n\n\nprovider \naws\n {\n  region = \nus-east-1\n\n}\n\nresource \naws_instance\n \nwebserver\n {\n  ami           = \nami-408c7f28\n\n  instance_type = \nt1.micro\n\n  key_name      = \nweb-admin-key\n\n\n  tags {\n    Name = \nweberserver\n\n  }\n}\n\n[...]\n\n\n\n\nThe final file shoudl look like the following.\n\n\nprovider \naws\n {\n  region = \nus-east-1\n\n}\n\nresource \naws_instance\n \nwebserver\n {\n  ami           = \nami-408c7f28\n\n  instance_type = \nt1.micro\n\n  key_name      = \nweb-admin-key\n\n\n  tags {\n    Name = \nweberserver\n\n  }\n}\n\nresource \naws_security_group\n \nwebserver_sg\n {\n\n        name = \nwebserver-sg\n\n\n        ingress {\n                from_port   = 22\n                to_port     = 22\n                protocol    = \ntcp\n\n                cidr_blocks = [\n0.0.0.0/0\n]\n        }\n}\n\nresource \naws_key_pair\n \nwebserver_key\n {\n  key_name   = \nweb-admin-key\n\n  public_key = \nssh-rsa sh-rsa AAAAB3NzaC1yc2EAAAADAQABAAABAQC4Q2TBuAD7ijkPjp+/Hl/QnrNo4hoZEz/l+UBsfvlDuJk8zfh0ivnQLtoYyXNuJ3/BjTVVIchrGo8CLZdTco//n+YBvMqgW4Wg5F92JNNkR5L5x04ELRUmC3ed1ZqbwrLmujzB33nMJ8Ld5dJjtS55KJa5MwkCaP7lqGicU2NgXe+if2DhCKW/lZyCpkkvRgmB7oEqj6aBWNjp+FMY4v6BtcmmB/+1Ry+GMvmZJO1EjSeUHAWCec3snX7TxJKHf4opwTHxknmhRKkz8+pS8rxyjiBeyncxP9jL9Tx/Zh6qmExCUfuhAWk87sjbb3j0enVs2LtzJOG9eBZ726wD83TJ vibe@vibes-MacBook-Air.local\n\n}\n\n\n\n\nExplicit Dependency\n\n\nWhen we apply the manifest, we will get the following error.\n\n\nterraform apply\n\n[output]\naws_security_group.webserver_sg: Still creating... (10s elapsed)\naws_security_group.webserver_sg: Creation complete after 11s (ID: sg-0c22a3497351d1caa)\n\nError: Error applying plan:\n\n2 error(s) occurred:\n\n* aws_instance.webserver: 1 error(s) occurred:\n\n* aws_instance.webserver: Error launching source instance: InvalidKeyPair.NotFound: The key pair 'web-admin-key' does not exist\n    status code: 400, request id: 36af6c0c-9016-4dc4-bd3a-7b94fc3dfade\n* aws_key_pair.webserver_key: 1 error(s) occurred:\n\n* aws_key_pair.webserver_key: Error import KeyPair: InvalidKey.Format: Key is not in valid OpenSSH public key format\n    status code: 400, request id: 8a3697d2-4450-4150-86e0-3b75c0d43b80\n\nTerraform does not automatically rollback in the face of errors.\nInstead, your Terraform state file has been partially updated with\nany resources that successfully completed. Please address the error\nabove and apply again to incrementally change your infrastructure.\n\n\n\n\nThis is because, the ec2 resource tries to use the key even before it is created. We can control the order of execution in two ways.\n  1. Implicit Dependecy (Automatic Dependency)\n\n  2. Explicit Dependency (Manual Dependency)  \n\n\nWe will learn more about \nImplicit Dependency\n in the next chapter. Now we will focus on adding \nExplicit Dependency\n to \naws_instance\n resource to depend on \naws_key_pair\n resource.\n\n\nThis will guarantee the creation of key pair before the instance get's created. In your instance block add the following,\n\n\nfile: main.tf\n\n\n[...]\nresource \naws_instance\n \nwebserver\n {\n  ami           = \nami-408c7f28\n\n  instance_type = \nt1.micro\n\n  key_name      = \nweb-admin-key\n\n\n  depends_on = [\naws_key_pair.webserver_key\n]\n  tags {\n    Name = \nweberserver\n\n  }\n}\n[...]\n\n\n\n\nSyntax: \ndepends_on = [\"resource_type.resource_name\"]\n\n\nIdempotency\n\n\nFinally apply the manifest by running,\n\n\nterraform apply\n\n[output]\nPlan: 2 to add, 0 to change, 0 to destroy.\n\nDo you want to perform these actions?\n  Terraform will perform the actions described above.\n  Only 'yes' will be accepted to approve.\n\n  Enter a value: yes\n\naws_key_pair.webserver_key: Creating...\n  fingerprint: \n =\n \ncomputed\n\n  key_name:    \n =\n \nweb-admin-key\n\n  public_key:  \n =\n \nssh-rsa AAAAB3NzaC1yc2EAAAADAQABAAABAQC4Q2TBuAD7ijkPjp+/Hl/QnrNo4hoZEz/l+UBsfvlDuJk8zfh0ivnQLtoYyXNuJ3/BjTVVIchrGo8CLZdTco//n+YBvMqgW4Wg5F92JNNkR5L5x04ELRUmC3ed1ZqbwrLmujzB33nMJ8Ld5dJjtS55KJa5MwkCaP7lqGicU2NgXe+if2DhCKW/lZyCpkkvRgmB7oEqj6aBWNjp+FMY4v6BtcmmB/+1Ry+GMvmZJO1EjSeUHAWCec3snX7TxJKHf4opwTHxknmhRKkz8+pS8rxyjiBeyncxP9jL9Tx/Zh6qmExCUfuhAWk87sjbb3j0enVs2LtzJOG9eBZ726wD83TJ vibe@vibes-MacBook-Air.local\n\naws_key_pair.webserver_key: Creation complete after 3s (ID: web-admin-key)\naws_instance.webserver: Creating...\n  ami:                          \n =\n \nami-408c7f28\n\n  arn:                          \n =\n \ncomputed\n\n  associate_public_ip_address:  \n =\n \ncomputed\n\n  availability_zone:            \n =\n \ncomputed\n\n  cpu_core_count:               \n =\n \ncomputed\n\n  cpu_threads_per_core:         \n =\n \ncomputed\n\n  ebs_block_device.#:           \n =\n \ncomputed\n\n  ephemeral_block_device.#:     \n =\n \ncomputed\n\n  get_password_data:            \n =\n \nfalse\n\n  instance_state:               \n =\n \ncomputed\n\n  instance_type:                \n =\n \nt1.micro\n\n  ipv6_address_count:           \n =\n \ncomputed\n\n  ipv6_addresses.#:             \n =\n \ncomputed\n\n  key_name:                     \n =\n \nweb-admin-key\n\n  network_interface.#:          \n =\n \ncomputed\n\n  network_interface_id:         \n =\n \ncomputed\n\n  password_data:                \n =\n \ncomputed\n\n  placement_group:              \n =\n \ncomputed\n\n  primary_network_interface_id: \n =\n \ncomputed\n\n  private_dns:                  \n =\n \ncomputed\n\n  private_ip:                   \n =\n \ncomputed\n\n  public_dns:                   \n =\n \ncomputed\n\n  public_ip:                    \n =\n \ncomputed\n\n  root_block_device.#:          \n =\n \ncomputed\n\n  security_groups.#:            \n =\n \ncomputed\n\n  source_dest_check:            \n =\n \ntrue\n\n  subnet_id:                    \n =\n \ncomputed\n\n  tags.%:                       \n =\n \n1\n\n  tags.Name:                    \n =\n \nweberserver\n\n  tenancy:                      \n =\n \ncomputed\n\n  volume_tags.%:                \n =\n \ncomputed\n\n  vpc_security_group_ids.#:     \n =\n \ncomputed\n\naws_instance.webserver: Still creating... (10s elapsed)\naws_instance.webserver: Still creating... (20s elapsed)\naws_instance.webserver: Still creating... (30s elapsed)\naws_instance.webserver: Creation complete after 37s (ID: i-0a7d259b3126e16b8)\n\nApply complete! Resources: 2 added, 0 changed, 0 destroyed.\n\n\n\n\nIf you have noticed, Terraform did not create the security group this time around. The reason for this behaviour is, it had created the security group resource in the first run itself. So it did not create the same resource again when we applied the second time. This behaviour is called \nIdempotency\n.", 
            "title": "Terraform Building Blocks - Part 2"
        }, 
        {
            "location": "/05-resources-part2/#resources-part-2", 
            "text": "The ec2 instance that we have created is not that useful when we don't have access to it. So let us delete it and  we shall set up this again with additional resources.   Let us create a security group, which allows us to ssh(port 22) into the machine.  file: main.tf  provider  aws  {\n  region =  us-east-1 \n}\n\nresource  aws_instance   webserver  {\n  ami           =  ami-408c7f28 \n  instance_type =  t1.micro \n}\n\nresource  aws_security_group   webserver_sg  {\n\n    name =  webserver-sg \n\n    ingress {\n        from_port   = 22\n        to_port     = 22\n        protocol    =  tcp \n        cidr_blocks = [ 0.0.0.0/0 ]\n    }\n}  Here,\n  Resource type = aws_security_group,\n  Resource name = webserver_sg  This  aws_security_group  resource allows us to ssh into the instance.  We need to create the EC2 instance with this security group. To do that,   The final requirement is a  key pair  using which we can login to the machine. Let us use  aws_key_pair  to register the key with AWS and then use in our ec2 instance.  To do this, you will need to create a key pair in your local machine. Run the following commands. This will create one public key and a private key.  root@vibe$ ssh-keygen -t rsa\n\n[output]\nGenerating public/private rsa key pair.\nEnter file in which to save the key (/home/vibe/.ssh/id_rsa):\nEnter passphrase (empty for no passphrase):\nEnter same passphrase again:\nYour identification has been saved in /home/vibe/.ssh/id_rsa.\nYour public key has been saved in /home/vibe/.ssh/id_rsa.pub.\nThe key fingerprint is:\nSHA256:nSnSLKDvnLv22LFX+wKYMa0TvSt3AL406z+Asj/GSak vibe@vibes-MacBook-Air.local\nThe key's randomart image is:\n+---[RSA 2048]----+\n|                 |\n|                 |\n|    .  o         |\n|   . .=oo. o     |\n|  .  +oOS.+      |\n|  ..+ Xo+..      |\n|   *.o.* = .     |\n|  Eo*++o= +      |\n|   +O*==.o o.    |\n+----[SHA256]-----+  Copy the content of your public key  cat ~/.ssh/id_rsa.pub\n\n[output]\nssh-rsa AAAAB3NzaC1yc2EAAAADAQABAAABAQC4Q2TBuAD7ijkPjp+/Hl/QnrNo4hoZEz/l+UBsfvlDuJk8zfh0ivnQLtoYyXNuJ3/BjTVVIchrGo8CLZdTco//n+YBvMqgW4Wg5F92JNNkR5L5x04ELRUmC3ed1ZqbwrLmujzB33nMJ8Ld5dJjtS55KJa5MwkCaP7lqGicU2NgXe+if2DhCKW/lZyCpkkvRgmB7oEqj6aBWNjp+FMY4v6BtcmmB/+1Ry+GMvmZJO1EjSeUHAWCec3snX7TxJKHf4opwTHxknmhRKkz8+pS8rxyjiBeyncxP9jL9Tx/Zh6qmExCUfuhAWk87sjbb3j0enVs2LtzJOG9eBZ726wD83TJ vibe@vibes-MacBook-Air.local  Paste the content of public key in the public_key  file: main.tf  [...]\n\nresource  aws_security_group   webserver_sg  {\n\n    name =  webserver-sg \n\n    ingress {\n        from_port   = 22\n        to_port     = 22\n        protocol    =  tcp \n        cidr_blocks = [ 0.0.0.0/0 ]\n    }\n}\n\nresource  aws_key_pair   webserver_key  {\n  key_name   =  web-admin-key \n  public_key =  ssh-rsa sh-rsa AAAAB3NzaC1yc2EAAAADAQABAAABAQC4Q2TBuAD7ijkPjp+/Hl/QnrNo4hoZEz/l+UBsfvlDuJk8zfh0ivnQLtoYyXNuJ3/BjTVVIchrGo8CLZdTco//n+YBvMqgW4Wg5F92JNNkR5L5x04ELRUmC3ed1ZqbwrLmujzB33nMJ8Ld5dJjtS55KJa5MwkCaP7lqGicU2NgXe+if2DhCKW/lZyCpkkvRgmB7oEqj6aBWNjp+FMY4v6BtcmmB/+1Ry+GMvmZJO1EjSeUHAWCec3snX7TxJKHf4opwTHxknmhRKkz8+pS8rxyjiBeyncxP9jL9Tx/Zh6qmExCUfuhAWk87sjbb3j0enVs2LtzJOG9eBZ726wD83TJ vibe@vibes-MacBook-Air.local\n}  We need to make sure our instance uses this key. To do that, we should add one more attribute to our  aws_instance  module. We will also tag the instace with a name.  file: main.tf  provider  aws  {\n  region =  us-east-1 \n}\n\nresource  aws_instance   webserver  {\n  ami           =  ami-408c7f28 \n  instance_type =  t1.micro \n  key_name      =  web-admin-key \n\n  tags {\n    Name =  weberserver \n  }\n}\n\n[...]  The final file shoudl look like the following.  provider  aws  {\n  region =  us-east-1 \n}\n\nresource  aws_instance   webserver  {\n  ami           =  ami-408c7f28 \n  instance_type =  t1.micro \n  key_name      =  web-admin-key \n\n  tags {\n    Name =  weberserver \n  }\n}\n\nresource  aws_security_group   webserver_sg  {\n\n        name =  webserver-sg \n\n        ingress {\n                from_port   = 22\n                to_port     = 22\n                protocol    =  tcp \n                cidr_blocks = [ 0.0.0.0/0 ]\n        }\n}\n\nresource  aws_key_pair   webserver_key  {\n  key_name   =  web-admin-key \n  public_key =  ssh-rsa sh-rsa AAAAB3NzaC1yc2EAAAADAQABAAABAQC4Q2TBuAD7ijkPjp+/Hl/QnrNo4hoZEz/l+UBsfvlDuJk8zfh0ivnQLtoYyXNuJ3/BjTVVIchrGo8CLZdTco//n+YBvMqgW4Wg5F92JNNkR5L5x04ELRUmC3ed1ZqbwrLmujzB33nMJ8Ld5dJjtS55KJa5MwkCaP7lqGicU2NgXe+if2DhCKW/lZyCpkkvRgmB7oEqj6aBWNjp+FMY4v6BtcmmB/+1Ry+GMvmZJO1EjSeUHAWCec3snX7TxJKHf4opwTHxknmhRKkz8+pS8rxyjiBeyncxP9jL9Tx/Zh6qmExCUfuhAWk87sjbb3j0enVs2LtzJOG9eBZ726wD83TJ vibe@vibes-MacBook-Air.local \n}", 
            "title": "Resources - Part 2"
        }, 
        {
            "location": "/05-resources-part2/#explicit-dependency", 
            "text": "When we apply the manifest, we will get the following error.  terraform apply\n\n[output]\naws_security_group.webserver_sg: Still creating... (10s elapsed)\naws_security_group.webserver_sg: Creation complete after 11s (ID: sg-0c22a3497351d1caa)\n\nError: Error applying plan:\n\n2 error(s) occurred:\n\n* aws_instance.webserver: 1 error(s) occurred:\n\n* aws_instance.webserver: Error launching source instance: InvalidKeyPair.NotFound: The key pair 'web-admin-key' does not exist\n    status code: 400, request id: 36af6c0c-9016-4dc4-bd3a-7b94fc3dfade\n* aws_key_pair.webserver_key: 1 error(s) occurred:\n\n* aws_key_pair.webserver_key: Error import KeyPair: InvalidKey.Format: Key is not in valid OpenSSH public key format\n    status code: 400, request id: 8a3697d2-4450-4150-86e0-3b75c0d43b80\n\nTerraform does not automatically rollback in the face of errors.\nInstead, your Terraform state file has been partially updated with\nany resources that successfully completed. Please address the error\nabove and apply again to incrementally change your infrastructure.  This is because, the ec2 resource tries to use the key even before it is created. We can control the order of execution in two ways.\n  1. Implicit Dependecy (Automatic Dependency) \n  2. Explicit Dependency (Manual Dependency)    We will learn more about  Implicit Dependency  in the next chapter. Now we will focus on adding  Explicit Dependency  to  aws_instance  resource to depend on  aws_key_pair  resource.  This will guarantee the creation of key pair before the instance get's created. In your instance block add the following,  file: main.tf  [...]\nresource  aws_instance   webserver  {\n  ami           =  ami-408c7f28 \n  instance_type =  t1.micro \n  key_name      =  web-admin-key \n\n  depends_on = [ aws_key_pair.webserver_key ]\n  tags {\n    Name =  weberserver \n  }\n}\n[...]  Syntax:  depends_on = [\"resource_type.resource_name\"]", 
            "title": "Explicit Dependency"
        }, 
        {
            "location": "/05-resources-part2/#idempotency", 
            "text": "Finally apply the manifest by running,  terraform apply\n\n[output]\nPlan: 2 to add, 0 to change, 0 to destroy.\n\nDo you want to perform these actions?\n  Terraform will perform the actions described above.\n  Only 'yes' will be accepted to approve.\n\n  Enter a value: yes\n\naws_key_pair.webserver_key: Creating...\n  fingerprint:   =   computed \n  key_name:      =   web-admin-key \n  public_key:    =   ssh-rsa AAAAB3NzaC1yc2EAAAADAQABAAABAQC4Q2TBuAD7ijkPjp+/Hl/QnrNo4hoZEz/l+UBsfvlDuJk8zfh0ivnQLtoYyXNuJ3/BjTVVIchrGo8CLZdTco//n+YBvMqgW4Wg5F92JNNkR5L5x04ELRUmC3ed1ZqbwrLmujzB33nMJ8Ld5dJjtS55KJa5MwkCaP7lqGicU2NgXe+if2DhCKW/lZyCpkkvRgmB7oEqj6aBWNjp+FMY4v6BtcmmB/+1Ry+GMvmZJO1EjSeUHAWCec3snX7TxJKHf4opwTHxknmhRKkz8+pS8rxyjiBeyncxP9jL9Tx/Zh6qmExCUfuhAWk87sjbb3j0enVs2LtzJOG9eBZ726wD83TJ vibe@vibes-MacBook-Air.local \naws_key_pair.webserver_key: Creation complete after 3s (ID: web-admin-key)\naws_instance.webserver: Creating...\n  ami:                            =   ami-408c7f28 \n  arn:                            =   computed \n  associate_public_ip_address:    =   computed \n  availability_zone:              =   computed \n  cpu_core_count:                 =   computed \n  cpu_threads_per_core:           =   computed \n  ebs_block_device.#:             =   computed \n  ephemeral_block_device.#:       =   computed \n  get_password_data:              =   false \n  instance_state:                 =   computed \n  instance_type:                  =   t1.micro \n  ipv6_address_count:             =   computed \n  ipv6_addresses.#:               =   computed \n  key_name:                       =   web-admin-key \n  network_interface.#:            =   computed \n  network_interface_id:           =   computed \n  password_data:                  =   computed \n  placement_group:                =   computed \n  primary_network_interface_id:   =   computed \n  private_dns:                    =   computed \n  private_ip:                     =   computed \n  public_dns:                     =   computed \n  public_ip:                      =   computed \n  root_block_device.#:            =   computed \n  security_groups.#:              =   computed \n  source_dest_check:              =   true \n  subnet_id:                      =   computed \n  tags.%:                         =   1 \n  tags.Name:                      =   weberserver \n  tenancy:                        =   computed \n  volume_tags.%:                  =   computed \n  vpc_security_group_ids.#:       =   computed \naws_instance.webserver: Still creating... (10s elapsed)\naws_instance.webserver: Still creating... (20s elapsed)\naws_instance.webserver: Still creating... (30s elapsed)\naws_instance.webserver: Creation complete after 37s (ID: i-0a7d259b3126e16b8)\n\nApply complete! Resources: 2 added, 0 changed, 0 destroyed.  If you have noticed, Terraform did not create the security group this time around. The reason for this behaviour is, it had created the security group resource in the first run itself. So it did not create the same resource again when we applied the second time. This behaviour is called  Idempotency .", 
            "title": "Idempotency"
        }, 
        {
            "location": "/06-variables-and-outputs/", 
            "text": "Variables\n\n\nLet us try to ssh into the machine that we've just created. Get the public IP from the AWS console.\n\n\nssh ubuntu@34.203.194.201\n\n[output]\nssh: connect to host 34.203.194.201 port 22: Operation timed out\n\n\n\n\nYou will not be able to SSH. The reason is we have not associated the security group that we have created with this instance. The instance is still using the default security group which doesn't allow ssh. \n\n\n\n\nWe need to fix this issue. Let us associate our security group with this machine.\n\n\nfile: main.tf\n\n\nBad Practice\n\n\nresource \naws_instance\n \nwebserver\n {\n  ami                    = \nami-408c7f28\n\n  instance_type          = \nt1.micro\n\n  key_name               = \nweb-admin-key\n\n  vpc_security_group_ids = \nsg-0c22a3497351d1caa\n\n  depends_on             = [\naws_key_pair.webserver_key\n]\n\n  tags {\n    Name = \nweberserver\n\n  }\n}\n\n\n\n\nWe can manually copy the ID of the security group and apply the manifest. This would work but this is an ugly fix. We should let Terraform to find the these kind of mutable data. Thats where \nVariables\n come into picture.\n\n\nType 1: Attribute of a Resource\n\n\nfile: main.tf\n\n\nGood Practice\n\n\nresource \naws_instance\n \nwebserver\n {\n  ami                    = \nami-408c7f28\n\n  instance_type          = \nt1.micro\n\n  key_name               = \nweb-admin-key\n\n  vpc_security_group_ids = [\n${aws_security_group.webserver_sg.id}\n]\n  depends_on             = [\naws_key_pair.webserver_key\n]\n\n  tags {\n    Name = \nweberserver\n\n  }\n}\n\n\n\n\nThis is how variable interpolation works in Terraform. \n\n\nSyntax: ${TYPE.NAME.ATTRIBUTE}\n\n\nIn our case, it is, \n${aws_security_group.webserver_sg.id}\n.\nHere,\n  aws_security_group =\n TYPE\n  webserver_sg       =\n NAME\n  id                 =\n ATTRIBUTE\n\n\nEvery resource has set of attribute that can be referred as a variable. \naws_security_group\n resource has the following attributes which can be referred.\n\n  * id - The ID of the security group\n\n  * arn - The ARN of the security group\n\n  * vpc_id - The VPC ID.\n\n  * owner_id - The owner ID.\n\n  * name - The name of the security group\n\n  * description - The description of the security group\n\n  * ingress - The ingress rules. See above for more.\n\n  * egress - The egress rules. See above for more.  \n\n\nThis also creates an \nImplicit Dependency\n. Terraform will know that this security group has to be created before the EC2 instance since the later refers to it. Let us apply the given manifest.  \n\n\nLet us apply the manifest.\n\n\nterraform apply \n\n[output]\nAn execution plan has been generated and is shown below.\nResource actions are indicated with the following symbols:\n  ~ update in-place\n\nTerraform will perform the following actions:\n\n  ~ aws_instance.webserver\n      vpc_security_group_ids.118229083:  \n =\n \nsg-0c22a3497351d1caa\n\n      vpc_security_group_ids.3314100969: \nsg-a42b7ae9\n =\n \n\n\n\nPlan: 0 to add, 1 to change, 0 to destroy.\n\nDo you want to perform these actions?\n  Terraform will perform the actions described above.\n  Only 'yes' will be accepted to approve.\n\n  Enter a value: yes\n\naws_instance.webserver: Modifying... (ID: i-0a7d259b3126e16b8)\n  vpc_security_group_ids.118229083:  \n =\n \nsg-0c22a3497351d1caa\n\n  vpc_security_group_ids.3314100969: \nsg-a42b7ae9\n =\n \n\naws_instance.webserver: Still modifying... (ID: i-0a7d259b3126e16b8, 10s elapsed)\naws_instance.webserver: Modifications complete after 13s (ID: i-0a7d259b3126e16b8)\n\nApply complete! Resources: 0 added, 1 changed, 0 destroyed.\n\n\n\n\nCheck in your AWS console to check the same.\n\n\n\n\nNow you should be able to SSH into the machine.\n\n\nssh ubuntu@34.203.194.201\n\n[output]\nWarning: Permanently added '34.203.194.201' (ECDSA) to the list of known hosts.\nWelcome to Ubuntu 14.04 LTS (GNU/Linux 3.13.0-29-generic x86_64)\n\nubuntu@ip-172-31-40-32:~$\n\n\n\n\nExercise: Remove the explicit dependecy by using the key_pair with above given attribute reference method\n \n\n\nType 2: User Defined(Input) Variables\n\n\nIt is always a good practice to remove data from code. In our manifest, we are hardcoding all the values. Instead we should use variables to define the values and reference them in the manifest. \n\n\nCreate a new file with the name \nvariables.tf\n\n\ntouch variables.tf\n\n\n\n\nSyntax\n:\n\n\nvariable \nname\n {\n  description = \ndescribe your variable\n\n  default     = \ndefault value\n\n}\n\n\n\n\nLet us define our first variable in this file.\n\n\nfile: variables.tf\n\n\nvariable \nami\n {\n  description = \nami for the instance\n\n  default     = \nami-408c7f28\n\n}\n\n\n\n\nThis variable can be referenced in the main manifest like the following.\n\n\n[...]\nresource \naws_instance\n \nwebserver\n {\n  ami                    = \n${var.ami}\n\n  instance_type          = \nt1.micro\n\n  key_name               = \nweb-admin-key\n\n  vpc_security_group_ids = [\n${aws_security_group.webserver_sg.id}\n]\n  depends_on             = [\naws_key_pair.webserver_key\n]\n\n  tags {\n    Name = \nweberserver\n\n  }\n}\n[...]\n\n\n\n\nLet us apply the manifest to see if this works. Terraform automatically loads all the files with \n.tf\n extension from the working directory. So we do not need to implicitly mention about the variable file.\n\n\nterraform apply\n\n[output]\naws_key_pair.webserver_key: Refreshing state... (ID: web-admin-key)\naws_security_group.webserver_sg: Refreshing state... (ID: sg-0c22a3497351d1caa)\naws_instance.webserver: Refreshing state... (ID: i-0a7d259b3126e16b8)\n\nApply complete! Resources: 0 added, 0 changed, 0 destroyed.\n\n\n\n\nLet us parameterize some properties from our main manifest.\n\n\nfile: variables.tf\n\n\n# default type is string\nvariable \nami\n {\n  description = \nami for the instance\n\n  default     = \nami-408c7f28\n\n}\n\n# map type variable definition\nvariable \ninstance\n {\n  description = \ninstance parameters\n\n  type        = map\n  default     = {\n    \ntype\n = \nt1.micro\n\n    \nname\n = \ndemo-server\n\n  }\n}\n\nvariable \nkey_name\n {\n  description = \nname of the key\n\n  default     = \nweb-admin-key\n\n}\n\nvariable \nkey_pub\n {\n  description = \ncontent of public key\n\n  default     = \nssh-rsa AAAAB3NzaC1yc2EAAAADAQABAAABAQC4Q2TBuAD7ijkPjp+/Hl/QnrNo4hoZEz/l+UBsfvlDuJk8zfh0ivnQLtoYyXNuJ3/BjTVVIchrGo8CLZdTco//n+YBvMqgW4Wg5F92JNNkR5L5x04ELRUmC3ed1ZqbwrLmujzB33nMJ8Ld5dJjtS55KJa5MwkCaP7lqGicU2NgXe+if2DhCKW/lZyCpkkvRgmB7oEqj6aBWNjp+FMY4v6BtcmmB/+1Ry+GMvmZJO1EjSeUHAWCec3snX7TxJKHf4opwTHxknmhRKkz8+pS8rxyjiBeyncxP9jL9Tx/Zh6qmExCUfuhAWk87sjbb3j0enVs2LtzJOG9eBZ726wD83TJ vibe@vibes-MacBook-Air.local\n\n}\n\n\n\n\nHere is fully parameterized main manifest.\n\nfile: main.tf\n\n\nprovider \naws\n {\n  region = \nus-east-1\n\n}\n\nresource \naws_instance\n \nwebserver\n {\n  ami                    = \n${var.ami}\n\n  instance_type          = \n${var.instance[\ntype\n]}\n\n  key_name               = \nweb-admin-key\n\n  vpc_security_group_ids = [\n${aws_security_group.webserver_sg.id}\n]\n  depends_on             = [\naws_key_pair.webserver_key\n]\n\n  tags {\n    Name = \n${var.instance[\nname\n]}\n\n  }\n}\n\nresource \naws_security_group\n \nwebserver_sg\n {\n  name = \nwebserver-sg\n\n\n  ingress {\n    from_port   = 22\n    to_port     = 22\n    protocol    = \ntcp\n\n    cidr_blocks = [\n0.0.0.0/0\n]\n  }\n}\n\nresource \naws_key_pair\n \nwebserver_key\n {\n  key_name   = \n${var.key_name}\n\n  public_key = \n${var.key_pub}\n\n}\n\n\n\n\nI've intentionally set the variable \ninstance.name\n to \ndemo-server\n. Let us apply the manifest.\n\n\nterraform apply\n\n[output]\naws_security_group.webserver_sg: Refreshing state... (ID: sg-0c22a3497351d1caa)\naws_key_pair.webserver_key: Refreshing state... (ID: web-admin-key)\naws_instance.webserver: Refreshing state... (ID: i-0a7d259b3126e16b8)\n\nAn execution plan has been generated and is shown below.\nResource actions are indicated with the following symbols:\n  ~ update in-place\n\nTerraform will perform the following actions:\n\n  ~ aws_instance.webserver\n      tags.Name: \nweberserver\n =\n \ndemo-server\n\n\n\nPlan: 0 to add, 1 to change, 0 to destroy.\n\nDo you want to perform these actions?\n  Terraform will perform the actions described above.\n  Only 'yes' will be accepted to approve.\n\n  Enter a value: yes\n\naws_instance.webserver: Modifying... (ID: i-0a7d259b3126e16b8)\n  tags.Name: \nweberserver\n =\n \ndemo-server\n\naws_instance.webserver: Still modifying... (ID: i-0a7d259b3126e16b8, 10s elapsed)\naws_instance.webserver: Modifications complete after 14s (ID: i-0a7d259b3126e16b8)\n\nApply complete! Resources: 0 added, 1 changed, 0 destroyed.\n\n\n\n\nTerraform has substituted the value of \ninstance name\n from variables, thus it has changed the resource as well.\n\n\nType 3: Output Variables\n\n\nOutput variables help us to refer the metadata of resources after they are applied. This saves a lot of time, because we don't have to find go to AWS web console to find the details.\n\n\nLet us get the public ip of the instance we've created by using output variable.\n\n\nfile: main.tf\n\n\n[...]\noutput \nwebserver_ip\n {\n    value = \n${aws_instance.webserver.public_ip}\n\n}\n[...]\n\n\n\n\nOutput variables also uses variable interpolation. \n\n\nRun \nterraform apply\n to see output variables in action.\n\n\nterraform apply\n\n[output]\naws_security_group.webserver_sg: Refreshing state... (ID: sg-0c22a3497351d1caa)\naws_key_pair.webserver_key: Refreshing state... (ID: web-admin-key)\naws_instance.webserver: Refreshing state... (ID: i-0a7d259b3126e16b8)\n\nApply complete! Resources: 0 added, 0 changed, 0 destroyed.\n\nOutputs:\n\nwebserver_ip = 34.203.194.201", 
            "title": "Input and Output Variables"
        }, 
        {
            "location": "/06-variables-and-outputs/#variables", 
            "text": "Let us try to ssh into the machine that we've just created. Get the public IP from the AWS console.  ssh ubuntu@34.203.194.201\n\n[output]\nssh: connect to host 34.203.194.201 port 22: Operation timed out  You will not be able to SSH. The reason is we have not associated the security group that we have created with this instance. The instance is still using the default security group which doesn't allow ssh.    We need to fix this issue. Let us associate our security group with this machine.  file: main.tf  Bad Practice  resource  aws_instance   webserver  {\n  ami                    =  ami-408c7f28 \n  instance_type          =  t1.micro \n  key_name               =  web-admin-key \n  vpc_security_group_ids =  sg-0c22a3497351d1caa \n  depends_on             = [ aws_key_pair.webserver_key ]\n\n  tags {\n    Name =  weberserver \n  }\n}  We can manually copy the ID of the security group and apply the manifest. This would work but this is an ugly fix. We should let Terraform to find the these kind of mutable data. Thats where  Variables  come into picture.", 
            "title": "Variables"
        }, 
        {
            "location": "/06-variables-and-outputs/#type-1-attribute-of-a-resource", 
            "text": "file: main.tf  Good Practice  resource  aws_instance   webserver  {\n  ami                    =  ami-408c7f28 \n  instance_type          =  t1.micro \n  key_name               =  web-admin-key \n  vpc_security_group_ids = [ ${aws_security_group.webserver_sg.id} ]\n  depends_on             = [ aws_key_pair.webserver_key ]\n\n  tags {\n    Name =  weberserver \n  }\n}  This is how variable interpolation works in Terraform.   Syntax: ${TYPE.NAME.ATTRIBUTE}  In our case, it is,  ${aws_security_group.webserver_sg.id} .\nHere,\n  aws_security_group =  TYPE\n  webserver_sg       =  NAME\n  id                 =  ATTRIBUTE  Every resource has set of attribute that can be referred as a variable.  aws_security_group  resource has the following attributes which can be referred. \n  * id - The ID of the security group \n  * arn - The ARN of the security group \n  * vpc_id - The VPC ID. \n  * owner_id - The owner ID. \n  * name - The name of the security group \n  * description - The description of the security group \n  * ingress - The ingress rules. See above for more. \n  * egress - The egress rules. See above for more.    This also creates an  Implicit Dependency . Terraform will know that this security group has to be created before the EC2 instance since the later refers to it. Let us apply the given manifest.    Let us apply the manifest.  terraform apply \n\n[output]\nAn execution plan has been generated and is shown below.\nResource actions are indicated with the following symbols:\n  ~ update in-place\n\nTerraform will perform the following actions:\n\n  ~ aws_instance.webserver\n      vpc_security_group_ids.118229083:    =   sg-0c22a3497351d1caa \n      vpc_security_group_ids.3314100969:  sg-a42b7ae9  =   \n\n\nPlan: 0 to add, 1 to change, 0 to destroy.\n\nDo you want to perform these actions?\n  Terraform will perform the actions described above.\n  Only 'yes' will be accepted to approve.\n\n  Enter a value: yes\n\naws_instance.webserver: Modifying... (ID: i-0a7d259b3126e16b8)\n  vpc_security_group_ids.118229083:    =   sg-0c22a3497351d1caa \n  vpc_security_group_ids.3314100969:  sg-a42b7ae9  =   \naws_instance.webserver: Still modifying... (ID: i-0a7d259b3126e16b8, 10s elapsed)\naws_instance.webserver: Modifications complete after 13s (ID: i-0a7d259b3126e16b8)\n\nApply complete! Resources: 0 added, 1 changed, 0 destroyed.  Check in your AWS console to check the same.   Now you should be able to SSH into the machine.  ssh ubuntu@34.203.194.201\n\n[output]\nWarning: Permanently added '34.203.194.201' (ECDSA) to the list of known hosts.\nWelcome to Ubuntu 14.04 LTS (GNU/Linux 3.13.0-29-generic x86_64)\n\nubuntu@ip-172-31-40-32:~$  Exercise: Remove the explicit dependecy by using the key_pair with above given attribute reference method", 
            "title": "Type 1: Attribute of a Resource"
        }, 
        {
            "location": "/06-variables-and-outputs/#type-2-user-definedinput-variables", 
            "text": "It is always a good practice to remove data from code. In our manifest, we are hardcoding all the values. Instead we should use variables to define the values and reference them in the manifest.   Create a new file with the name  variables.tf  touch variables.tf  Syntax :  variable  name  {\n  description =  describe your variable \n  default     =  default value \n}  Let us define our first variable in this file.  file: variables.tf  variable  ami  {\n  description =  ami for the instance \n  default     =  ami-408c7f28 \n}  This variable can be referenced in the main manifest like the following.  [...]\nresource  aws_instance   webserver  {\n  ami                    =  ${var.ami} \n  instance_type          =  t1.micro \n  key_name               =  web-admin-key \n  vpc_security_group_ids = [ ${aws_security_group.webserver_sg.id} ]\n  depends_on             = [ aws_key_pair.webserver_key ]\n\n  tags {\n    Name =  weberserver \n  }\n}\n[...]  Let us apply the manifest to see if this works. Terraform automatically loads all the files with  .tf  extension from the working directory. So we do not need to implicitly mention about the variable file.  terraform apply\n\n[output]\naws_key_pair.webserver_key: Refreshing state... (ID: web-admin-key)\naws_security_group.webserver_sg: Refreshing state... (ID: sg-0c22a3497351d1caa)\naws_instance.webserver: Refreshing state... (ID: i-0a7d259b3126e16b8)\n\nApply complete! Resources: 0 added, 0 changed, 0 destroyed.  Let us parameterize some properties from our main manifest.  file: variables.tf  # default type is string\nvariable  ami  {\n  description =  ami for the instance \n  default     =  ami-408c7f28 \n}\n\n# map type variable definition\nvariable  instance  {\n  description =  instance parameters \n  type        = map\n  default     = {\n     type  =  t1.micro \n     name  =  demo-server \n  }\n}\n\nvariable  key_name  {\n  description =  name of the key \n  default     =  web-admin-key \n}\n\nvariable  key_pub  {\n  description =  content of public key \n  default     =  ssh-rsa AAAAB3NzaC1yc2EAAAADAQABAAABAQC4Q2TBuAD7ijkPjp+/Hl/QnrNo4hoZEz/l+UBsfvlDuJk8zfh0ivnQLtoYyXNuJ3/BjTVVIchrGo8CLZdTco//n+YBvMqgW4Wg5F92JNNkR5L5x04ELRUmC3ed1ZqbwrLmujzB33nMJ8Ld5dJjtS55KJa5MwkCaP7lqGicU2NgXe+if2DhCKW/lZyCpkkvRgmB7oEqj6aBWNjp+FMY4v6BtcmmB/+1Ry+GMvmZJO1EjSeUHAWCec3snX7TxJKHf4opwTHxknmhRKkz8+pS8rxyjiBeyncxP9jL9Tx/Zh6qmExCUfuhAWk87sjbb3j0enVs2LtzJOG9eBZ726wD83TJ vibe@vibes-MacBook-Air.local \n}  Here is fully parameterized main manifest. file: main.tf  provider  aws  {\n  region =  us-east-1 \n}\n\nresource  aws_instance   webserver  {\n  ami                    =  ${var.ami} \n  instance_type          =  ${var.instance[ type ]} \n  key_name               =  web-admin-key \n  vpc_security_group_ids = [ ${aws_security_group.webserver_sg.id} ]\n  depends_on             = [ aws_key_pair.webserver_key ]\n\n  tags {\n    Name =  ${var.instance[ name ]} \n  }\n}\n\nresource  aws_security_group   webserver_sg  {\n  name =  webserver-sg \n\n  ingress {\n    from_port   = 22\n    to_port     = 22\n    protocol    =  tcp \n    cidr_blocks = [ 0.0.0.0/0 ]\n  }\n}\n\nresource  aws_key_pair   webserver_key  {\n  key_name   =  ${var.key_name} \n  public_key =  ${var.key_pub} \n}  I've intentionally set the variable  instance.name  to  demo-server . Let us apply the manifest.  terraform apply\n\n[output]\naws_security_group.webserver_sg: Refreshing state... (ID: sg-0c22a3497351d1caa)\naws_key_pair.webserver_key: Refreshing state... (ID: web-admin-key)\naws_instance.webserver: Refreshing state... (ID: i-0a7d259b3126e16b8)\n\nAn execution plan has been generated and is shown below.\nResource actions are indicated with the following symbols:\n  ~ update in-place\n\nTerraform will perform the following actions:\n\n  ~ aws_instance.webserver\n      tags.Name:  weberserver  =   demo-server \n\n\nPlan: 0 to add, 1 to change, 0 to destroy.\n\nDo you want to perform these actions?\n  Terraform will perform the actions described above.\n  Only 'yes' will be accepted to approve.\n\n  Enter a value: yes\n\naws_instance.webserver: Modifying... (ID: i-0a7d259b3126e16b8)\n  tags.Name:  weberserver  =   demo-server \naws_instance.webserver: Still modifying... (ID: i-0a7d259b3126e16b8, 10s elapsed)\naws_instance.webserver: Modifications complete after 14s (ID: i-0a7d259b3126e16b8)\n\nApply complete! Resources: 0 added, 1 changed, 0 destroyed.  Terraform has substituted the value of  instance name  from variables, thus it has changed the resource as well.", 
            "title": "Type 2: User Defined(Input) Variables"
        }, 
        {
            "location": "/06-variables-and-outputs/#type-3-output-variables", 
            "text": "Output variables help us to refer the metadata of resources after they are applied. This saves a lot of time, because we don't have to find go to AWS web console to find the details.  Let us get the public ip of the instance we've created by using output variable.  file: main.tf  [...]\noutput  webserver_ip  {\n    value =  ${aws_instance.webserver.public_ip} \n}\n[...]  Output variables also uses variable interpolation.   Run  terraform apply  to see output variables in action.  terraform apply\n\n[output]\naws_security_group.webserver_sg: Refreshing state... (ID: sg-0c22a3497351d1caa)\naws_key_pair.webserver_key: Refreshing state... (ID: web-admin-key)\naws_instance.webserver: Refreshing state... (ID: i-0a7d259b3126e16b8)\n\nApply complete! Resources: 0 added, 0 changed, 0 destroyed.\n\nOutputs:\n\nwebserver_ip = 34.203.194.201", 
            "title": "Type 3: Output Variables"
        }, 
        {
            "location": "/07-datasources/", 
            "text": "Data Source\n\n\nData sources are read only information that Terraform can get from Provider's API. When we use data source, Terraform doesn't create/modify anything. It just queries the API, so that the data can be used by other resources.", 
            "title": "Data Source"
        }, 
        {
            "location": "/07-datasources/#data-source", 
            "text": "Data sources are read only information that Terraform can get from Provider's API. When we use data source, Terraform doesn't create/modify anything. It just queries the API, so that the data can be used by other resources.", 
            "title": "Data Source"
        }, 
        {
            "location": "/0x-terraform-state/", 
            "text": "Terraform State\n\n\nOne advantage, Terraform has over other configuration management tools like Ansible and Chef is State management. Terraform stores/tracks all our infrastructure information(that we have created using Terraform) in a file with the name \nterraform.tfstate\n. \n\n\nIn the last chapter, we have ran \nterraform apply\n. This command would create the above mentioned JSON flavoured statefile. Let us look at its the content.\n\n\nterraform.tfstate\n\n\n{\n    \nversion\n: 3,\n    \nterraform_version\n: \n0.11.7\n,\n    \nserial\n: 1,\n    \nlineage\n: \n138bb0c6-ca69-0d39-aa90-5e08f29c8efb\n,\n    \nmodules\n: [\n        {\n            \npath\n: [\n                \nroot\n\n            ],\n            \noutputs\n: {},\n            \nresources\n: {\n                \naws_instance.webserver\n: {\n                    \ntype\n: \naws_instance\n,\n                    \ndepends_on\n: [],\n                    \nprimary\n: {\n                        \nid\n: \ni-02489cdf638f05bbd\n,\n                        \nattributes\n: {\n                            \nami\n: \nami-408c7f28\n,\n                            \narn\n: \narn:aws:ec2:us-east-1:822941572458:instance/i-02489cdf638f05bbd\n,\n                            \nassociate_public_ip_address\n: \ntrue\n,\n                            \navailability_zone\n: \nus-east-1d\n,\n                            \ncpu_core_count\n: \n1\n,\n                            \ncpu_threads_per_core\n: \n1\n,\n                            \ncredit_specification.#\n: \n1\n,\n                            \ncredit_specification.0.cpu_credits\n: \nstandard\n,\n                            \ndisable_api_termination\n: \nfalse\n,\n                            \nebs_block_device.#\n: \n0\n,\n                            \nebs_optimized\n: \nfalse\n,\n                            \nephemeral_block_device.#\n: \n0\n,\n                            \nget_password_data\n: \nfalse\n,\n                            \niam_instance_profile\n: \n,\n                            \nid\n: \ni-02489cdf638f05bbd\n,\n                            \ninstance_state\n: \nrunning\n,\n                            \ninstance_type\n: \nt1.micro\n,\n                            \nipv6_addresses.#\n: \n0\n,\n                            \nkey_name\n: \n,\n                            \nmonitoring\n: \nfalse\n,\n                            \nnetwork_interface.#\n: \n0\n,\n                            \nnetwork_interface_id\n: \neni-00fbc08209349bb38\n,\n                            \npassword_data\n: \n,\n                            \nplacement_group\n: \n,\n                            \nprimary_network_interface_id\n: \neni-00fbc08209349bb38\n,\n                            \nprivate_dns\n: \nip-172-31-24-184.ec2.internal\n,\n                            \nprivate_ip\n: \n172.31.24.184\n,\n                            \npublic_dns\n: \nec2-34-230-78-138.compute-1.amazonaws.com\n,\n                            \npublic_ip\n: \n34.230.78.138\n,\n                            \nroot_block_device.#\n: \n1\n,\n                            \nroot_block_device.0.delete_on_termination\n: \ntrue\n,\n                            \nroot_block_device.0.iops\n: \n0\n,\n                            \nroot_block_device.0.volume_id\n: \nvol-0cc495c189e5c8dd2\n,\n                            \nroot_block_device.0.volume_size\n: \n8\n,\n                            \nroot_block_device.0.volume_type\n: \nstandard\n,\n                            \nsecurity_groups.#\n: \n1\n,\n                            \nsecurity_groups.3814588639\n: \ndefault\n,\n                            \nsource_dest_check\n: \ntrue\n,\n                            \nsubnet_id\n: \nsubnet-e8b3e6a2\n,\n                            \ntags.%\n: \n0\n,\n                            \ntenancy\n: \ndefault\n,\n                            \nvolume_tags.%\n: \n0\n,\n                            \nvpc_security_group_ids.#\n: \n1\n,\n                            \nvpc_security_group_ids.3314100969\n: \nsg-a42b7ae9\n\n                        },\n                        \nmeta\n: {\n                            \ne2bfb730-ecaa-11e6-8f88-34363bc7c4c0\n: {\n                                \ncreate\n: 600000000000,\n                                \ndelete\n: 1200000000000,\n                                \nupdate\n: 600000000000\n                            },\n                            \nschema_version\n: \n1\n\n                        },\n                        \ntainted\n: false\n                    },\n                    \ndeposed\n: [],\n                    \nprovider\n: \nprovider.aws\n\n                }\n            },\n            \ndepends_on\n: []\n        }\n    ]\n}\n\n\n\n\nUsecase 1\n\n\nThis file contains the metadata of our ec2 instance that we have created in the last chapter. This information will be critical when we have to create \nother resources which references this\n ec2 instance. As we add more resources to the terrform template, this file will get populated with more metadata about each resource.\n\n\nUsecase 2\n\n\nWhat happens when someone manually changes(which is not desirable) the properties of the instance created by Terraform? We can undo the manual changes just by running \nterraform apply\n again. One point to keep in mind though is, some property changes forces resource recreation which might result in data loss.\n\n\nChanges in Terrfaform state\n\n\nLet us see what happens to tfstate file when we destroy the ec2 instance\n\n\nterraform destroy\n\n[output]\naws_instance.webserver: Refreshing state... (ID: i-02489cdf638f05bbd)\n\nAn execution plan has been generated and is shown below.\nResource actions are indicated with the following symbols:\n  - destroy\n\nTerraform will perform the following actions:\n\n  - aws_instance.webserver\n\n\nPlan: 0 to add, 0 to change, 1 to destroy.\n\nDo you really want to destroy?\n  Terraform will destroy all your managed infrastructure, as shown above.\n  There is no undo. Only 'yes' will be accepted to confirm.\n\n  Enter a value: yes\n  [...]\naws_instance.webserver: Still destroying... (ID: i-02489cdf638f05bbd, 1m0s elapsed)\naws_instance.webserver: Destruction complete after 1m0s\n\nDestroy complete! Resources: 1 destroyed.\n\n\n\n\nfile: terraform.tfstate\n\n\n{\n    \nversion\n: 3,\n    \nterraform_version\n: \n0.11.7\n,\n    \nserial\n: 2,\n    \nlineage\n: \n138bb0c6-ca69-0d39-aa90-5e08f29c8efb\n,\n    \nmodules\n: [\n        {\n            \npath\n: [\n                \nroot\n\n            ],\n            \noutputs\n: {},\n            \nresources\n: {},\n            \ndepends_on\n: []\n        }\n    ]\n}\n\n\n\n\nOnce the machine is destroyed, all metadata about that machine is also gone.", 
            "title": "State Management in Terraform"
        }, 
        {
            "location": "/0x-terraform-state/#terraform-state", 
            "text": "One advantage, Terraform has over other configuration management tools like Ansible and Chef is State management. Terraform stores/tracks all our infrastructure information(that we have created using Terraform) in a file with the name  terraform.tfstate .   In the last chapter, we have ran  terraform apply . This command would create the above mentioned JSON flavoured statefile. Let us look at its the content.  terraform.tfstate  {\n     version : 3,\n     terraform_version :  0.11.7 ,\n     serial : 1,\n     lineage :  138bb0c6-ca69-0d39-aa90-5e08f29c8efb ,\n     modules : [\n        {\n             path : [\n                 root \n            ],\n             outputs : {},\n             resources : {\n                 aws_instance.webserver : {\n                     type :  aws_instance ,\n                     depends_on : [],\n                     primary : {\n                         id :  i-02489cdf638f05bbd ,\n                         attributes : {\n                             ami :  ami-408c7f28 ,\n                             arn :  arn:aws:ec2:us-east-1:822941572458:instance/i-02489cdf638f05bbd ,\n                             associate_public_ip_address :  true ,\n                             availability_zone :  us-east-1d ,\n                             cpu_core_count :  1 ,\n                             cpu_threads_per_core :  1 ,\n                             credit_specification.# :  1 ,\n                             credit_specification.0.cpu_credits :  standard ,\n                             disable_api_termination :  false ,\n                             ebs_block_device.# :  0 ,\n                             ebs_optimized :  false ,\n                             ephemeral_block_device.# :  0 ,\n                             get_password_data :  false ,\n                             iam_instance_profile :  ,\n                             id :  i-02489cdf638f05bbd ,\n                             instance_state :  running ,\n                             instance_type :  t1.micro ,\n                             ipv6_addresses.# :  0 ,\n                             key_name :  ,\n                             monitoring :  false ,\n                             network_interface.# :  0 ,\n                             network_interface_id :  eni-00fbc08209349bb38 ,\n                             password_data :  ,\n                             placement_group :  ,\n                             primary_network_interface_id :  eni-00fbc08209349bb38 ,\n                             private_dns :  ip-172-31-24-184.ec2.internal ,\n                             private_ip :  172.31.24.184 ,\n                             public_dns :  ec2-34-230-78-138.compute-1.amazonaws.com ,\n                             public_ip :  34.230.78.138 ,\n                             root_block_device.# :  1 ,\n                             root_block_device.0.delete_on_termination :  true ,\n                             root_block_device.0.iops :  0 ,\n                             root_block_device.0.volume_id :  vol-0cc495c189e5c8dd2 ,\n                             root_block_device.0.volume_size :  8 ,\n                             root_block_device.0.volume_type :  standard ,\n                             security_groups.# :  1 ,\n                             security_groups.3814588639 :  default ,\n                             source_dest_check :  true ,\n                             subnet_id :  subnet-e8b3e6a2 ,\n                             tags.% :  0 ,\n                             tenancy :  default ,\n                             volume_tags.% :  0 ,\n                             vpc_security_group_ids.# :  1 ,\n                             vpc_security_group_ids.3314100969 :  sg-a42b7ae9 \n                        },\n                         meta : {\n                             e2bfb730-ecaa-11e6-8f88-34363bc7c4c0 : {\n                                 create : 600000000000,\n                                 delete : 1200000000000,\n                                 update : 600000000000\n                            },\n                             schema_version :  1 \n                        },\n                         tainted : false\n                    },\n                     deposed : [],\n                     provider :  provider.aws \n                }\n            },\n             depends_on : []\n        }\n    ]\n}", 
            "title": "Terraform State"
        }, 
        {
            "location": "/0x-terraform-state/#usecase-1", 
            "text": "This file contains the metadata of our ec2 instance that we have created in the last chapter. This information will be critical when we have to create  other resources which references this  ec2 instance. As we add more resources to the terrform template, this file will get populated with more metadata about each resource.", 
            "title": "Usecase 1"
        }, 
        {
            "location": "/0x-terraform-state/#usecase-2", 
            "text": "What happens when someone manually changes(which is not desirable) the properties of the instance created by Terraform? We can undo the manual changes just by running  terraform apply  again. One point to keep in mind though is, some property changes forces resource recreation which might result in data loss.", 
            "title": "Usecase 2"
        }, 
        {
            "location": "/0x-terraform-state/#changes-in-terrfaform-state", 
            "text": "Let us see what happens to tfstate file when we destroy the ec2 instance  terraform destroy\n\n[output]\naws_instance.webserver: Refreshing state... (ID: i-02489cdf638f05bbd)\n\nAn execution plan has been generated and is shown below.\nResource actions are indicated with the following symbols:\n  - destroy\n\nTerraform will perform the following actions:\n\n  - aws_instance.webserver\n\n\nPlan: 0 to add, 0 to change, 1 to destroy.\n\nDo you really want to destroy?\n  Terraform will destroy all your managed infrastructure, as shown above.\n  There is no undo. Only 'yes' will be accepted to confirm.\n\n  Enter a value: yes\n  [...]\naws_instance.webserver: Still destroying... (ID: i-02489cdf638f05bbd, 1m0s elapsed)\naws_instance.webserver: Destruction complete after 1m0s\n\nDestroy complete! Resources: 1 destroyed.  file: terraform.tfstate  {\n     version : 3,\n     terraform_version :  0.11.7 ,\n     serial : 2,\n     lineage :  138bb0c6-ca69-0d39-aa90-5e08f29c8efb ,\n     modules : [\n        {\n             path : [\n                 root \n            ],\n             outputs : {},\n             resources : {},\n             depends_on : []\n        }\n    ]\n}  Once the machine is destroyed, all metadata about that machine is also gone.", 
            "title": "Changes in Terrfaform state"
        }
    ]
}